[{"id":0,"href":"/icorer_docs/doccenter/redishub/module_test/2.1/","title":"2.1 NetHandle组件测试","section":"系统模块测试","content":" NetHandle # This is a library for building high-performance TCP server applications, standing on the shoulders of Go giants and redcon\n1. Features # High performance, low resource consumption Very easy to use development interface 2. Install # go get -u uriModule/NetHandle\n3. Performance Testing: # 3.1 50*10000 (50 threads X 10000 requests) # 3.2 50*20000 (50 threads X 20000 requests) # 3.3 100*10000 (100 threads X 10000 requests) # "},{"id":1,"href":"/icorer_docs/doccenter/redishub/deploy/3.1/","title":"3.1 部署文档","section":"中间件部署","content":" 一. 系统设计 # 1.1 背景描述 # Redis单实例模式下，出现了机器存储过高,因此进行单实例向集群化的改造，但是由于存在以下两种原因，造成需要自研中间件：\nRedis标准集群不支持跨数据槽的MGET、MSET指令。 PHP生态缺乏并发支持，造成在M指令上性能很差。 最终我们设计RedisHub集群中间件，一方面用它来支持跨数据槽的MSET、MGET指令，一方面借助它的并发优势为PHP底层的M指令指令提高性能。\n1.2 总体设计 # 中间件的总体结构设计图如下所示:\n1.3 设计阐述 # 如图所示，PHP通过Unix Domain Socket途径和中间件进行IPC通信，然后中间件把PHP的redis请求进行处理，并转发到下游的Redis集群中，为PHP业务系统提供无缝的单实例到集群的改造，相关的网络模型如下：\n二. 组件部署文档 # RedisHub中间件 部署主要分为两个部分, 安装相关安装包 和 修改配置并运行.\n2.1 部署准备 # Linux 64bit 操作系统 RedisHub 二进制文件 调整Redishub配置文件：rh_config.yaml RedisHub进程监控工具 ,例如Supervisor 2.2 应用体安装 # 2.2.1 程序体运行 # 由于中间件是个可以方便运行的二进制体，但是我们在运行的时候需要制定配置文件路径，例如以下命令：\n./RedisHub -c /home/corerman/DATA/ICODE/GoLang/RedisHub/config/rh_config.yaml\n具体运行参数，运维伙伴可以自行调整。\n三. 配置文件详解 # 配置文件（rh_config.yaml）是这个系统运行的基础，所以这里将讲解配置文件的相关信息.\n#RedisHub YAML config file #RedisHub Net Config net: listen_uri: unix:/tmp/redis.sock #Unix Domain Socket的监听路径：PHP推荐使用这种模式 #listen_uri: tcp:10.100.183.180:16379 #TCP的监控IP及端口 #RedisHub cluster Config cluster: start_nodes: 10.54.2.8:9736,10.54.2.9:9736,10.54.2.10:9736 #Redis集群的节点，这里可以根据线上实际情况进行配置，多个只是为了保障高可用 conn_timeout: 50 #Redis节点的TCP连接超时时间 （单位：毫秒） conn_read_timeout: 50 #Redis节点的TCP读取超时时间 （单位：毫秒） conn_write_timeout: 50 #Redis节点的TCP写入超时时间 （单位：毫秒） conn_alive_timeout: 60 #Redis节点的TCP最大空闲时间 （单位：秒） conn_pool_size: 150 #针对每一个Redis集群节点的TCP连接池最大值 （单位：个） #RedisHub api config api: http_listen_address: #RedisHub log config # log 相关配置 log: # 日否开启日志 enable: true #是否开启日志功能（true 或 false） # 日志输出位置，支持std(终端) kafka # 注：std仅在调试时使用 output: \u0026#34;kafka\u0026#34; # kafka server的地址 需要修改到指定环境的kafka kafka_address: [\u0026#34;192.168.205.10:9092\u0026#34;, \u0026#34;192.168.205.11:9092\u0026#34;, \u0026#34;192.168.205.12:9092\u0026#34;] kafka_info_topic: \u0026#34;ltlog-info\u0026#34; kafka_error_topic: \u0026#34;ltlog-error\u0026#34; # 日志输出级别控制, 可省略, 默认输出到 error 级别 # 高级别的可以输出低级别的日志， 级别 trace \u0026gt; debug \u0026gt; error \u0026gt; warning \u0026gt; info # 例如 level = error时，不可输出trace和debug级别的日志 level: \u0026#34;error\u0026#34; # 日志中是否报告函数调用信息,可省略 默认为false report_call: false # 机器ip，可为空，默认自动查找 ip: \u0026#34;\u0026#34; # 机器hostname，可为空，默认自动查找 hostname: \u0026#34;\u0026#34; # app_name 默认为 RedisHub app_name: \u0026#34;RedisHub\u0026#34; # 周期上报redis执行信息 （当前是数量） heartbeat_report_second: 120 四 . 稳定性保障方案 # 4.1 进程稳定保障 # RedisHub中间件采用多线程-协程-多核编程,有很好的并发处理能力,经过较为严格的测试没出现过崩溃情况,但是对操作系统目前指抛出一个进程,为了保障RedisHub的运行稳定性 , 所以需要给予配置一个进程监控程序,可以使用Supervisor .\n4.2 更新配置 # 目前仅能通过修改配置文件来更新配置文件,如果需要更新配置,执行的操作有以下两步:\n更新配置文件 重启应用体 五. 运行校验 # 可以通过redis-cli工具连接redisHub中间件，然后测试set\\get\\mset\\mget指令的运行状况，从而判断中间件的运行状况。\n"},{"id":2,"href":"/icorer_docs/doccenter/redishub/system_access/4.1/","title":"4.1 phpredis对接redishub","section":"系统接入","content":" phpredis 对接 RedisHub 改造方案 # 一、背景描述 # phpredis进行Redis集群化改造，对接 RedisHub 中间件，并调整phpredis底层，增加业务降级逻辑。\n二、改造方案 # 2.1、Agent 连接 # 由于 RedisHub 采用 UNIX domain连接，本地部署 Agent 的方式，不存在 port端口，故 redis连接时，无法再传递该参数，需要去掉，具体连接代码如下\npublic function __construct($config, $prefix = \u0026#39;prefix:\u0026#39;) { $this-\u0026gt;prefixH = $prefix; $this-\u0026gt;redisconf = $config; $this-\u0026gt;redis = new \\Redis(); try { $this-\u0026gt;redis-\u0026gt;connect($this-\u0026gt;redisconf[\u0026#39;host\u0026#39;]); } catch (\\Exception $exception) { Logger::getInstance()-\u0026gt;error(\u0026#39;Redis agent connect error, \u0026#39; . $exception-\u0026gt;getMessage() . \u0026#39;, \u0026#39; . $this-\u0026gt;redisconf[\u0026#39;host\u0026#39;]); try { //redis集群中间件服务不可用，降级 $this-\u0026gt;redis = new \\RedisCluster(null, $this-\u0026gt;redisconf[\u0026#39;cluster\u0026#39;][\u0026#39;node\u0026#39;], $this-\u0026gt;redisconf[\u0026#39;cluster\u0026#39;][\u0026#39;timeout\u0026#39;], $this-\u0026gt;redisconf[\u0026#39;cluster\u0026#39;][\u0026#39;readTimeout\u0026#39;], $this-\u0026gt;redisconf[\u0026#39;cluster\u0026#39;][\u0026#39;persistent\u0026#39;]); } catch (\\Exception $exception) { Logger::getInstance()-\u0026gt;error(\u0026#39;RedisCluster connect error, \u0026#39; . $exception-\u0026gt;getMessage()); } } $this-\u0026gt;redis-\u0026gt;setOption(\\Redis::OPT_PREFIX, $prefix); } 我们可以看到，原先的连接方式几乎没有改动，只是去掉了port参数\n2.2、降级方案 # 针对 Agent可能产生异常的情形，我们做了降级方案，代码如上。当检测到连接异常时，采用 PHPRedis原生的集群方案，并发送错误日志，此降级对业务是无感知的\n三、过多 KEY 分片 # 为了避免 mget操作大数量级的 key，造成性能的下降，针对超过 200（可自定义）数量级的 key进行分片操作，代码如下\npublic function getMultiple($keys) { try { if (count($keys) \u0026gt; self::CHUNK_SIZE) { $data = array(); try { //针对200key以上分片读取 foreach (array_chunk($keys, self::CHUNK_SIZE) as $val) { $data = array_merge($data, $this-\u0026gt;redis-\u0026gt;mget($val)); } return $data; } catch (\\Exception $exception) { Logger::getInstance()-\u0026gt;warn(\u0026#39;redis getMultiple(mget) error, error message : \u0026#39; . $exception-\u0026gt;getMessage()); return false; } } return $this-\u0026gt;redis-\u0026gt;mget($keys); } catch (\\Exception $ex) { if (strpos($ex-\u0026gt;getMessage(), \u0026#39;protocol error\u0026#39;) !== false) { Logger::getInstance()-\u0026gt;warn(\u0026#39;protocol error : php redis getMultiple(mget) error, the key is \u0026#39; . implode($keys) . \u0026#39;. error message : \u0026#39; . $ex-\u0026gt;getMessage()); $this-\u0026gt;repconnect(); } return false; } } 我们定义了一个常量 CHUNK_SIZE，设置为 200，当 key数量大于 200 时，进行分片，每 200 key为单位，分批请求，再将结果进行合并返回，一旦中间出现任何错误，函数终止，返回 false\n四、配置文件 # 业务框架需要配合修改redis.php配置文件,deom 如下\n\u0026lt;?php // phpredis配置文件 return [ \u0026#39;cache\u0026#39; =\u0026gt; [ \u0026#39;host\u0026#39; =\u0026gt; \u0026#39;/tmp/redis.sock\u0026#39;, \u0026#39;port\u0026#39; =\u0026gt; \u0026#39;16379\u0026#39;, \u0026#39;cluster\u0026#39; =\u0026gt; [ \u0026#39;node\u0026#39; =\u0026gt; [ \u0026#39;node1\u0026#39;, \u0026#39;node2\u0026#39;, \u0026#39;node3\u0026#39;, \u0026#39;node4\u0026#39; ], \u0026#39;timeout\u0026#39; =\u0026gt; 1.5, \u0026#39;readTimeout\u0026#39; =\u0026gt; 1.5, \u0026#39;persistent\u0026#39; =\u0026gt; true ] ], \u0026#39;log\u0026#39; =\u0026gt; [ \u0026#39;host\u0026#39; =\u0026gt; \u0026#39;127.0.0.1\u0026#39;, \u0026#39;port\u0026#39; =\u0026gt; \u0026#39;6379\u0026#39; ], ]; host为Agent的UNIX domain文件地址\nport 可以不填\n新增 cluster 节点，node 为集群地址，timeout 为集群连接超时时间，readTimeout 为读取超时时间，persistent 为长连接参数\n以上参数请根据线上环境自行填写\n五、注意 # 5.1、为了应对降级方案，在使用 RedisCluster 对象的时候，目前线上版本的 PHPRdis为 5.0.0，此版本在集群模式下会有导致 php-fpm 进程崩溃的风险，需要升级到 5.0.2\n5.2、为了提升原生 RedisCluster 的性能，需要在 php.ini 文件中加上 redis.clusters.cache_slots = 1\n"},{"id":3,"href":"/icorer_docs/doccenter/ak-2019/architecture/overview/","title":"OverView","section":"Architecture","content":" OverView # "},{"id":4,"href":"/icorer_docs/doccenter/logdarts/architecture/overview/","title":"OverView","section":"Architecture","content":" OverView # "},{"id":5,"href":"/icorer_docs/doccenter/pulseflow/architecture/overview/","title":"OverView","section":"Architecture","content":" OverView # "},{"id":6,"href":"/icorer_docs/doccenter/redishub/designs/overview/","title":"OverView","section":"系统设计","content":" OverView # "},{"id":7,"href":"/icorer_docs/doccenter/redistun/designs/overview/","title":"OverView","section":"系统设计","content":" OverView # "},{"id":8,"href":"/icorer_docs/doccenter/redishub/","title":"RedisHub","section":"项目总览","content":"RedisHub 是一款Redis集群中间件，帮助PHP环境平滑迁移Redis集群模式，通过中间件可以解耦业务代码和redis集群之间的关系，降低开发人员对于redis集群的理解心智。中间件实现高性能网络通信、RESP协议与Redis集群协议解析，实现集群模式下的MSET/MGET指令跨槽及并发流水吞吐，为PHP请求远程Redis集群提供更高的性能及稳定性。\n一. 总体设计 # RedisHub在组件设计上分为以下几部分:\nAgent配置解析器：负责对于配置文件进行解析（后续增加统一配置中心的支持） 通信组件: 包括UNIX本地监听组 和 远端Redis集群TCP长连接及连接池。 协议分析器: 提供稳定的Redis协议解析及组装功能组件。 协议拦截器: 主要对某些Redis命令进行拦截,调用协议插件组进行功能扩展. 协议插件组: 为协议分析器添加一系列插件,对通信进行优化和功能扩展，例如集群的mset、mget、del操作。 容灾器: 为Agent运行提供必要的安全保障,主要包括进程资源监控,迭代更新监控. 具体的组件总体架构如下图: 二. 网络代理设计 # RedisHub很重要的是网络代理部分,在网络代理方面由三部分组成.\n第一部分是对远程redis集群的连接池. 第二部分是对本地众多php-fpm客户端的UNIX请求连接管理. 第三部分是对这三端之间redis通信协议进行兼容. "},{"id":9,"href":"/icorer_docs/doccenter/redishub/designs/1.1/","title":"1.1基础运行框架","section":"系统设计","content":" 一. 基础运行框架 # 1.1 设计概述 # 基础运行框架也可以成为程序组织结构,一个项目必须要有足够清晰的工程文件结构. 在清晰的工程结构下,系统的各个模块才会有适合自己的存储位置,从存储位置可以上升为代码的调用路径,好的基础运行框架,既可以让系统的源码结构清楚很多,也可以降低模块间的耦合度,提高系统的稳定性.\n1.2 工程框架组成部分 # 在此项目工程结构中,最外层的文件结构主要包括以下几部分, 项目工程一级文件结构如下图所示:\ncmd目录 : 此目录是工程运行体的源码目录,也就是最终会编译出来的可执行体的源码目录,这个目录包括 proxy,daemon目录. config目录 : 配置文件存储目录. deploy目录 : 工程部署目录,里面会包含一些部署脚本和部署工具. doc目录 : 文档目录 ,里面包括一系列的子文件夹,用来保存每个子功能的描述文档. example目录 : 样例目录,对于一些对外提供的功能模块做一些功能示例. script目录 : 脚本目录,里面的脚本相对与deploy目录里的脚本更偏向于一些模块测试脚本. src目录 : 模块源代码目录, 这个目录是工程框架中最重要的一部分,主要包括工程的模块元素,其中包括models 、pkg、 proxy 、redishub、 redis、util目录,后面会做更加详细的阐述. vender目录 : 外部库目录,因为外部的包不断更新,这里的vender更偏向于把适合工程的外部依赖库进行镜像保存,主要是为了提高工程的稳定性. 二. 重要部分拆分设计 # 2.1 cmd目录 # 这个是运行体目录,主要存储main包结构的文件源码,目前里面包含两部分:\nRedisHub目录 : RedisHub主程序体 2.2 SRC目录结构 # SRC目录的结构如下图:\n这个目录会包含一些子目录文件夹,主要存储功能包级别的源码文件及源码目录,主要包括:\nmodels目录 : 数据结构目录,存储系统用到的数据结构相关定义 proxy目录 : 代理模块,这个模块专门储存redis代理相关的功能,既包括本地监听级别的backend,也包括协议解析部分的redis目录,还包括plugin插件目录. redhub目录: 这个目录是核心目录,主要的工作任务在于承上启下,因为在src目录下基础单元都是一个个独立的包,但是如何被cmd层的代码顺利调用,还需要redtun在src功能包基础上抽象cmd层调用的操作单元. utils目录 : 框架的套件目录,主要用来存储框架所使用的一系列套件包,例如errors , log , math , redis-client , trace , unsafe , rpc , sync , resolver , usage 等 pkg目录：包含codis redis协议解析器 redis目录：包含redis集群核心功能代码。 "},{"id":10,"href":"/icorer_docs/doccenter/redistun/designs/1.1/","title":"1.1基础运行框架","section":"系统设计","content":" 一. 基础运行框架 # 1.1 设计概述 # 基础运行框架也可以成为程序组织结构,一个项目必须要有足够清晰的工程文件结构. 在清晰的工程结构下,系统的各个模块才会有适合自己的存储位置,从存储位置可以上升为代码的调用路径,好的基础运行框架,既可以让系统的源码结构清楚很多,也可以降低模块间的耦合度,提高系统的稳定性.\n1.2 工程框架组成部分 # 在此项目工程结构中,最外层的文件结构主要包括以下几部分, 项目工程一级文件结构如下图所示:\ncmd目录 : 此目录是工程运行体的源码目录,也就是最终会编译出来的可执行体的源码目录,这个目录包括 proxy,daemon目录. config目录 : 配置文件存储目录. deploy目录 : 工程部署目录,里面会包含一些部署脚本和部署工具. doc目录 : 文档目录 ,里面包括一系列的子文件夹,用来保存每个子功能的描述文档. example目录 : 样例目录,对于一些对外提供的功能模块做一些功能示例. script目录 : 脚本目录,里面的脚本相对与deploy目录里的脚本更偏向于一些模块测试脚本. src目录 : 模块源代码目录, 这个目录是工程框架中最重要的一部分,主要包括工程的模块元素,其中包括models , proxy , redtun , utils目录,后面会做更加详细的阐述. vender目录 : 外部库目录,因为外部的包不断更新,这里的vender更偏向于把适合工程的外部依赖库进行镜像保存,主要是为了提高工程的稳定性. 二. 重要部分拆分设计 # 2.1 cmd目录 # 这个是运行体目录,主要存储main包结构的文件源码,目前里面包含两部分:\nproxy目录 : redisTunel主程序体 daemon目录 : redisTunel的容灾器程序体 2.2 SRC目录结构 # SRC目录的结构如下图:\n这个目录会包含一些子目录文件夹,主要存储功能包级别的源码文件及源码目录,主要包括:\nmodels目录 : 数据结构目录,存储系统用到的数据结构相关定义 proxy目录 : 代理模块,这个模块专门储存redis代理相关的功能,既包括本地监听级别的backend,也包括协议解析部分的redis目录,还包括plugin插件目录. redtun目录: 这个目录是核心目录,主要的工作任务在于承上启下,因为在src目录下基础单元都是一个个独立的包,但是如何被cmd层的代码顺利调用,还需要redtun在src功能包基础上抽象cmd层调用的操作单元. utils目录 : 框架的套件目录,主要用来存储框架所使用的一系列套件包,例如errors , log , math , redis-client , trace , unsafe , rpc , sync , resolver , usage 等 "},{"id":11,"href":"/icorer_docs/doccenter/redishub/module_test/2.2/","title":"2.2 中间件完整测试","section":"系统模块测试","content":" 零、亿级数据压测 # // 测试脚本 \u0026lt;?php $redis = new Redis(); try { //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $ret = $redis-\u0026gt;set(\u0026#34;hello\u0026#34;, \u0026#34;helloworld\u0026#34;,2); var_dump($ret); $ret = $redis-\u0026gt;get(\u0026#34;hello\u0026#34;); var_dump($ret); $ret = $redis-\u0026gt;del(\u0026#34;hello\u0026#34;); var_dump($ret); $ret = $redis-\u0026gt;mset([\u0026#34;test1\u0026#34; =\u0026gt; \u0026#39;value1\u0026#39;, \u0026#34;test2\u0026#34; =\u0026gt; \u0026#39;value2\u0026#39;]); var_dump($ret); $ret = $redis-\u0026gt;del(\u0026#34;test1\u0026#34;, \u0026#34;test2\u0026#34;, \u0026#34;test3\u0026#34;); var_dump($ret); $ret = $redis-\u0026gt;mget([\u0026#34;test1\u0026#34;, \u0026#34;test2\u0026#34;, \u0026#34;test3\u0026#34;, \u0026#34;test4\u0026#34;, \u0026#34;test5\u0026#34;, \u0026#34;test6\u0026#34;, \u0026#34;test7\u0026#34;, \u0026#34;test8\u0026#34;, \u0026#34;test9\u0026#34;, \u0026#34;test10\u0026#34;, \u0026#34;test11\u0026#34;, \u0026#34;test12\u0026#34;, \u0026#34;test13\u0026#34;, \u0026#34;test14\u0026#34;, \u0026#34;test15\u0026#34;, \u0026#34;test16\u0026#34;, \u0026#34;test17\u0026#34;, \u0026#34;test18\u0026#34;, \u0026#34;test19\u0026#34;, \u0026#34;test20\u0026#34;]); var_dump($ret); $ret = $redis-\u0026gt;rPush(\u0026#34;push\u0026#34;,\u0026#34;key1\u0026#34;,2019,\u0026#34;key2\u0026#34;); var_dump($ret); $val1 = $redis-\u0026gt;lPop(\u0026#34;push\u0026#34;); var_dump($val1); $val1 = $redis-\u0026gt;lPop(\u0026#34;push\u0026#34;); var_dump($val1); $val1 = $redis-\u0026gt;lPop(\u0026#34;push\u0026#34;); var_dump($val1); } catch (\\Exception $ex) { var_dump($ex-\u0026gt;getMessage()); } # 终端输出 ______ _ _ _ _ _ (_____ \\ | (_) (_) (_) | | _____) )_____ __| |_ ___ _______ _ _| |__ | __ /| ___ |/ _ | |/___) ___ | | | | _ \\ | | \\ \\| ____( (_| | |___ | | | | |_| | |_) ) |_| |_|_____)\\____|_(___/|_| |_|____/|____/ 2019/09/15 09:40:27 main.go:69: UNIX-Server: /tmp/redis.socks {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;RedisHub Heart-Beat-Report running.\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:40:27.222+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;RedisHub-UNIX begin running\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:40:27.222+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 1978910\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:42:27.222+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 3674420\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:44:27.222+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 7971749\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:46:27.223+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 13502078\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:48:27.223+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 19082608\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:50:27.224+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 24676646\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:52:27.224+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 30279296\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:54:27.225+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 35869386\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:56:27.225+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 41462169\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T09:58:27.226+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 47037700\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:00:27.227+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 52639532\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:02:27.227+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 58224711\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:04:27.229+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 63814850\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:06:27.229+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 69385735\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:08:27.229+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 74981851\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:10:27.230+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 80565352\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:12:27.230+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 86114343\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:14:27.231+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 91721982\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:16:27.231+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 97338179\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:18:27.231+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 102913090\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:20:27.231+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 102913090\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:22:27.232+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 102913090\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:24:27.232+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 102913090\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:26:27.233+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 102913100\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:28:27.233+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 102913270\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:30:27.340+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 102913270\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:32:27.341+0800\u0026#34;} {\u0026#34;appName\u0026#34;:\u0026#34;RedisHub\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;corerman-WorkStation\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;heartbeat report info: command parse count : 102913270\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2019-09-15T10:34:27.341+0800\u0026#34;} 一、Redis基准压测性能对比 # corerman@corerman-WorkStation:~$ redis-benchmark -p 6379 -t get,set,rpush,lpop,setex,psetex,del -n 200000 -c 50 -q SET: 129785.85 requests per second GET: 128865.98 requests per second RPUSH: 131839.16 requests per second LPOP: 131061.59 requests per second corerman@corerman-WorkStation:~$ redis-benchmark -s /tmp/redis.socks -t get,set,rpush,lpop,setex,psetex,del -n 200000 -c 50 -q SET: 116754.23 requests per second GET: 105932.20 requests per second RPUSH: 116686.12 requests per second LPOP: 105652.41 requests per second 通过上面可以看出，SET、GET、RPUSH、LPOP性能损耗不大\n二. 中间件和标准集群下，phpredis的表现及性能 # phpredis 5.0.2版本 需要在php.ini 中增加 redis.clusters.cache_slots = 1，开启redis集群的slots信息缓存，总而提升性能。\n2.1 SET指令 （OK） # 2.1.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $status = $redis-\u0026gt;set(\u0026#34;test\u0026#34;,\u0026#34;testval\u0026#34;); var_dump($status); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(true)\n2.1.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redisCluster = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $status = $redisCluster-\u0026gt;set(\u0026#34;test\u0026#34;,\u0026#34;testval\u0026#34;); var_dump($status); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(true)\n2.1.3 压测数据对比 # #中间件 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 11 bytes Concurrency Level: 20 Time taken for tests: 6.229 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19000000 bytes HTML transferred: 1100000 bytes Requests per second: 16054.15 [#/sec] (mean) Time per request: 1.246 [ms] (mean) Time per request: 0.062 [ms] (mean, across all concurrent requests) Transfer rate: 2978.80 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 2 Processing: 0 1 2.9 1 213 Waiting: 0 1 2.9 1 213 Total: 0 1 2.9 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 3 99% 4 100% 213 (longest request) # phpredis直连标准集群 ： 开启slot缓存 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 11 bytes Concurrency Level: 20 Time taken for tests: 5.609 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19000000 bytes HTML transferred: 1100000 bytes Requests per second: 17829.52 [#/sec] (mean) Time per request: 1.122 [ms] (mean) Time per request: 0.056 [ms] (mean, across all concurrent requests) Transfer rate: 3308.21 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 2.0 1 213 Waiting: 0 1 2.0 1 212 Total: 0 1 2.0 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 2 99% 3 100% 213 (longest request) # phpredis直连标准集群 ： 未开启slot缓存 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 11 bytes Concurrency Level: 20 Time taken for tests: 10.369 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19000000 bytes HTML transferred: 1100000 bytes Requests per second: 9643.96 [#/sec] (mean) Time per request: 2.074 [ms] (mean) Time per request: 0.104 [ms] (mean, across all concurrent requests) Transfer rate: 1789.41 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 3.2 0 1018 Processing: 1 2 4.1 2 214 Waiting: 1 2 4.1 2 214 Total: 1 2 5.2 2 1021 Percentage of the requests served within a certain time (ms) 50% 2 66% 2 75% 2 80% 2 90% 2 95% 2 98% 3 99% 3 100% 1021 (longest request) 2.2 SETEX指令 （OK） # 2.2.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $status = $redis-\u0026gt;set(\u0026#34;test\u0026#34;,\u0026#34;testval\u0026#34;，5); //内部调用setex var_dump($status); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(true)\n2.2.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redis = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $status = $redis-\u0026gt;set(\u0026#34;test\u0026#34;,\u0026#34;testval\u0026#34;，5); //内部调用setex var_dump($status); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(true)\n2.2.3 压测数据对比 # # 中间件 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 11 bytes Concurrency Level: 20 Time taken for tests: 6.258 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19000000 bytes HTML transferred: 1100000 bytes Requests per second: 15979.34 [#/sec] (mean) Time per request: 1.252 [ms] (mean) Time per request: 0.063 [ms] (mean, across all concurrent requests) Transfer rate: 2964.92 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 2.6 1 211 Waiting: 0 1 2.6 1 211 Total: 0 1 2.6 1 211 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 3 99% 3 100% 211 (longest request) # 标准集群 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 11 bytes Concurrency Level: 20 Time taken for tests: 5.600 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19000000 bytes HTML transferred: 1100000 bytes Requests per second: 17858.46 [#/sec] (mean) Time per request: 1.120 [ms] (mean) Time per request: 0.056 [ms] (mean, across all concurrent requests) Transfer rate: 3313.58 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 2.0 1 209 Waiting: 0 1 2.0 1 209 Total: 0 1 2.0 1 210 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 2 99% 3 100% 210 (longest request) 2.3 PSETEX指令 （OK） # 2.3.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $status = $redis-\u0026gt;set(\u0026#34;test\u0026#34;,\u0026#34;testval\u0026#34;, [\u0026#39;xx\u0026#39;, \u0026#39;px\u0026#39;=\u0026gt;1000]); var_dump($status); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(true)\n2.3.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redisCluster = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $status = $redisCluster-\u0026gt;set(\u0026#34;test\u0026#34;,\u0026#34;testval\u0026#34;, [\u0026#39;xx\u0026#39;, \u0026#39;px\u0026#39;=\u0026gt;1000]); var_dump($status); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(true)\n2.3.3 压测数据对比 # # 中间件 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 11 bytes Concurrency Level: 20 Time taken for tests: 6.265 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19000000 bytes HTML transferred: 1100000 bytes Requests per second: 15962.77 [#/sec] (mean) Time per request: 1.253 [ms] (mean) Time per request: 0.063 [ms] (mean, across all concurrent requests) Transfer rate: 2961.84 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 2.9 1 213 Waiting: 0 1 2.9 1 213 Total: 0 1 2.9 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 3 99% 4 100% 213 (longest request) # 标准集群 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 11 bytes Concurrency Level: 20 Time taken for tests: 5.696 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19000000 bytes HTML transferred: 1100000 bytes Requests per second: 17555.61 [#/sec] (mean) Time per request: 1.139 [ms] (mean) Time per request: 0.057 [ms] (mean, across all concurrent requests) Transfer rate: 3257.39 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 3 Processing: 0 1 1.8 1 214 Waiting: 0 1 1.8 1 214 Total: 0 1 1.8 1 214 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 3 99% 4 100% 214 (longest request) 2.4 GET指令 （数据存在：1KB 标准数据） （OK） # 2.4.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $ret = $redis-\u0026gt;get(\u0026#34;test\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 能够成功获取到1KB数据。\n2.4.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redis = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $ret = $redis-\u0026gt;get(\u0026#34;test\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 能够成功获取到1KB数据。\n2.4.3 压测数据对比 # # 中间件 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 0 bytes Concurrency Level: 20 Time taken for tests: 6.025 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 17900000 bytes HTML transferred: 0 bytes Requests per second: 16597.96 [#/sec] (mean) Time per request: 1.205 [ms] (mean) Time per request: 0.060 [ms] (mean, across all concurrent requests) Transfer rate: 2901.40 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 2 Processing: 0 1 2.8 1 213 Waiting: 0 1 2.8 1 213 Total: 0 1 2.8 1 214 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 3 99% 3 100% 214 (longest request) # 标准集群 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 0 bytes Concurrency Level: 20 Time taken for tests: 5.314 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 17900000 bytes HTML transferred: 0 bytes Requests per second: 18818.88 [#/sec] (mean) Time per request: 1.063 [ms] (mean) Time per request: 0.053 [ms] (mean, across all concurrent requests) Transfer rate: 3289.63 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 2 Processing: 0 1 1.8 1 213 Waiting: 0 1 1.8 1 212 Total: 0 1 1.8 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 1 95% 2 98% 2 99% 3 100% 213 (longest request) 2.5 GET指令 （数据不存在） （OK） # 2.5.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $ret = $redis-\u0026gt;get(\u0026#34;test\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(false)\n2.5.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redis = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $ret = $redis-\u0026gt;get(\u0026#34;test\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(false)\n2.5.3 压测数据对比 # # 中间件 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 12 bytes Concurrency Level: 20 Time taken for tests: 6.012 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19100000 bytes HTML transferred: 1200000 bytes Requests per second: 16632.40 [#/sec] (mean) Time per request: 1.202 [ms] (mean) Time per request: 0.060 [ms] (mean, across all concurrent requests) Transfer rate: 3102.33 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 2 Processing: 0 1 2.9 1 213 Waiting: 0 1 2.9 1 213 Total: 0 1 2.9 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 3 99% 3 100% 213 (longest request) # 标准集群 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 12 bytes Concurrency Level: 20 Time taken for tests: 5.313 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19100000 bytes HTML transferred: 1200000 bytes Requests per second: 18822.79 [#/sec] (mean) Time per request: 1.063 [ms] (mean) Time per request: 0.053 [ms] (mean, across all concurrent requests) Transfer rate: 3510.89 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 2.0 1 212 Waiting: 0 1 2.0 1 212 Total: 0 1 2.0 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 1 95% 2 98% 2 99% 3 100% 213 (longest request) 2.6 RPUSH指令 （异常情况）（OK） # 2.6.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $ret = $redis-\u0026gt;rPush(\u0026#34;test\u0026#34;,\u0026#34;val1\u0026#34;); //由于test 键已经和上面的set冲突，所以会出错 var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(false)\n2.6.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redis = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $ret = $redis-\u0026gt;rPush(\u0026#34;test\u0026#34;,\u0026#34;val1\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(false)\n2.6.3 压测数据对比 # # 中间件 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 12 bytes Concurrency Level: 20 Time taken for tests: 5.777 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19100000 bytes HTML transferred: 1200000 bytes Requests per second: 17309.96 [#/sec] (mean) Time per request: 1.155 [ms] (mean) Time per request: 0.058 [ms] (mean, across all concurrent requests) Transfer rate: 3228.71 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 2 Processing: 0 1 2.4 1 213 Waiting: 0 1 2.4 1 213 Total: 0 1 2.4 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 2 99% 3 100% 213 (longest request) # 标准集群 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 12 bytes Concurrency Level: 20 Time taken for tests: 5.570 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 19100000 bytes HTML transferred: 1200000 bytes Requests per second: 17952.40 [#/sec] (mean) Time per request: 1.114 [ms] (mean) Time per request: 0.056 [ms] (mean, across all concurrent requests) Transfer rate: 3348.54 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 1.9 1 210 Waiting: 0 1 1.9 1 210 Total: 0 1 1.9 1 210 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 1 95% 2 98% 2 99% 3 100% 210 (longest request) 2.7 RPUSH指令 （成功情况）（OK） # 2.7.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $ret = $redis-\u0026gt;rPush(\u0026#34;pushtest1\u0026#34;,\u0026#34;val1\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：int(1)\n2.7.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redis = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $ret = $redis-\u0026gt;rPush(\u0026#34;pushtest2\u0026#34;,\u0026#34;val1\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：int(1)\n2.7.3 压测数据对比 # # 中间件 压测后计数正常 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 7 bytes Concurrency Level: 20 Time taken for tests: 6.132 seconds Complete requests: 100000 Failed requests: 99992 (Connect: 0, Receive: 0, Length: 99992, Exceptions: 0) Total transferred: 18988900 bytes HTML transferred: 1088900 bytes Requests per second: 16307.69 [#/sec] (mean) Time per request: 1.226 [ms] (mean) Time per request: 0.061 [ms] (mean, across all concurrent requests) Transfer rate: 3024.07 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 1.7 1 213 Waiting: 0 1 1.7 1 213 Total: 0 1 1.7 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 3 99% 3 100% 213 (longest request) # 标准集群 压测后计数正常 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 7 bytes Concurrency Level: 20 Time taken for tests: 5.558 seconds Complete requests: 100000 Failed requests: 99991 (Connect: 0, Receive: 0, Length: 99991, Exceptions: 0) Total transferred: 18988895 bytes HTML transferred: 1088895 bytes Requests per second: 17992.50 [#/sec] (mean) Time per request: 1.112 [ms] (mean) Time per request: 0.056 [ms] (mean, across all concurrent requests) Transfer rate: 3336.50 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 3 Processing: 0 1 2.3 1 213 Waiting: 0 1 2.3 1 213 Total: 0 1 2.4 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 1 95% 2 98% 2 99% 3 100% 213 (longest request) 2.8 LPOP指令（OK） # 2.8.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $ret = $redis-\u0026gt;lPop(\u0026#34;pushtest1\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 结果：可以正常消费，并且当没有数据后 返回false\n2.8.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redis = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $ret = $redis-\u0026gt;lPop(\u0026#34;pushtest2\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 结果：可以正常消费，并且当没有数据后 返回false\n2.8.3 压测数据对比 # # 中间件 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 17 bytes Concurrency Level: 20 Time taken for tests: 5.839 seconds Complete requests: 100000 Failed requests: 97496 (Connect: 0, Receive: 0, Length: 97496, Exceptions: 0) Total transferred: 19112520 bytes HTML transferred: 1212520 bytes Requests per second: 17126.52 [#/sec] (mean) Time per request: 1.168 [ms] (mean) Time per request: 0.058 [ms] (mean, across all concurrent requests) Transfer rate: 3196.59 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 2.7 1 213 Waiting: 0 1 2.7 1 213 Total: 0 1 2.7 1 213 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 3 99% 3 100% 213 (longest request) # 标准集群 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 17 bytes Concurrency Level: 20 Time taken for tests: 5.419 seconds Complete requests: 100000 Failed requests: 47803 (Connect: 0, Receive: 0, Length: 47803, Exceptions: 0) Total transferred: 19360985 bytes HTML transferred: 1460985 bytes Requests per second: 18453.22 [#/sec] (mean) Time per request: 1.084 [ms] (mean) Time per request: 0.054 [ms] (mean, across all concurrent requests) Transfer rate: 3488.99 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 1.8 1 209 Waiting: 0 1 1.8 1 209 Total: 0 1 1.8 1 209 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 1 95% 2 98% 2 99% 3 100% 209 (longest request) 2.9 MGET指令（OK） # 2.9.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $ret = $redis-\u0026gt;mget([\u0026#34;test1\u0026#34;,\u0026#34;test2\u0026#34;,\u0026#34;test3\u0026#34;,\u0026#34;test4\u0026#34;,\u0026#34;test5\u0026#34;,\u0026#34;test6\u0026#34;,\u0026#34;test7\u0026#34;,\u0026#34;test8\u0026#34;,\u0026#34;test9\u0026#34;,\u0026#34;test10\u0026#34;,\u0026#34;test11\u0026#34;,\u0026#34;test12\u0026#34;,\u0026#34;test13\u0026#34;,\u0026#34;test14\u0026#34;,\u0026#34;test15\u0026#34;,\u0026#34;test16\u0026#34;,\u0026#34;test17\u0026#34;,\u0026#34;test18\u0026#34;,\u0026#34;test19\u0026#34;,\u0026#34;test20\u0026#34;]); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：\narray(20) { [0]=\u0026gt; string(6) \u0026#34;value1\u0026#34; [1]=\u0026gt; string(6) \u0026#34;value2\u0026#34; [2]=\u0026gt; bool(false) [3]=\u0026gt; bool(false) [4]=\u0026gt; bool(false) [5]=\u0026gt; bool(false) [6]=\u0026gt; bool(false) [7]=\u0026gt; bool(false) [8]=\u0026gt; bool(false) [9]=\u0026gt; bool(false) [10]=\u0026gt; bool(false) [11]=\u0026gt; bool(false) [12]=\u0026gt; bool(false) [13]=\u0026gt; bool(false) [14]=\u0026gt; bool(false) [15]=\u0026gt; bool(false) [16]=\u0026gt; bool(false) [17]=\u0026gt; bool(false) [18]=\u0026gt; bool(false) [19]=\u0026gt; bool(false) } 2.9.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redis = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $ret = $redis-\u0026gt;mget([\u0026#34;test1\u0026#34;,\u0026#34;test2\u0026#34;,\u0026#34;test3\u0026#34;,\u0026#34;test4\u0026#34;,\u0026#34;test5\u0026#34;,\u0026#34;test6\u0026#34;,\u0026#34;test7\u0026#34;,\u0026#34;test8\u0026#34;,\u0026#34;test9\u0026#34;,\u0026#34;test10\u0026#34;,\u0026#34;test11\u0026#34;,\u0026#34;test12\u0026#34;,\u0026#34;test13\u0026#34;,\u0026#34;test14\u0026#34;,\u0026#34;test15\u0026#34;,\u0026#34;test16\u0026#34;,\u0026#34;test17\u0026#34;,\u0026#34;test18\u0026#34;,\u0026#34;test19\u0026#34;,\u0026#34;test20\u0026#34;]); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：\narray(20) { [0]=\u0026gt; string(6) \u0026#34;value1\u0026#34; [1]=\u0026gt; string(6) \u0026#34;value2\u0026#34; [2]=\u0026gt; bool(false) [3]=\u0026gt; bool(false) [4]=\u0026gt; bool(false) [5]=\u0026gt; bool(false) [6]=\u0026gt; bool(false) [7]=\u0026gt; bool(false) [8]=\u0026gt; bool(false) [9]=\u0026gt; bool(false) [10]=\u0026gt; bool(false) [11]=\u0026gt; bool(false) [12]=\u0026gt; bool(false) [13]=\u0026gt; bool(false) [14]=\u0026gt; bool(false) [15]=\u0026gt; bool(false) [16]=\u0026gt; bool(false) [17]=\u0026gt; bool(false) [18]=\u0026gt; bool(false) [19]=\u0026gt; bool(false) } 2.9.3 压测数据对比 # # 中间件 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 478 bytes Concurrency Level: 20 Time taken for tests: 8.120 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 65700000 bytes HTML transferred: 47800000 bytes Requests per second: 12315.93 [#/sec] (mean) Time per request: 1.624 [ms] (mean) Time per request: 0.081 [ms] (mean, across all concurrent requests) Transfer rate: 7901.92 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 2.5 1 214 Waiting: 0 1 2.5 1 214 Total: 0 2 2.5 1 215 Percentage of the requests served within a certain time (ms) 50% 1 66% 2 75% 2 80% 2 90% 2 95% 3 98% 3 99% 4 100% 215 (longest request) # 标准集群 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 478 bytes Concurrency Level: 20 Time taken for tests: 13.117 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 65700000 bytes HTML transferred: 47800000 bytes Requests per second: 7623.54 [#/sec] (mean) Time per request: 2.623 [ms] (mean) Time per request: 0.131 [ms] (mean, across all concurrent requests) Transfer rate: 4891.28 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 1 Processing: 1 3 2.4 2 213 Waiting: 1 3 2.4 2 213 Total: 1 3 2.4 2 213 Percentage of the requests served within a certain time (ms) 50% 2 66% 3 75% 3 80% 3 90% 4 95% 4 98% 5 99% 5 100% 213 (longest request) 2.10 DEL指令（OK） # 2.10.1 中间件 # \u0026lt;?php $redis = new Redis(); try{ //connect 是 异常级别 $redis-\u0026gt;connect(\u0026#39;/tmp/redis.socks\u0026#39;); $ret = $redis-\u0026gt;mset([\u0026#34;test1\u0026#34;=\u0026gt;\u0026#39;value1\u0026#39;,\u0026#34;test2\u0026#34;=\u0026gt;\u0026#39;value2\u0026#39;]); var_dump($ret); $ret = $redis-\u0026gt;del(\u0026#34;test1\u0026#34;,\u0026#34;test2\u0026#34;,\u0026#34;test3\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(true) int(2)\n2.10.2 标准集群 # \u0026lt;?php try{ //connect 是 异常级别 $redis = new RedisCluster(NULL, Array(\u0026#34;127.0.0.1:9001\u0026#34;), 1.5, 1.5, true); $ret = $redis-\u0026gt;mset([\u0026#34;test1\u0026#34;=\u0026gt;\u0026#39;value1\u0026#39;,\u0026#34;test2\u0026#34;=\u0026gt;\u0026#39;value2\u0026#39;]); var_dump($ret); $ret = $redis-\u0026gt;del(\u0026#34;test1\u0026#34;,\u0026#34;test2\u0026#34;,\u0026#34;test3\u0026#34;); var_dump($ret); }catch (\\Exception $ex){ var_dump($ex-\u0026gt;getMessage()); } 运行结果：bool(true) int(2)\n2.10.3 压测数据对比 # # 中间件 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_agent.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_agent.php Document Length: 7 bytes Concurrency Level: 20 Time taken for tests: 7.240 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 18600000 bytes HTML transferred: 700000 bytes Requests per second: 13811.28 [#/sec] (mean) Time per request: 1.448 [ms] (mean) Time per request: 0.072 [ms] (mean, across all concurrent requests) Transfer rate: 2508.69 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 2.6 1 215 Waiting: 0 1 2.6 1 215 Total: 0 1 2.6 1 215 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 2 80% 2 90% 2 95% 2 98% 3 99% 4 100% 215 (longest request) # 标准集群 corerman@corerman-WorkStation:~$ ab -n 100000 -c 20 http://lab.test.local/redis_cluster.php This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1807734 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking lab.test.local (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx Server Hostname: lab.test.local Server Port: 80 Document Path: /redis_cluster.php Document Length: 7 bytes Concurrency Level: 20 Time taken for tests: 6.447 seconds Complete requests: 100000 Failed requests: 0 Total transferred: 18600000 bytes HTML transferred: 700000 bytes Requests per second: 15511.04 [#/sec] (mean) Time per request: 1.289 [ms] (mean) Time per request: 0.064 [ms] (mean, across all concurrent requests) Transfer rate: 2817.44 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 0 1 3.1 1 216 Waiting: 0 1 3.1 1 216 Total: 0 1 3.1 1 216 Percentage of the requests served within a certain time (ms) 50% 1 66% 1 75% 1 80% 1 90% 2 95% 2 98% 3 99% 4 100% 216 (longest request) RedisHub 与 phpredis集群客户端指令效果对比 # 一. set指令 （保持一致） # 正常：true 节点损坏：报异常 clusterDown：返回异常，clusterdown异常 二、mset （保持一致） # 正常 ：true 节点损坏：报异常 clusterDown：返回异常，clusterdown异常 三、get （保持一致） # 正常：数据 节点损坏：报异常 clusterDown：返回异常，clusterdown异常 四、mget （节点损坏时有区别，redishub更合理） # 正常：返回数据 ，无数据时为false 节点损坏： phpredis全部不返回，redishub针对存活的数据节点返回数据，不存活的节点返回nil及false clusterDown：返回异常，clusterdown异常 五、DEL # 正常：返回删除数据量\n节点损坏：phpredis报异常、redishub针对存活的数据节点进行数据删除，并统计数量返回，redishub不报异常\nclusterDown：返回异常，clusterdown异常\n六.rpush指令 （保持一致） # 正常 返回：统计量\n节点损坏：报异常\nclusterDown：返回异常，clusterdown异常\n七.lpop指令 （保持一致） # 正常 返回：统计量 节点损坏：报异常 clusterDown：返回异常，clusterdown异常 "},{"id":12,"href":"/icorer_docs/doccenter/ak-2019/architecture/network/","title":"NetWork","section":"Architecture","content":" NetWork Details # "},{"id":13,"href":"/icorer_docs/doccenter/logdarts/architecture/network/","title":"NetWork","section":"Architecture","content":" NetWork Details # "},{"id":14,"href":"/icorer_docs/doccenter/pulseflow/architecture/network/","title":"NetWork","section":"Architecture","content":" NetWork Details # "},{"id":15,"href":"/icorer_docs/doccenter/redishub/designs/1.2/","title":"1.2配置解析器","section":"系统设计","content":" 1.2 配置解析器设计 # Agent配置器, 主要负责解析来自网络 或者 文件系统中的配置文件,目前提供配置文件解析模块,配置解析器设计主要包括以下部分:\n配置信息元素结构. 配置解析器相关解析函数. 配置解析器对外API接口服务,允许动态更新配置. 组成结构图如下: 1.2.1 配置信息元素 # 随着系统功能的不断丰富,系统的配置项目也会越来越多,目前配置解析器主要解析的数据对象包括:\n网络配置项 : 针对中间件网络监听进行配置。 redis集群配置项：针对Redis集群进行配置。 日志配置项：目前提供kafka或日志输出，kafka支持公司标准日志。 1.2.2 配置样例 # #RedisHub YAML config file #RedisHub Net Config net: listen_uri: unix:/var/run/redis.sock #Unix Domain Socket的监听路径：PHP推荐使⽤这种模式 # listen_uri: tcp:10.100.183.180:16379 #TCP的监控IP及端⼝ #RedisHub cluster Config cluster: start_nodes:node1,node2,node3 #Redis集群的节点，这⾥可以根据线上实际情况进⾏配置，多个只是为了保障⾼可⽤ conn_timeout: 200 #Redis节点的TCP连接超时时间 （单位：毫秒） conn_read_timeout: 50 #Redis节点的TCP读取超时时间 （单位：毫秒） conn_write_timeout: 50 #Redis节点的TCP写⼊超时时间 （单位：毫秒） conn_alive_timeout: 60 #Redis节点的TCP最⼤空闲时间 （单位：秒） conn_pool_size: 200 #针对每⼀个Redis集群节点的TCP连接池最⼤值 （单位：个） #RedisHub api config api: http_listen_address: #RedisHub log config # log 相关配置 log: # 日否开启日志 enable: true # 日志输出位置，支持std(终端) kafka # 注：std仅在调试时使用 output: \u0026#34;kafka\u0026#34; # kafka server的地址 需要修改到指定环境的kafka kafka_address: [\u0026#34;10.166.7.139:9092\u0026#34;, \u0026#34;10.166.7.139:9093\u0026#34;, \u0026#34;10.166.7.139:9094\u0026#34;] kafka_info_topic: \u0026#34;ltlog-info\u0026#34; kafka_error_topic: \u0026#34;ltlog-error\u0026#34; # 日志输出级别控制, 可省略, 默认输出到 error 级别 # 高级别的可以输出低级别的日志， 级别 trace \u0026gt; debug \u0026gt; error \u0026gt; warning \u0026gt; info # 例如 level = error时，不可输出trace和debug级别的日志 level: \u0026#34;debug\u0026#34; # 日志中是否报告函数调用信息,可省略 默认为false report_call: false # 机器ip，可为空，默认自动查找 ip: \u0026#34;\u0026#34; # 机器hostname，可为空，默认自动查找 hostname: \u0026#34;\u0026#34; # app_name 默认为 RedisHub app_name: \u0026#34;RedisHub\u0026#34; # 周期上报redis执行信息 （单位：秒） heartbeat_report_second: 120 "},{"id":16,"href":"/icorer_docs/doccenter/redistun/designs/1.2/","title":"1.2配置解析器","section":"系统设计","content":" 1.2 配置解析器设计 # Agent配置器, 主要负责解析来自网络 或者 文件系统中的配置文件,目前提供配置文件解析模块,配置解析器设计主要包括以下部分:\n配置信息元素结构. 配置解析器相关解析函数. 配置解析器对外API接口服务,允许动态更新配置. 组成结构图如下: 1.2.1 配置信息元素 # 随着系统功能的不断丰富,系统的配置项目也会越来越多,目前配置解析器主要解析的数据对象包括:\n系统通用配置 : 对系统的通用配置进行解析 网络组配置 : 对通信组件中需要使用的redis集群组进行配置 1.2.2 配置样例 # local_unix_common_uri: /home/corerman/DATA/ICODE/GoLang/RedisTunel-go/bin/unix/ api_http_listen_uri: 127.0.0.1:10000 redis_group_list: - server_name: redis-pool1 group_id : 1 is_enable: true local_unix_name: redis1 master_server : 127.0.0.1:6379 master_conn_pool_size:10,20 master_conn_idle_time_out: 200 slave_server : 127.0.0.1:6380,127.0.0.1:6381,127.0.0.1:6382,127.0.0.1:6383 slave_conn_pool_size:30,40 slave_conn_idle_time_out: 200 - server_name: redis-pool2 group_id : 2 is_enable: true local_unix_name: redis2 master_server : 127.0.1.1:6379 master_conn_pool_size:10,20 master_conn_idle_time_out: 200 slave_server : 127.0.1.1:6380,127.0.1.1:6381,127.0.1.1:6382,127.0.1.1:6383 slave_conn_pool_size:30,40 slave_conn_idle_time_out: 200 上面的配置文件中,配置了两个redis group,每个group中包含主从关系,用来读写分离,也针对每个主从的网络连接配置了相关的连接池配置.\n1.2 解析器工作流程 # 配置解析器有两个加载部分,第一部分在程序初始化阶段,但是这种情况无法做到后期动态更新配置,所以配置解析器还会对外提供api接口,用于更新内部配置 , 相关流程结构图如下:\n"},{"id":17,"href":"/icorer_docs/doccenter/ak-2019/architecture/storage/","title":"Storage","section":"Architecture","content":" Storage Engine Details # "},{"id":18,"href":"/icorer_docs/doccenter/logdarts/architecture/storage/","title":"Storage","section":"Architecture","content":" Storage Engine Details # "},{"id":19,"href":"/icorer_docs/doccenter/pulseflow/architecture/storage/","title":"Storage","section":"Architecture","content":" Storage Engine Details # "},{"id":20,"href":"/icorer_docs/doccenter/redishub/designs/1.3/","title":"1.3通信组件","section":"系统设计","content":" 1.3 通信组件设计 # 通信组件目前不包括协议解析部分,这里的通信组件就是纯粹的网络通信层设计.\n1.3.1 通信组件组成部分 # 目前网络通信层分为两部分:\n本地UNIX监听组,用于高速的IPC通信 每个UNIX监听组所对应一组远端redis服务器,分别对于主从进行连接池连接. 1.3.1 通信组件链路结构 # RedisHub很重要的是网络代理部分,在网络代理方面由三部分组成.\n第一部分是对远程redis集群的连接池. 第二部分是对本地众多php-fpm客户端的UNIX请求连接管理. 第三部分是对这三端之间redis通信协议进行兼容. "},{"id":21,"href":"/icorer_docs/doccenter/redistun/designs/1.3/","title":"1.3通信组件","section":"系统设计","content":" 1.3 通信组件设计 # 通信组件目前不包括协议解析部分,这里的通信组件就是纯粹的网络通信层设计.\n1.3.1 通信组件组成部分 # 目前网络通信层分为两部分:\n本地UNIX监听组,用于高速的IPC通信 每个UNIX监听组所对应一组远端redis服务器,分别对于主从进行连接池连接. 1.3.1 通信组件链路结构 # Redis-Tunel很重要的是网络代理部分,在网络代理方面由三部分组成.\n第一部分是对远程redis-server的连接池. 第二部分是对本地众多php-fpm客户端的UNIX请求连接管理. 第三部分是对这三端之间redis通信协议进行兼容. "},{"id":22,"href":"/icorer_docs/doccenter/ak-2019/architecture/protocol/","title":"Protocol","section":"Architecture","content":" Protocol Details # "},{"id":23,"href":"/icorer_docs/doccenter/logdarts/architecture/protocol/","title":"Protocol","section":"Architecture","content":" Protocol Details # "},{"id":24,"href":"/icorer_docs/doccenter/pulseflow/architecture/protocol/","title":"Protocol","section":"Architecture","content":" Protocol Details # "},{"id":25,"href":"/icorer_docs/doccenter/redishub/designs/1.4/","title":"1.4 协议解析器与拦截器","section":"系统设计","content":" 1.4 协议解析器与拦截器 # 作为网络中间件,我们需要针对网络数据包进行读取之外,还需要对数据包进行解析工作,基于redis协议做了解析之后,我们还需要在解析器的基础上做拦截器,针对不同的redis做不同的处理流程.\n1.4.1 协议解析器设计 # 协议解析器,是一个单独的模块,它主要针对网络数据包进行redis协议的解析工作,虽然redis协议具有统一的数据格式,但是还需要对每种协议命令做兼容操作.\n1.4.2 协议解析器构成成分 # redis协议解析器 : 主要用来解析redis协议 (decoder) redis协议编码器 : 主要用来组装redis协议 (encoder) 1.4.3 解析器 和 拦截器 的工作流程 配合 # 这两个重要组件的功能流程配合如下:\n[PHP-FPM请求] \u0026ndash;\u0026gt;** [RedisHub中间件]** \u0026ndash;\u0026gt; (读取数据包) \u0026ndash;\u0026gt; (解析数据包协议) \u0026ndash;\u0026gt; (对指定命令进行拦截操作) \u0026mdash;\u0026gt; (转发下游redis服务) \u0026ndash;\u0026gt; [下游redis集群] \u0026ndash;\u0026gt; (处理命令并响应) \u0026ndash;\u0026gt; [RedisHub中间件] \u0026mdash;\u0026gt; (响应请求) \u0026mdash;\u0026gt;** [PHP-FPM]**\n"},{"id":26,"href":"/icorer_docs/doccenter/redistun/designs/1.4/","title":"1.4 协议解析器与拦截器","section":"系统设计","content":" 1.4 协议解析器与拦截器 # 作为网络中间件,我们需要针对网络数据包进行读取之外,还需要对数据包进行解析工作,基于redis协议做了解析之后,我们还需要在解析器的基础上做拦截器,针对不同的redis做不同的处理流程.\n1.4.1 协议解析器设计 # 协议解析器,是一个单独的模块,它主要针对网络数据包进行redis协议的解析工作,虽然redis协议具有统一的数据格式,但是还需要对每种协议命令做兼容操作.\n1.4.2 协议解析器构成成分 # redis协议解析器 : 主要用来解析redis协议 (decoder) redis协议编码器 : 主要用来组装redis协议 (encoder) 1.4.3 解析器 和 拦截器 的工作流程 配合 # 这两个重要组件的功能流程配合如下:\n[PHP-FPM请求] \u0026ndash;\u0026gt;** [RedisTunel中间件]** \u0026ndash;\u0026gt; (读取数据包) \u0026ndash;\u0026gt; (解析数据包协议) \u0026ndash;\u0026gt; (对指定命令进行拦截操作) \u0026mdash;\u0026gt; (转发下游redis服务) \u0026ndash;\u0026gt; [下游redis服务] \u0026ndash;\u0026gt; (处理命令并响应) \u0026ndash;\u0026gt; [RedisTunel中间件] \u0026mdash;\u0026gt; (响应请求) \u0026mdash;\u0026gt;** [PHP-FPM]**\n"},{"id":27,"href":"/icorer_docs/doccenter/pulseflow/architecture/codec/","title":"Codec","section":"Architecture","content":" Codec Engine Details # "},{"id":28,"href":"/icorer_docs/doccenter/redishub/designs/1.5/","title":"1.5 NetHandle组件","section":"系统设计","content":" NetHandle # 这是一个库,方便构建高性能TCP服务端应用程序,站在Go语言的巨人肩膀上\n项目地址: uriModule/NetHandle\n一. 特点 # 高性能,低资源消耗 非常简单易用的开发接口 支持众多协议,TCP,UDP,UNIX 二. 安装 # go get -u moduleUri/NetHandle\n三. 性能测试: # 3.1 50*10000 (50线程 X 10000请求) # 3.2 50*20000 (50线程 X 20000请求) # 3.3 100*10000 (100线程 X 10000请求) # 四. 样例代码: # 使用这个库的时候,只需要自定义简单的回调函数,即可构造出性能强悍的网络监听.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;moduleUri/NetHandle\u0026#34; \u0026#34;log\u0026#34; \u0026#34;sync\u0026#34; ) var addrTcp = \u0026#34;127.0.0.1:10000\u0026#34; func main() { log.SetFlags(log.Lshortfile | log.LstdFlags) var mu sync.RWMutex count := 0 go log.Printf(\u0026#34;started server at %s\u0026#34;, addrTcp) err := NetHandle.ListenAndServe(\u0026#34;tcp\u0026#34;, addrTcp, func(conn NetHandle.Conn) { requestData := make([]byte, 512) _, err := conn.NetConn().Read(requestData) if err != nil { conn.Close() return } mu.Lock() count++ mu.Unlock() countCurrent := 0 mu.RLock() countCurrent = count mu.RUnlock() replyData := fmt.Sprintf(\u0026#34;%d\\r\\n\u0026#34;, countCurrent) conn.NetConn().Write(append([]byte(replyData))) }, func(conn NetHandle.Conn) bool { // use this function to accept or deny the connection. log.Printf(\u0026#34;accept: %s\u0026#34;, conn.RemoteAddr()) return true }, func(conn NetHandle.Conn, err error) { // this is called when the connection has been closed log.Printf(\u0026#34;closed: %s, err: %v\u0026#34;, conn.RemoteAddr(), err) }, ) if err != nil { log.Fatal(err) } } "},{"id":29,"href":"/icorer_docs/doccenter/redistun/designs/1.5/","title":"1.5 NetHandle组件","section":"系统设计","content":" NetHandle # 这是一个库,方便构建高性能TCP服务端应用程序,站在Go语言的巨人肩膀上\n项目地址: uriModule/NetHandle\n一. 特点 # 高性能,低资源消耗 非常简单易用的开发接口 支持众多协议,TCP,UDP,UNIX 二. 安装 # go get -u moduleUri/NetHandle\n三. 性能测试: # 3.1 50*10000 (50线程 X 10000请求) # 3.2 50*20000 (50线程 X 20000请求) # 3.3 100*10000 (100线程 X 10000请求) # 四. 样例代码: # 使用这个库的时候,只需要自定义简单的回调函数,即可构造出性能强悍的网络监听.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;moduleUri/NetHandle\u0026#34; \u0026#34;log\u0026#34; \u0026#34;sync\u0026#34; ) var addrTcp = \u0026#34;127.0.0.1:10000\u0026#34; func main() { log.SetFlags(log.Lshortfile | log.LstdFlags) var mu sync.RWMutex count := 0 go log.Printf(\u0026#34;started server at %s\u0026#34;, addrTcp) err := NetHandle.ListenAndServe(\u0026#34;tcp\u0026#34;, addrTcp, func(conn NetHandle.Conn) { requestData := make([]byte, 512) _, err := conn.NetConn().Read(requestData) if err != nil { conn.Close() return } mu.Lock() count++ mu.Unlock() countCurrent := 0 mu.RLock() countCurrent = count mu.RUnlock() replyData := fmt.Sprintf(\u0026#34;%d\\r\\n\u0026#34;, countCurrent) conn.NetConn().Write(append([]byte(replyData))) }, func(conn NetHandle.Conn) bool { // use this function to accept or deny the connection. log.Printf(\u0026#34;accept: %s\u0026#34;, conn.RemoteAddr()) return true }, func(conn NetHandle.Conn, err error) { // this is called when the connection has been closed log.Printf(\u0026#34;closed: %s, err: %v\u0026#34;, conn.RemoteAddr(), err) }, ) if err != nil { log.Fatal(err) } } "},{"id":30,"href":"/icorer_docs/doccenter/redistun/designs/1.6/","title":"1.5 哈希分操器组件","section":"系统设计","content":" 背景描述: # 哈希分槽器,顾名思义,它的主要工作就是根据redis协议中的key值进行哈希计算,并选择相关的存储节点,在不同的节点上完成redis数据的读写操作.\n通过上面的描述,我们可以看出,哈希分槽器主要的设计部分包括如下:\n数据分槽器 : 基于一致性哈希算法,负责key值的落槽工作,每个槽对应一个redis group 单元. 哈希结构及算法 : 需要减少节点添加删除造成的缓存失效问题,所以采用一致性哈希算法. 一. 数据分槽器(Slots) # 在RedTun设计下, 数据分槽器属于Neter的一部分,主要是面向网络组进行服务,数据分槽器前后沟通了一致性哈希算法,服务器group节点,redis客户端请求这三方,是用户的请求可以通过一致性哈希算法准确落到指定的redis group内,响应的group负责读写分离.\n1.1 用户数据分槽流程 # 1.2 分槽器实现 # 为了兼容线上环境,分槽器目前的一致性哈希算法实现高度参考predis的hashring,采用crc32 IEEE作为hash的值计算算法,采用uint32作为hash环的大小.\n1.3 算法兼容性测试 # 为了保障RedTun的一致性哈希算法 和 线上环境predis的一致性哈希算法一致,避免缓存大量失效的情况,目前我们针对这两个算法实现做了单元测试:\n测试总量: **8529820次 ** 随机 key 的哈希生成与结果匹配.\n测试异常: 0次\n总共进行了800多万次测试,两个语言的算法实现没有出现差异结果,说明RedTun内部的一致性哈希算法已经和线上高度一致,不会造成失效问题.\n1.4 一致性哈希的相关数据结构优化 # 1.4.1 哈希环的hash key选择 # 一致性哈希中,每个key的稳定性决定了哈希环上节点位置的稳定性,所以,在RedTun中,对于hash key的选择没有粗略的选择 IP:PORT , 而是在用户配置区间为每个GROUP提供了一个名字叫做\u0026quot;hash_ring_key\u0026quot; , 根据这个字段内的数据进行哈希环的构造.\n二 . 哈希结构及算法 # 现在我们需要设计一个哈希结构,这个哈希结构能够把各个redis group节点映射上来,并且这个哈希结构具有较高的稳定性,当添加或者删除相关的group节点时,不会造成哈希映射的大规模失效.在上述的需求下,我们选择了一致性哈希这个算法.\n2.1 一致性哈希相关解释 # 关于一致性哈希的描述,各处都有比较完善的文章,下面主要摘抄部分来阐述一致性哈希的关键点.\n其实，⼀致性哈希算法也是使⽤取模的⽅法，只是，刚才描述的取模法是对服务器的数量进⾏取模，⽽⼀致性哈希算法是对2^32取模.⾸先，我们把⼆的三⼗⼆次⽅想象成⼀个圆，就像钟表⼀样，钟表的圆可以理解成由60个点组成的圆，⽽此处我们把这个圆想象成由2^32个点组成的圆，⽰意图如下:\n圆环的正上⽅的点代表0，0点右侧的第⼀个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第⼀个点代表2^32-1,我们把这个由2的32次⽅个点组成的圆环称为hash环,假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么这三台服务器肯定有⾃⼰的IP地址，我们使⽤它们各⾃的IP地址进⾏哈希计算，使⽤哈希后的结果对2^32取模，可以使⽤如下公式⽰意。 hash（服务器A的IP地址） % 2^32\n通过上述公式算出的结果⼀定是⼀个0到2^32-1之间的⼀个整数，我们就⽤算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的有⼀个点与这个整数对应，⽽我们刚才已经说明，使⽤这个整数代表服务器A，那么，服务器A就可以映射到这个环上，⽤下图⽰意.\n同理，服务器B与服务器C也可以通过相同的⽅法映射到上图中的hash环中\nhash（服务器B的IP地址） % 2^32\nhash（服务器C的IP地址） % 2^32\n通过上述⽅法，可以将服务器B与服务器C映射到上图中的hash环上，⽰意图如下\n假设，我们需要使⽤缓存服务器缓存图⽚，⽽且我们仍然使⽤图⽚的名称作为找到图⽚的key，那么我们使⽤如下公式可以将图⽚映射到上图中的hash环上。\nhash（图⽚名称） % 2^32\n映射后的⽰意图如下，下图中的橘⻩⾊圆形表⽰图⽚\n好了，现在服务器与图⽚都被映射到了hash环上，那么上图中的这个图⽚到底应该被缓存到哪⼀台服务器上呢？上图中的图⽚将会被缓存到服务器A上，为什么呢？ 位置开始，沿顺时针⽅向遇到的第⼀个服务器就是A服务器，所以，上图中的图⽚将会被缓存到服务器A上，如下图所⽰。\n⼀致性哈希算法就是通过这种⽅法，判断⼀个对象应该被缓存到哪台服务器上的，将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位置出⽅向遇到的第⼀个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，⼀张图⽚必定会被缓存服务器上，那么，当下次想要访问这张图⽚时，只要再次使⽤相同的算法进⾏计算，即可算出这个图⽚被缓存在哪个服务器上，直接去对应的服务器查找对应的图⽚即刚才的⽰例只使⽤了⼀张图⽚进⾏演⽰，假设有四张图⽚需要缓存，⽰意图如下:\n1号、2号图⽚将会被缓存到服务器A上，3号图⽚将会被缓存到服务器B上，4号图⽚将会被缓存到服务器C上。\n"},{"id":31,"href":"/icorer_docs/doccenter/redishub/designs/1.6/","title":"1.5 集群 MSET 指令支持","section":"系统设计","content":" 集群 MSET 指令支持 # "},{"id":32,"href":"/icorer_docs/doccenter/redishub/designs/1.7/","title":"1.7 集群 MGET 指令支持","section":"系统设计","content":" 1.7 集群 MGET 指令支持 # 业务系统为了提高多个key的数据获取吞吐，经常会采用mget指令，这个指令在单实例模式的redis场景下能够完美支持，但是redis标准集群不支持跨槽位执行mget指令。\n但是mget针对业务环境是大量使用的，所以中间件必须完成mget指令在集群中的命令支持。\n1.7.1 指令转换 # 由于Redis不支持跨槽位执行mget指令，因此我们可以变相思维，总体的指令转换如下：\n针对MGET指令的keys进行拆分。 对keys进行hash计算 =\u0026gt; 选择key所对应的node 。 针对node组上的指令进行并发 pipline命令发送。 聚合各个并发线程的指令结果，把远端redis集群内部的数据返回给业务调用方。 1.7.2 MGET指令设计图 # 针对MGET的具体工作情况，我这边绘制了一个图，说明MGET的具体工作原理，红色线路代表一次完整的MGET执行周期。 从上面的图形可以看出，中间件接受到MGET请求后，会把指令中的KYES进行hash计算、并结合node信息选择数据存储的node，针对每个node进行进行pipeline 指令流水吞吐、保障单node下的吞吐高性能，针对不同的node进行并发执行，通过并发技术提高MGET在集群环境下的整体响应速度。\n"},{"id":33,"href":"/icorer_docs/doccenter/redishub/designs/1.8/","title":"1.9 Redis集群状态更新","section":"系统设计","content":" 1.9 Redis集群状态更新 # RedisHub中间件除了要沟通客户端 与 服务端 这两方，还需要及时获取Redis集群的状态信息，并把状态信息转换或更新必要的内存数据结构，内存数据结构最终会被中间件用来承载redis请求。\n1.9.1 状态信息来源 # 集群状态信息的来源主要包括：\n被动方式：集群内部指令执行周期内的MOVE、ASK信号 主动方式：集群 CLUSTER SLOTS 指令 1.9.2 集群槽位状态信息更新 # 关于集群槽位的信息更新，我们主要包括以下两方面策略：\n为了具备更好的性能，我们采用chan 共享内存监听 采用读写锁，提高关键内存共享区的读写安全性及性能 针对更新操作做了秒级限流操作，保障中间件的稳定性。 核心源码分析 如下：\nfunc (cluster *Cluster) handleUpdate() { for { //获取chan列表的更新信号 msg := \u0026lt;-cluster.updateList // TODO: control update frequency by updateTime and movedTime? cluster.rwLock.RLock() clusterLastUpdateTime := cluster.updateTime cluster.rwLock.RUnlock() //如果集群的上一次更新时间 加上窗口值（1s） 小于 此次集群更新指令产生的时间: 证明集群更新频率过高，控制频率。 if clusterLastUpdateTime.Add(1 * time.Second).Before(msg.movedTime) { //针对集群进行状态更新 err := cluster.Update(msg.node) if err != nil { log.Printf(\u0026#34;handleUpdate: %v\\n\u0026#34;, err) go KafkaLoger.Errorf(\u0026#34;redistun handleUpdate wrong. err: %s\u0026#34;, err.Error()) } } } } 1.9.2 指令MOVE 、ASK 信号跟踪 # 如果客户端在请求redis集群的过程中、redis集群出现集群槽位重新分配，会对于请求产生MOVE、ASK信号，为了让中间件支持数据的无缝迁移，我们针对MOVE、ASK进行了特殊处理。\n核心源码分析 如下：\n// 检查回复类型 resp := checkReply(reply) switch (resp) { case kRespOK, kRespError: return reply, nil case kRespMove: //此处在高并发+slots循环多次集中迁移时，会出现数据的多级别MOVE，对于多级别MOVE 要进行到底，一般频率为20万次中出现10次 //所以采用循环进行多级MOVE处理 for { //尝试第一次MOVE，并对结果进行判断，如果reply类型不再是MOVE类型，则证明摆脱多级MOVE，则把结果返回出去 //由于结果可能会发生变化，因此再进行判断 reply, err = cluster.handleMove(node, reply.(redisError).Error(), cmd, args) respType := checkReply(reply) //如果reply类型不是MOVE类型，则 准备跳出循环、对结果进行判断，选择条件返回 if respType != kRespMove { switch (respType) { case kRespOK, kRespError: return reply, nil case kRespAsk: return cluster.handleAsk(node, reply.(redisError).Error(), cmd, args) case kRespConnTimeout: return cluster.handleConnTimeout(node, cmd, args) case kRespClusterDown: //如果redis集群宕机，则返回宕机错误 //选取可用的节点 更新集群状态信息 cluster.UpdateSlotsInfoByRandomNode(node) return reply, Cluster_Down_Error } //此处return为了跳出多级MOVE的for循环 return reply, err } } //return cluster.handleMove(node, reply.(redisError).Error(), cmd, args) case kRespAsk: return cluster.handleAsk(node, reply.(redisError).Error(), cmd, args) case kRespConnTimeout: return cluster.handleConnTimeout(node, cmd, args) case kRespClusterDown: //如果redis集群宕机，则返回宕机错误 //选取可用的节点 更新集群状态信息 cluster.UpdateSlotsInfoByRandomNode(node) return reply, Cluster_Down_Error } "},{"id":34,"href":"/icorer_docs/doccenter/redishub/designs/1.9/","title":"1.8 TCP连接池","section":"系统设计","content":" 1.8 TCP连接池 # 1.8.1 连接池是什么 # 我们常见的池很多，比如内存池，线程池，对象池，连接池等。顾名思义，池子干的事情都是一样的，把一类相同的事物放到一个池里面，已备不时之需，好比我们的蓄水池一样，把平日多余的水储蓄起来，一方面防止洪水到来时候对下游造成洪涝灾害，另一方面还可以合理灌溉资源利用，比如还可以水力发电。同样连接池是把已经已经建立好的连接放入一个池子，当请求到来可以直接拿来使用，这样就即解决了频繁的创建关闭连接带来的开销，也保护了后端服务，防止同时有大量连接涌入，造成危害。\n1.8.2 连接池的种类 # 其实也就是连接池的使用场景\n可以是一个独立部署的服务，通过套接字提供代理服务。例如我们的常用的dbproxy。\n可以是一个服务内部进程间共享的连接池，这种相对更加轻量，可以理解为项目级别，只对内提供服务。\n进程内的连接池，更加轻量，当前进程内的线程或者协程可以使用。\nRedisHub 实现的连接池就是 进程内的连接池，使用连接池有以下好处：\n减少客户端使用连接时，创建和销毁连接的时间和系统资源开销，这里涉及到TCP的三次握手也四次挥手，还有TCP的慢启动预热。 避免极端情况大量连接直接涌入后端服务，对整个系统服务造成危害。 但同时也有一些缺点，比如空闲状态下也要维护一定数量的连接，占用客户端和服务端的资源，这里可以根据实际需求动态调配连接数，达到效率和资源利用的平衡。哪有一点资源不占用，还想系统高效稳定的事情，建个水坝还得占片地，护坝人间断性的职守呢。\n1.8.3 TCP连接池初始化方式 # TCP连接池的最终目标就是对程序体内部需要使用的TCP连接进行池化管理，连接不够使用时自动扩容、连接过剩的时候能够自动回收，所以 我们首先需要考虑TCP连接池的初始化方式。连接池的初始化方式主要包括如下两种：\n当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，创建连接对象，请求结束的时候，归还至连接池.\n进程启动的时候，创建固定数量的连接对象，当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，继续等待或者服务降级; 不为空的话正常服务，请求结束的时候，归还至连接池.\nRedisHub 中间件的TCP连接池初始化方式选择第一种。针对第二种连接池的实现方案，可以查阅本人另外一个项目RedisTun。\n1.8.4 连接池源码分析 - 获取一个可用链接 # func (node *redisNode) getConn() (*redisConn, error) { //需要针对当前的redis-node的tcp连接池进行内存操作，在并发场景下，首先先上锁。 node.mutex.Lock() //如果当前node已经进入不可用状态。 if node.closed { node.mutex.Unlock() return nil, fmt.Errorf(\u0026#34;getConn: connection has been closed\u0026#34;) } //从TCP连接池中清理陈旧的TCP连接，这里面使用了LIST数据结构，可以把陈旧连接进行归并、一并处理。 //如果连接远程node节点时候设置了TCP连接存活时间 则 进行检验。 if node.aliveTime \u0026gt; 0 { for { //从list中选择一个元素，如果conns列表为空 则跳出检查 elem := node.conns.Back() if elem == nil { break } //成功获取到一条TCP连接，进行生命期时间校验 conn := elem.Value.(*redisConn) //如果当前获取的TCP连接是在合法生命周期内部的，立刻退出，但是这个元素还在list中，下次获取仍然能够获取到 if conn.t.Add(node.aliveTime).After(time.Now()) { break } //运行到这里，代表TCP连接生命期超时，删除此元素 node.conns.Remove(elem) } } //经过前面的操作，前面目的在于清理超时TCP连接 if node.conns.Len() \u0026lt;= 0 { //没有TCP连接可用，所以需要新建连接，立刻需要释放锁 node.mutex.Unlock() c, err := net.DialTimeout(\u0026#34;tcp\u0026#34;, node.address, node.connTimeout) if err != nil { return nil, err } //var writerMemory bytes.Buffer //创建新的redis连接内存对象 conn := \u0026amp;redisConn{ c: c, br: bufio.NewReader(c), bw: bufio.NewWriter(c), readTimeout: node.readTimeout, writeTimeout: node.writeTimeout, //writerMemory: \u0026amp;writerMemory, } //设置内存缓冲区 //conn.bwm = RedSHandle.NewWriterHandle(conn.writerMemory) //conn.readerParser = RedisFastParser.NewParserHandle(conn.c) return conn, nil } //获取到一条已经存在的存活TCP连接，这条TCP的生命周期也在合法时间内，所以： // 1.取出元素 // 2.删除元素在list中的位置 // 3.立刻解锁 elem := node.conns.Back() node.conns.Remove(elem) node.mutex.Unlock() //重置内存缓冲区 //elem.Value.(*redisConn).writerMemory.Reset() return elem.Value.(*redisConn), nil } 1.8.5 连接池源码分析 - 放回可用连接进入池 # func (node *redisNode) releaseConn(conn *redisConn) { //需要针对当前的redis-node的tcp连接池进行内存操作，在并发场景下，首先先上锁。 node.mutex.Lock() defer node.mutex.Unlock() //连接仍然有待处理的回复，只需将其关闭即可，避免可能的TCP粘包连接。 if conn.pending \u0026gt; 0 || node.closed { conn.shutdown() return } //如果连接池的当前长度已经超过池的最高界限，或者node没有开启tcp存活时间选项。 if node.conns.Len() \u0026gt;= node.keepAlive || node.aliveTime \u0026lt;= 0 { conn.shutdown() return } //更新当前conn的时间，并放入LIST数据结构 conn.t = time.Now() node.conns.PushFront(conn) //重置内存缓冲区 //conn.writerMemory.Reset() } "},{"id":35,"href":"/icorer_docs/doccenter/redistun/","title":"RedisTun","section":"项目总览","content":"RedisTunel 是为了解决PHP-FPM和Redis服务器之间的短连接问题,是为了更好地解耦业务代码与后端redis服务器集群之间的关系而设计的网络通信中间件，目的在于提高PHP请求远程Redis服务器的性能及稳定性,并在业务代码无感知的情况下提供数据分槽,指令组合,数据压缩等通信插件包,丰富redis的操作.\n一. 总体设计 # Redis-Tunel在组件设计上分为以下几部分:\nAgent配置解析器和更新器 通信组件: 包括UNIX本地监听组 和 远端Redis服务器连接池 协议分析器: 主要包括协议编码器,解码器 协议拦截器: 主要对某些redis命令进行拦截,调用协议插件组进行功能扩展. 协议插件组: 为协议分析器添加一系列插件,对通信进行优化和功能扩展. 容灾器: 为Agent运行提供必要的安全保障,主要包括进程资源监控,迭代更新监控. 具体的组件总体架构如下图: 二. 网络代理设计 # Redis-Tunel很重要的是网络代理部分,在网络代理方面由三部分组成.\n第一部分是对远程redis-server的连接池. 第二部分是对本地众多php-fpm客户端的UNIX请求连接管理. 第三部分是对这三端之间redis通信协议进行兼容. Go基础版本组件设计目前已经完成功能如下：\n配置解析器。 Unix domain server 组。 Tcp pool （目前包含自动扩容，连接隔离）。 Unix domain server 与 Tcp pool 的网络解耦。 借助redcon库进行redis协议解析和php-fpm客户端连接控制。 兼容set,get,mset,mget命令。 "},{"id":36,"href":"/icorer_docs/doccenter/redishub/designs/1.10/","title":"1.10 RESP协议解析","section":"系统设计","content":" 1.10 RESP协议解析 # 1.10.1 RESP协议介绍 # Redis 协议在以下三个目标之间进行折中：\n易于实现 可以高效地被计算机分析（parse） 可以很容易地被人类读懂 1.10.2 请求 # Redis 服务器接受命令以及命令的参数。\n服务器会在接到命令之后，对命令进行处理，并将命令的回复传送回客户端。\n1.10.3 回复 # Redis 命令会返回多种不同类型的回复。\n通过检查服务器发回数据的第一个字节， 可以确定这个回复是什么类型：\n状态回复（status reply）的第一个字节是 \u0026ldquo;+\u0026rdquo;\n错误回复（error reply）的第一个字节是 \u0026ldquo;-\u0026rdquo;\n整数回复（integer reply）的第一个字节是 \u0026ldquo;:\u0026rdquo;\n批量回复（bulk reply）的第一个字节是 \u0026ldquo;$\u0026rdquo;\n多条批量回复（multi bulk reply）的第一个字节是 \u0026ldquo;*\u0026rdquo;\n1.10.4 状态回复 # 一个状态回复（或者单行回复，single line reply）是一段以 \u0026ldquo;+\u0026rdquo; 开始、 \u0026ldquo;\\r\\n\u0026rdquo; 结尾的单行字符串。\n以下是一个状态回复的例子：\n+OK\n客户端库应该返回 \u0026ldquo;+\u0026rdquo; 号之后的所有内容。 比如在在上面的这个例子中， 客户端就应该返回字符串 \u0026ldquo;OK\u0026rdquo; 。\n状态回复通常由那些不需要返回数据的命令返回，这种回复不是二进制安全的，它也不能包含新行。\n状态回复的额外开销非常少，只需要三个字节（开头的 \u0026ldquo;+\u0026rdquo; 和结尾的 CRLF）。\n1.10.5 错误回复 # 错误回复和状态回复非常相似， 它们之间的唯一区别是， 错误回复的第一个字节是 \u0026ldquo;-\u0026rdquo; ， 而状态回复的第一个字节是 \u0026quot;+\u0026quot; 。\n错误回复只在某些地方出现问题时发送： 比如说， 当用户对不正确的数据类型执行命令， 或者执行一个不存在的命令， 等等。\n一个客户端库应该在收到错误回复时产生一个异常。\n以下是两个错误回复的例子：\n-ERR unknown command \u0026lsquo;foobar\u0026rsquo; -WRONGTYPE Operation against a key holding the wrong kind of value\n在 \u0026quot;-\u0026quot; 之后，直到遇到第一个空格或新行为止，这中间的内容表示所返回错误的类型。\nERR 是一个通用错误，而 WRONGTYPE 则是一个更特定的错误。 一个客户端实现可以为不同类型的错误产生不同类型的异常， 或者提供一种通用的方式， 让调用者可以通过提供字符串形式的错误名来捕捉（trap）不同的错误。\n不过这些特性用得并不多， 所以并不是特别重要， 一个受限的（limited）客户端可以通过简单地返回一个逻辑假（false）来表示一个通用的错误条件。\n1.10.6 整数回复 # 整数回复就是一个以 \u0026quot;:\u0026quot; 开头， CRLF 结尾的字符串表示的整数。\n比如说， \u0026quot;:0\\r\\n\u0026quot; 和 \u0026quot;:1000\\r\\n\u0026quot; 都是整数回复。\n1.10.7 RESP协议解析- 源码分析 # 这里首先感谢Codis 和 Redigo 这两大开源项目， 这里只进行概括性源码解析。\nfunc (d *Decoder) decodeResp() (*Resp, error) { b, err := d.br.ReadByte() //从缓冲区读取1byte，这个是RESP首特征byte if err != nil { return nil, errors.Trace(err) } r := \u0026amp;Resp{} r.Type = RespType(b) switch r.Type { default: //如果不在可控范围，则代表请求不是RESP协议 return nil, errors.Errorf(\u0026#34;bad resp type %s\u0026#34;, r.Type) case TypeString, TypeError, TypeInt: //如果是字符串、错误、整形响应 r.Value, err = d.decodeTextBytes() case TypeBulkBytes: //如果是Bulk类型 r.Value, err = d.decodeBulkBytes() case TypeArray: //如果数据是数组类型 r.Array, err = d.decodeArray() } return r, err } //解析非二进制安全的字符串、错误、整形响应，必须按照\\r\\n分割。 func (d *Decoder) decodeTextBytes() ([]byte, error) { b, err := d.br.ReadBytes(\u0026#39;\\n\u0026#39;) if err != nil { return nil, errors.Trace(err) } if n := len(b) - 2; n \u0026lt; 0 || b[n] != \u0026#39;\\r\u0026#39; { return nil, errors.Trace(ErrBadCRLFEnd) } else { return b[:n], nil } } //解析数组类型响应。 func (d *Decoder) decodeArray() ([]*Resp, error) { //解析数组长度 n, err := d.decodeInt() if err != nil { return nil, err } switch { case n \u0026lt; -1: return nil, errors.Trace(ErrBadArrayLen) case n \u0026gt; MaxArrayLen: return nil, errors.Trace(ErrBadArrayLenTooLong) case n == -1: return nil, nil } //根据数组长度创建RESP数组 array := make([]*Resp, n) for i := range array { //针对每个数组元素进行解析，此处类似递归调用，但是，借助go的栈逃逸、堆区内存分配，可以避免循环栈消耗。 r, err := d.decodeResp() if err != nil { return nil, err } array[i] = r } return array, nil } "},{"id":37,"href":"/icorer_docs/doccenter/redishub/designs/","title":"系统设计","section":"RedisHub","content":" 一. 总体设计 # RedisHub在组件设计上分为以下几部分:\nAgent配置解析器：负责对于配置文件进行解析（后续增加统一配置中心的支持） 通信组件: 包括UNIX本地监听组 和 远端Redis集群TCP长连接及连接池。 协议分析器: 提供稳定的Redis协议解析及组装功能组件。 协议拦截器: 主要对某些Redis命令进行拦截,调用协议插件组进行功能扩展. 协议插件组: 为协议分析器添加一系列插件,对通信进行优化和功能扩展，例如集群的mset、mget、del操作。 容灾器: 为Agent运行提供必要的安全保障,主要包括进程资源监控,迭代更新监控. 具体的组件总体架构如下图: "},{"id":38,"href":"/icorer_docs/doccenter/redistun/designs/","title":"系统设计","section":"RedisTun","content":" 一. 总体设计 # RedisHub在组件设计上分为以下几部分:\nAgent配置解析器：负责对于配置文件进行解析（后续增加统一配置中心的支持） 通信组件: 包括UNIX本地监听组 和 远端Redis集群TCP长连接及连接池。 协议分析器: 提供稳定的Redis协议解析及组装功能组件。 协议拦截器: 主要对某些Redis命令进行拦截,调用协议插件组进行功能扩展. 协议插件组: 为协议分析器添加一系列插件,对通信进行优化和功能扩展，例如集群的mset、mget、del操作。 容灾器: 为Agent运行提供必要的安全保障,主要包括进程资源监控,迭代更新监控. 具体的组件总体架构如下图: "},{"id":39,"href":"/icorer_docs/doccenter/","title":"项目总览","section":"工匠之芯-文档中心","content":" 项目总览 # RedisHub PulseFlow "},{"id":40,"href":"/icorer_docs/doccenter/redishub/system_access/","title":"系统接入","section":"RedisHub","content":" Tutorials # "},{"id":41,"href":"/icorer_docs/doccenter/redistun/system_access/","title":"系统接入","section":"RedisTun","content":" Tutorials # "}]