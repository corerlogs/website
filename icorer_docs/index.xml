<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>工匠之芯-文档中心</title><link>https://icorer.com/icorer_docs/</link><description>Recent content on 工匠之芯-文档中心</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://icorer.com/icorer_docs/index.xml" rel="self" type="application/rss+xml"/><item><title>2.1 NetHandle组件测试</title><link>https://icorer.com/icorer_docs/doccenter/redishub/module_test/2.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/module_test/2.1/</guid><description> NetHandle # This is a library for building high-performance TCP server applications, standing on the shoulders of Go giants and redcon
1. Features # High performance, low resource consumption Very easy to use development interface 2. Install # go get -u uriModule/NetHandle
3. Performance Testing: # 3.1 50*10000 (50 threads X 10000 requests) # 3.2 50*20000 (50 threads X 20000 requests) # 3.3 100*10000 (100 threads X 10000 requests) #</description></item><item><title>3.1 部署文档</title><link>https://icorer.com/icorer_docs/doccenter/redishub/deploy/3.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/deploy/3.1/</guid><description>一. 系统设计 # 1.1 背景描述 # 由于商城-商品中心系统目前使用的Redis单实例模式下，出现了机器存储过高、单机无法应对黑五大流量吞吐，因此进行单实例向集群化的改造，但是由于存在以下两种原因，造成需要自研中间件：
Redis标准集群不支持跨数据槽的MGET、MSET指令。 PHP生态缺乏并发支持，造成在M指令上性能很差。 最终我们设计RedisHub集群中间件，一方面用它来支持跨数据槽的MSET、MGET指令，一方面借助它的并发优势为PHP底层的M指令指令提高性能。
1.2 总体设计 # 中间件的总体结构设计图如下所示:
1.3 设计阐述 # 如图所示，PHP通过Unix Domain Socket途径和中间件进行IPC通信，然后中间件把PHP的redis请求进行处理，并转发到下游的Redis集群中，为PHP业务系统提供无缝的单实例到集群的改造，相关的网络模型如下：
二. 组件部署文档 # RedisHub中间件 部署主要分为两个部分, 安装相关安装包 和 修改配置并运行.
2.1 部署准备 # Linux 64bit 操作系统 RedisHub 二进制文件 调整Redishub配置文件：rh_config.yaml RedisHub进程监控工具 ,例如Supervisor 2.2 应用体安装 # 2.2.1 程序体获取 # 最新版本的中间件程序可以联系公共平台架构部门-开发二组获取，我们编译了Linux-64bit可执行程序，给予X运行权限，即可运行。
2.2.2 程序体运行 # 由于中间件是个可以方便运行的二进制体，但是我们在运行的时候需要制定配置文件路径，例如以下命令：
./RedisHub -c /home/corerman/DATA/ICODE/GoLang/RedisHub/config/rh_config.yaml
具体运行参数，运维伙伴可以自行调整。
三. 配置文件详解 # 配置文件（rh_config.yaml）是这个系统运行的基础，所以这里将讲解配置文件的相关信息.
#RedisHub YAML config file #RedisHub Net Config net: listen_uri: unix:/tmp/redis.sock #Unix Domain Socket的监听路径：PHP推荐使用这种模式 #listen_uri: tcp:10.</description></item><item><title>4.1 phpredis对接redishub</title><link>https://icorer.com/icorer_docs/doccenter/redishub/system_access/4.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/system_access/4.1/</guid><description>phpredis 对接 RedisHub 改造方案 # 一、背景描述 # phpredis进行Redis集群化改造，对接 RedisHub 中间件，并调整phpredis底层，增加业务降级逻辑。
二、改造方案 # 2.1、Agent 连接 # 由于 RedisHub 采用 UNIX domain连接，本地部署 Agent 的方式，不存在 port端口，故 redis连接时，无法再传递该参数，需要去掉，具体连接代码如下
public function __construct($config, $prefix = &amp;#39;prefix:&amp;#39;) { $this-&amp;gt;prefixH = $prefix; $this-&amp;gt;redisconf = $config; $this-&amp;gt;redis = new \Redis(); try { $this-&amp;gt;redis-&amp;gt;connect($this-&amp;gt;redisconf[&amp;#39;host&amp;#39;]); } catch (\Exception $exception) { Logger::getInstance()-&amp;gt;error(&amp;#39;Redis agent connect error, &amp;#39; . $exception-&amp;gt;getMessage() . &amp;#39;, &amp;#39; . $this-&amp;gt;redisconf[&amp;#39;host&amp;#39;]); try { //redis集群中间件服务不可用，降级 $this-&amp;gt;redis = new \RedisCluster(null, $this-&amp;gt;redisconf[&amp;#39;cluster&amp;#39;][&amp;#39;node&amp;#39;], $this-&amp;gt;redisconf[&amp;#39;cluster&amp;#39;][&amp;#39;timeout&amp;#39;], $this-&amp;gt;redisconf[&amp;#39;cluster&amp;#39;][&amp;#39;readTimeout&amp;#39;], $this-&amp;gt;redisconf[&amp;#39;cluster&amp;#39;][&amp;#39;persistent&amp;#39;]); } catch (\Exception $exception) { Logger::getInstance()-&amp;gt;error(&amp;#39;RedisCluster connect error, &amp;#39; .</description></item><item><title>icefiredb-crdt-kv</title><link>https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-crdt-kv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-crdt-kv/</guid><description>icefiredb-crdt-kv # Project introduction # The IceFireDB-CRDT-KV engine can support decentralized P2P networking, data synchronization and consistency between nodes. It is a component of the IceFireDB software ecosystem, thanks to the open source of IPFS.
Features # Easy access to P2P data consistency function Stable decentralized networking function Friendly program access interface Installing # go get -u github.com/IceFireDB/icefiredb-crdt-kv Example # package main import ( &amp;#34;bufio&amp;#34; &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; icefiredb_crdt_kv &amp;#34;github.com/IceFireDB/icefiredb-crdt-kv/kv&amp;#34; badger2 &amp;#34;github.</description></item><item><title>OrbitDB</title><link>https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/orbitdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/orbitdb/</guid><description>Compared with OrbitDB # OrbitDB is a serverless, distributed, peer-to-peer database.
OrbitDB uses IPFS as its data storage and IPFS Pubsub and uses CRDTs to automatically sync databases with peers, achieving strong eventual consistency - when all updates are eventually received, all nodes will have the same state.
IceFireDB is a database built for web3 and web2,The core mission of the project is to help applications quickly achieve decentralization,built for Data dao.</description></item><item><title>OverView</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/overview/</guid><description> OverView #</description></item><item><title>OverView</title><link>https://icorer.com/icorer_docs/doccenter/logdarts/architecture/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/logdarts/architecture/overview/</guid><description> OverView #</description></item><item><title>OverView</title><link>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/overview/</guid><description> OverView #</description></item><item><title>OverView</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/overview/</guid><description> OverView #</description></item><item><title>OverView</title><link>https://icorer.com/icorer_docs/doccenter/redistun/designs/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/designs/overview/</guid><description> OverView #</description></item><item><title>1.1基础运行框架</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.1/</guid><description> 一. 基础运行框架 # 1.1 设计概述 # 基础运行框架也可以成为程序组织结构,一个项目必须要有足够清晰的工程文件结构. 在清晰的工程结构下,系统的各个模块才会有适合自己的存储位置,从存储位置可以上升为代码的调用路径,好的基础运行框架,既可以让系统的源码结构清楚很多,也可以降低模块间的耦合度,提高系统的稳定性.
1.2 工程框架组成部分 # 在此项目工程结构中,最外层的文件结构主要包括以下几部分, 项目工程一级文件结构如下图所示:
cmd目录 : 此目录是工程运行体的源码目录,也就是最终会编译出来的可执行体的源码目录,这个目录包括 proxy,daemon目录. config目录 : 配置文件存储目录. deploy目录 : 工程部署目录,里面会包含一些部署脚本和部署工具. doc目录 : 文档目录 ,里面包括一系列的子文件夹,用来保存每个子功能的描述文档. example目录 : 样例目录,对于一些对外提供的功能模块做一些功能示例. script目录 : 脚本目录,里面的脚本相对与deploy目录里的脚本更偏向于一些模块测试脚本. src目录 : 模块源代码目录, 这个目录是工程框架中最重要的一部分,主要包括工程的模块元素,其中包括models 、pkg、 proxy 、redishub、 redis、util目录,后面会做更加详细的阐述. vender目录 : 外部库目录,因为外部的包不断更新,这里的vender更偏向于把适合工程的外部依赖库进行镜像保存,主要是为了提高工程的稳定性. 二. 重要部分拆分设计 # 2.1 cmd目录 # 这个是运行体目录,主要存储main包结构的文件源码,目前里面包含两部分:
RedisHub目录 : RedisHub主程序体 2.2 SRC目录结构 # SRC目录的结构如下图:
这个目录会包含一些子目录文件夹,主要存储功能包级别的源码文件及源码目录,主要包括:
models目录 : 数据结构目录,存储系统用到的数据结构相关定义 proxy目录 : 代理模块,这个模块专门储存redis代理相关的功能,既包括本地监听级别的backend,也包括协议解析部分的redis目录,还包括plugin插件目录. redhub目录: 这个目录是核心目录,主要的工作任务在于承上启下,因为在src目录下基础单元都是一个个独立的包,但是如何被cmd层的代码顺利调用,还需要redtun在src功能包基础上抽象cmd层调用的操作单元. utils目录 : 框架的套件目录,主要用来存储框架所使用的一系列套件包,例如errors , log , math , redis-client , trace , unsafe , rpc , sync , resolver , usage 等 pkg目录：包含codis redis协议解析器 redis目录：包含redis集群核心功能代码。</description></item><item><title>2.2 中间件完整测试</title><link>https://icorer.com/icorer_docs/doccenter/redishub/module_test/2.2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/module_test/2.2/</guid><description>零、亿级数据压测 # // 测试脚本 &amp;lt;?php $redis = new Redis(); try { //connect 是 异常级别 $redis-&amp;gt;connect(&amp;#39;/tmp/redis.socks&amp;#39;); $ret = $redis-&amp;gt;set(&amp;#34;hello&amp;#34;, &amp;#34;helloworld&amp;#34;,2); var_dump($ret); $ret = $redis-&amp;gt;get(&amp;#34;hello&amp;#34;); var_dump($ret); $ret = $redis-&amp;gt;del(&amp;#34;hello&amp;#34;); var_dump($ret); $ret = $redis-&amp;gt;mset([&amp;#34;test1&amp;#34; =&amp;gt; &amp;#39;value1&amp;#39;, &amp;#34;test2&amp;#34; =&amp;gt; &amp;#39;value2&amp;#39;]); var_dump($ret); $ret = $redis-&amp;gt;del(&amp;#34;test1&amp;#34;, &amp;#34;test2&amp;#34;, &amp;#34;test3&amp;#34;); var_dump($ret); $ret = $redis-&amp;gt;mget([&amp;#34;test1&amp;#34;, &amp;#34;test2&amp;#34;, &amp;#34;test3&amp;#34;, &amp;#34;test4&amp;#34;, &amp;#34;test5&amp;#34;, &amp;#34;test6&amp;#34;, &amp;#34;test7&amp;#34;, &amp;#34;test8&amp;#34;, &amp;#34;test9&amp;#34;, &amp;#34;test10&amp;#34;, &amp;#34;test11&amp;#34;, &amp;#34;test12&amp;#34;, &amp;#34;test13&amp;#34;, &amp;#34;test14&amp;#34;, &amp;#34;test15&amp;#34;, &amp;#34;test16&amp;#34;, &amp;#34;test17&amp;#34;, &amp;#34;test18&amp;#34;, &amp;#34;test19&amp;#34;, &amp;#34;test20&amp;#34;]); var_dump($ret); $ret = $redis-&amp;gt;rPush(&amp;#34;push&amp;#34;,&amp;#34;key1&amp;#34;,2019,&amp;#34;key2&amp;#34;); var_dump($ret); $val1 = $redis-&amp;gt;lPop(&amp;#34;push&amp;#34;); var_dump($val1); $val1 = $redis-&amp;gt;lPop(&amp;#34;push&amp;#34;); var_dump($val1); $val1 = $redis-&amp;gt;lPop(&amp;#34;push&amp;#34;); var_dump($val1); } catch (\Exception $ex) { var_dump($ex-&amp;gt;getMessage()); } # 终端输出 ______ _ _ _ _ _ (_____ \ | (_) (_) (_) | | _____) )_____ __| |_ ___ _______ _ _| |__ | __ /| ___ |/ _ | |/___) ___ | | | | _ \ | | \ \| ____( (_| | |___ | | | | |_| | |_) ) |_| |_|_____)\____|_(___/|_| |_|____/|____/ 2019/09/15 09:40:27 main.</description></item><item><title>icefiredb-ipfs-log</title><link>https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-ipfs-log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-ipfs-log/</guid><description>icefiredb-ipfs-log # Project introduction # icefiredb-ipfs-log is a distributed immutable, operation-based conflict-free replication data structure that relies on ipfs to store data and merges each peer node data based on pubsub conflict-free. You can easily implement custom data structures such as kv, event, nosql, etc. based on icefiredb-ipfs-log.
Conflict-free log replication model
Log A Log B | | logA.append(&amp;#34;one&amp;#34;) logB.append(&amp;#34;hello&amp;#34;) | | v v +-----+ +-------+ |&amp;#34;one&amp;#34;| |&amp;#34;hello&amp;#34;| +-----+ +-------+ | | logA.</description></item><item><title>NetWork</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/network/</guid><description> NetWork Details #</description></item><item><title>NetWork</title><link>https://icorer.com/icorer_docs/doccenter/logdarts/architecture/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/logdarts/architecture/network/</guid><description> NetWork Details #</description></item><item><title>NetWork</title><link>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/network/</guid><description> NetWork Details #</description></item><item><title>Network layer</title><link>https://icorer.com/icorer_docs/doccenter/redistun/designs/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/designs/network/</guid><description>Network layer design # The network layer undertakes the work of inter-node networking, inter-node data distribution, and inter-node data consistency consensus. The network layer of IceFireDB is divided into two layers according to the distance of the physical network link:
Data consistency network layer for short-distance networks. Decentralized database network layer for wide-distance network. The above two different network layers are supported by different technologies and have different requirements for data consistency sensitivity and timeliness.</description></item><item><title>ThreadDB</title><link>https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/threaddb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/threaddb/</guid><description>Compared with ThreadDB # ThreadDB is a serverless, distributed, peer-to-peer database.
IceFireDB is a database built for web3 and web2,The core mission of the project is to help applications quickly achieve decentralization,built for Data dao.
Database ThreadDB IceFireDB system target P2P Databases A decentralized database platform built for Data dao. storage engine support IPFS goleveldb、badger、IPFS、CRDT、IPFS-LOG、OSS network support type P2P P2P、RAFT、NATS Data type support SQL KV、Strings、Hashes、Lists、Sorted Sets、Sets、SQL、PubSub Software integration method Binary software integration Software library integration, binary software integration、web3 platform integration web3 support No smart contract plan Smart contracts are being supported、Build data dao database platform computer language used to implement Go Go Ecological client language Go Any client that supports the redis、mysql protocol Thanks ThreadDB # Thanks to ThreadDB for letting us see the excellent implementation of decentralized SQL database.</description></item><item><title>1.2配置解析器</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.2/</guid><description>1.2 配置解析器设计 # Agent配置器, 主要负责解析来自网络 或者 文件系统中的配置文件,目前提供配置文件解析模块,配置解析器设计主要包括以下部分:
配置信息元素结构. 配置解析器相关解析函数. 配置解析器对外API接口服务,允许动态更新配置. 组成结构图如下: 1.2.1 配置信息元素 # 随着系统功能的不断丰富,系统的配置项目也会越来越多,目前配置解析器主要解析的数据对象包括:
网络配置项 : 针对中间件网络监听进行配置。 redis集群配置项：针对Redis集群进行配置。 日志配置项：目前提供kafka或日志输出，kafka支持公司标准日志。 1.2.2 配置样例 # #RedisHub YAML config file #RedisHub Net Config net: listen_uri: unix:/var/run/redis.sock #Unix Domain Socket的监听路径：PHP推荐使⽤这种模式 # listen_uri: tcp:10.100.183.180:16379 #TCP的监控IP及端⼝ #RedisHub cluster Config cluster: start_nodes:node1,node2,node3 #Redis集群的节点，这⾥可以根据线上实际情况进⾏配置，多个只是为了保障⾼可⽤ conn_timeout: 200 #Redis节点的TCP连接超时时间 （单位：毫秒） conn_read_timeout: 50 #Redis节点的TCP读取超时时间 （单位：毫秒） conn_write_timeout: 50 #Redis节点的TCP写⼊超时时间 （单位：毫秒） conn_alive_timeout: 60 #Redis节点的TCP最⼤空闲时间 （单位：秒） conn_pool_size: 200 #针对每⼀个Redis集群节点的TCP连接池最⼤值 （单位：个） #RedisHub api config api: http_listen_address: #RedisHub log config # log 相关配置 log: # 日否开启日志 enable: true # 日志输出位置，支持std(终端) kafka # 注：std仅在调试时使用 output: &amp;#34;kafka&amp;#34; # kafka server的地址 需要修改到指定环境的kafka kafka_address: [&amp;#34;10.</description></item><item><title>icefiredb-proxy</title><link>https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb_proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb_proxy/</guid><description>IceFireDB-Proxy # Project introduction # IceFireDB-Proxy is a high-performance, high-availability, and user-friendly Resp protocol cluster proxy solution. It is supporting P2P networking and is a network component in the IceFireDB ecosystem.
Features # Complete data source mode support: stand-alone, cluster mode Rich command support Excellent cluster state management and failover Excellent traffic control policies: Traffic read/write separation and multi-tenant data isolation Excellent command telemetry features Bottom-fishing use of mind and base abilities that are closer to cloud native Supports P2P automatic networking, and Proxy helps traditional Redis databases achieve data decentralization.</description></item><item><title>Storage</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/storage/</guid><description> Storage Engine Details #</description></item><item><title>Storage</title><link>https://icorer.com/icorer_docs/doccenter/logdarts/architecture/storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/logdarts/architecture/storage/</guid><description> Storage Engine Details #</description></item><item><title>Storage</title><link>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/storage/</guid><description> Storage Engine Details #</description></item><item><title>Storage layer</title><link>https://icorer.com/icorer_docs/doccenter/redistun/designs/storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/designs/storage/</guid><description>Storage layer design # The storage layer is responsible for data storage, and the data storage here includes different storage media of web2 and web3. For web2, the storage media we face includes disk, OSS, and for web3, the storage media we face includes IPFS, blockchain, and smart contracts.Currently, the storage types supported by IceFireDB mainly include the following.
Engine type describe Driver directory LevelDB LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.</description></item><item><title>1.3通信组件</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.3/</guid><description> 1.3 通信组件设计 # 通信组件目前不包括协议解析部分,这里的通信组件就是纯粹的网络通信层设计.
1.3.1 通信组件组成部分 # 目前网络通信层分为两部分:
本地UNIX监听组,用于高速的IPC通信 每个UNIX监听组所对应一组远端redis服务器,分别对于主从进行连接池连接. 1.3.1 通信组件链路结构 # RedisHub很重要的是网络代理部分,在网络代理方面由三部分组成.
第一部分是对远程redis集群的连接池. 第二部分是对本地众多php-fpm客户端的UNIX请求连接管理. 第三部分是对这三端之间redis通信协议进行兼容.</description></item><item><title>Protocol</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/protocol/</guid><description> Protocol Details #</description></item><item><title>Protocol</title><link>https://icorer.com/icorer_docs/doccenter/logdarts/architecture/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/logdarts/architecture/protocol/</guid><description> Protocol Details #</description></item><item><title>Protocol</title><link>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/protocol/</guid><description> Protocol Details #</description></item><item><title>Protocol layer</title><link>https://icorer.com/icorer_docs/doccenter/redistun/designs/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/designs/protocol/</guid><description>Protocol layer design # A good access method of the application can accelerate the growth of the application ecology, and a good protocol design can reduce the transformation cost of the stock application, so the protocol layer is an important component of the IceFireDB software stack. The communication protocol of IceFireDB-NoSQL fully integrates the Redis RESP protocol, which mainly includes the following two parts of the protocol:
Data control protocol: Complete support for RESP clients, supporting functional requirements for database data access.</description></item><item><title>redhub-frame</title><link>https://icorer.com/icorer_docs/doccenter/redistun/develop/redhub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/develop/redhub/</guid><description>redhub-frame # Project introduction # High-performance Redis-Server multi-threaded framework, based on RawEpoll model.
Features # Ultra high performance Fully multi-threaded support Low CPU resource consumption Compatible with redis protocol Create a Redis compatible server with RawEpoll model in Go Installing # go get -u github.com/IceFireDB/redhub Example # Here is a simple framework usage example,support the following redis commands:
SET key value GET key DEL key PING QUIT You can run this example in terminal:</description></item><item><title>1.4 协议解析器与拦截器</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.4/</guid><description>1.4 协议解析器与拦截器 # 作为网络中间件,我们需要针对网络数据包进行读取之外,还需要对数据包进行解析工作,基于redis协议做了解析之后,我们还需要在解析器的基础上做拦截器,针对不同的redis做不同的处理流程.
1.4.1 协议解析器设计 # 协议解析器,是一个单独的模块,它主要针对网络数据包进行redis协议的解析工作,虽然redis协议具有统一的数据格式,但是还需要对每种协议命令做兼容操作.
1.4.2 协议解析器构成成分 # redis协议解析器 : 主要用来解析redis协议 (decoder) redis协议编码器 : 主要用来组装redis协议 (encoder) 1.4.3 解析器 和 拦截器 的工作流程 配合 # 这两个重要组件的功能流程配合如下:
[PHP-FPM请求] &amp;ndash;&amp;gt;** [RedisHub中间件]** &amp;ndash;&amp;gt; (读取数据包) &amp;ndash;&amp;gt; (解析数据包协议) &amp;ndash;&amp;gt; (对指定命令进行拦截操作) &amp;mdash;&amp;gt; (转发下游redis服务) &amp;ndash;&amp;gt; [下游redis集群] &amp;ndash;&amp;gt; (处理命令并响应) &amp;ndash;&amp;gt; [RedisHub中间件] &amp;mdash;&amp;gt; (响应请求) &amp;mdash;&amp;gt;** [PHP-FPM]**</description></item><item><title>Codec</title><link>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/codec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/codec/</guid><description> Codec Engine Details #</description></item><item><title>Codec layer</title><link>https://icorer.com/icorer_docs/doccenter/redistun/designs/codec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redistun/designs/codec/</guid><description>Codec layer design # The codec layer is the glue of the IceFireDB data expression layer, because the bottom layer of IceFireDB supports many storage engines, including centralized storage such as web2 disk, OSS, leveldb, and badger, as well as web3&amp;rsquo;s IPFS, crdt-kv, and IPFS-LOG For this kind of decentralized storage, the storage interface provided by any kind of storage is simple and not standardized. The codec layer of IceFireDB-NoSQL is abstracted through a unified driver layer, and by encoding and decoding many instruction semantics into a KV model, a richer data expression layer is built to support more data scenarios, such as Strings\Hashs\Sets\Lists \Sorted Sets.</description></item><item><title>1.5 NetHandle组件</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.5/</guid><description>NetHandle # 这是一个库,方便构建高性能TCP服务端应用程序,站在Go语言的巨人肩膀上
项目地址: uriModule/NetHandle
一. 特点 # 高性能,低资源消耗 非常简单易用的开发接口 支持众多协议,TCP,UDP,UNIX 二. 安装 # go get -u moduleUri/NetHandle
三. 性能测试: # 3.1 50*10000 (50线程 X 10000请求) # 3.2 50*20000 (50线程 X 20000请求) # 3.3 100*10000 (100线程 X 10000请求) # 四. 样例代码: # 使用这个库的时候,只需要自定义简单的回调函数,即可构造出性能强悍的网络监听.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;moduleUri/NetHandle&amp;#34; &amp;#34;log&amp;#34; &amp;#34;sync&amp;#34; ) var addrTcp = &amp;#34;127.0.0.1:10000&amp;#34; func main() { log.SetFlags(log.Lshortfile | log.LstdFlags) var mu sync.RWMutex count := 0 go log.</description></item><item><title>1.5 集群 MSET 指令支持</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.6/</guid><description> 集群 MSET 指令支持 #</description></item><item><title>1.7 集群 MGET 指令支持</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.7/</guid><description>1.7 集群 MGET 指令支持 # 业务系统为了提高多个key的数据获取吞吐，经常会采用mget指令，这个指令在单实例模式的redis场景下能够完美支持，但是redis标准集群不支持跨槽位执行mget指令。
但是mget针对业务环境是大量使用的，所以中间件必须完成mget指令在集群中的命令支持。
1.7.1 指令转换 # 由于Redis不支持跨槽位执行mget指令，因此我们可以变相思维，总体的指令转换如下：
针对MGET指令的keys进行拆分。 对keys进行hash计算 =&amp;gt; 选择key所对应的node 。 针对node组上的指令进行并发 pipline命令发送。 聚合各个并发线程的指令结果，把远端redis集群内部的数据返回给业务调用方。 1.7.2 MGET指令设计图 # 针对MGET的具体工作情况，我这边绘制了一个图，说明MGET的具体工作原理，红色线路代表一次完整的MGET执行周期。 从上面的图形可以看出，中间件接受到MGET请求后，会把指令中的KYES进行hash计算、并结合node信息选择数据存储的node，针对每个node进行进行pipeline 指令流水吞吐、保障单node下的吞吐高性能，针对不同的node进行并发执行，通过并发技术提高MGET在集群环境下的整体响应速度。</description></item><item><title>1.9 Redis集群状态更新</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.8/</guid><description>1.9 Redis集群状态更新 # RedisHub中间件除了要沟通客户端 与 服务端 这两方，还需要及时获取Redis集群的状态信息，并把状态信息转换或更新必要的内存数据结构，内存数据结构最终会被中间件用来承载redis请求。
1.9.1 状态信息来源 # 集群状态信息的来源主要包括：
被动方式：集群内部指令执行周期内的MOVE、ASK信号 主动方式：集群 CLUSTER SLOTS 指令 1.9.2 集群槽位状态信息更新 # 关于集群槽位的信息更新，我们主要包括以下两方面策略：
为了具备更好的性能，我们采用chan 共享内存监听 采用读写锁，提高关键内存共享区的读写安全性及性能 针对更新操作做了秒级限流操作，保障中间件的稳定性。 核心源码分析 如下：
func (cluster *Cluster) handleUpdate() { for { //获取chan列表的更新信号 msg := &amp;lt;-cluster.updateList // TODO: control update frequency by updateTime and movedTime? cluster.rwLock.RLock() clusterLastUpdateTime := cluster.updateTime cluster.rwLock.RUnlock() //如果集群的上一次更新时间 加上窗口值（1s） 小于 此次集群更新指令产生的时间: 证明集群更新频率过高，控制频率。 if clusterLastUpdateTime.Add(1 * time.Second).Before(msg.movedTime) { //针对集群进行状态更新 err := cluster.Update(msg.node) if err != nil { log.</description></item><item><title>1.8 TCP连接池</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.9/</guid><description>1.8 TCP连接池 # 1.8.1 连接池是什么 # 我们常见的池很多，比如内存池，线程池，对象池，连接池等。顾名思义，池子干的事情都是一样的，把一类相同的事物放到一个池里面，已备不时之需，好比我们的蓄水池一样，把平日多余的水储蓄起来，一方面防止洪水到来时候对下游造成洪涝灾害，另一方面还可以合理灌溉资源利用，比如还可以水力发电。同样连接池是把已经已经建立好的连接放入一个池子，当请求到来可以直接拿来使用，这样就即解决了频繁的创建关闭连接带来的开销，也保护了后端服务，防止同时有大量连接涌入，造成危害。
1.8.2 连接池的种类 # 其实也就是连接池的使用场景
可以是一个独立部署的服务，通过套接字提供代理服务。例如我们的常用的dbproxy。
可以是一个服务内部进程间共享的连接池，这种相对更加轻量，可以理解为项目级别，只对内提供服务。
进程内的连接池，更加轻量，当前进程内的线程或者协程可以使用。
RedisHub 实现的连接池就是 进程内的连接池，使用连接池有以下好处：
减少客户端使用连接时，创建和销毁连接的时间和系统资源开销，这里涉及到TCP的三次握手也四次挥手，还有TCP的慢启动预热。 避免极端情况大量连接直接涌入后端服务，对整个系统服务造成危害。 但同时也有一些缺点，比如空闲状态下也要维护一定数量的连接，占用客户端和服务端的资源，这里可以根据实际需求动态调配连接数，达到效率和资源利用的平衡。哪有一点资源不占用，还想系统高效稳定的事情，建个水坝还得占片地，护坝人间断性的职守呢。
1.8.3 TCP连接池初始化方式 # TCP连接池的最终目标就是对程序体内部需要使用的TCP连接进行池化管理，连接不够使用时自动扩容、连接过剩的时候能够自动回收，所以 我们首先需要考虑TCP连接池的初始化方式。连接池的初始化方式主要包括如下两种：
当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，创建连接对象，请求结束的时候，归还至连接池.
进程启动的时候，创建固定数量的连接对象，当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，继续等待或者服务降级; 不为空的话正常服务，请求结束的时候，归还至连接池.
RedisHub 中间件的TCP连接池初始化方式选择第一种。针对第二种连接池的实现方案，可以查阅本人另外一个项目RedisTun。
1.8.4 连接池源码分析 - 获取一个可用链接 # func (node *redisNode) getConn() (*redisConn, error) { //需要针对当前的redis-node的tcp连接池进行内存操作，在并发场景下，首先先上锁。 node.mutex.Lock() //如果当前node已经进入不可用状态。 if node.closed { node.mutex.Unlock() return nil, fmt.Errorf(&amp;#34;getConn: connection has been closed&amp;#34;) } //从TCP连接池中清理陈旧的TCP连接，这里面使用了LIST数据结构，可以把陈旧连接进行归并、一并处理。 //如果连接远程node节点时候设置了TCP连接存活时间 则 进行检验。 if node.aliveTime &amp;gt; 0 { for { //从list中选择一个元素，如果conns列表为空 则跳出检查 elem := node.</description></item><item><title>1.10 RESP协议解析</title><link>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/redishub/designs/1.10/</guid><description>1.10 RESP协议解析 # 1.10.1 RESP协议介绍 # Redis 协议在以下三个目标之间进行折中：
易于实现 可以高效地被计算机分析（parse） 可以很容易地被人类读懂 1.10.2 请求 # Redis 服务器接受命令以及命令的参数。
服务器会在接到命令之后，对命令进行处理，并将命令的回复传送回客户端。
1.10.3 回复 # Redis 命令会返回多种不同类型的回复。
通过检查服务器发回数据的第一个字节， 可以确定这个回复是什么类型：
状态回复（status reply）的第一个字节是 &amp;ldquo;+&amp;rdquo;
错误回复（error reply）的第一个字节是 &amp;ldquo;-&amp;rdquo;
整数回复（integer reply）的第一个字节是 &amp;ldquo;:&amp;rdquo;
批量回复（bulk reply）的第一个字节是 &amp;ldquo;$&amp;rdquo;
多条批量回复（multi bulk reply）的第一个字节是 &amp;ldquo;*&amp;rdquo;
1.10.4 状态回复 # 一个状态回复（或者单行回复，single line reply）是一段以 &amp;ldquo;+&amp;rdquo; 开始、 &amp;ldquo;\r\n&amp;rdquo; 结尾的单行字符串。
以下是一个状态回复的例子：
+OK
客户端库应该返回 &amp;ldquo;+&amp;rdquo; 号之后的所有内容。 比如在在上面的这个例子中， 客户端就应该返回字符串 &amp;ldquo;OK&amp;rdquo; 。
状态回复通常由那些不需要返回数据的命令返回，这种回复不是二进制安全的，它也不能包含新行。
状态回复的额外开销非常少，只需要三个字节（开头的 &amp;ldquo;+&amp;rdquo; 和结尾的 CRLF）。
1.10.5 错误回复 # 错误回复和状态回复非常相似， 它们之间的唯一区别是， 错误回复的第一个字节是 &amp;ldquo;-&amp;rdquo; ， 而状态回复的第一个字节是 &amp;quot;+&amp;quot; 。</description></item></channel></rss>