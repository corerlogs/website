<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>系统设计 on 工匠之芯-文档中心</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/</link><description>Recent content in 系统设计 on 工匠之芯-文档中心</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://icorer.com/icorer_docs/doccenter/ak-2019/designs/index.xml" rel="self" type="application/rss+xml"/><item><title>OverView</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/overview/</guid><description> OverView #</description></item><item><title>框架层次设计</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.1/</guid><description> 一. 框架内部分层关系 # 基于目前的AK-2019框架代码: https://git.icorer.com/APLID/AK-2019
系统框架在设计上分为4层,相关层次结构从下向上如下图:
二. 框架各个层次的作用 # TP5.1 层: 引入进来的TP框架,采用其中的ORM和路由部分 AK-Frame层: 这一层是我们重力设计的一部分,这部分主要用来存储内核代码,和业务层完全分开,通过类或者包对外提供服务. APPS层: 这一层是业务代码层,里面每一个文件夹代表一组业务,由于这部分和AK-FRAME已经隔离,所以这里可以存储一组业务,也可以存储多组业务. APPS-FRAME: 这一层介于APPS层和AK-FRAME层,继承自AK-FRAME层,服务于APPS层,这一层主要是预防业务层代码需要定制化AK-FRAME内核.</description></item><item><title>1.2 AK-FRAME设计-Request Handle设计</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.2/</guid><description/></item><item><title>1.3 AK-FRAME设计-Request Handle设计阐述</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.3/</guid><description>Request Handle 顾名思义 ,它的主要职责用来承载用户API请求,基于这个包将会衍生出框架的控制器基础类，也可以让当前类成为控制器基础类，控制器基础类将被每个实体业务控制器继承,所以它处在AK-FRAME层面.
所以在AK-FRAME层面,我们有request目录用来存储request相关的类实现文件,配置文件,相关工具包文件.
一. 工作流程组成部分 # 1.1 Request-Handle 模块设计图 # Request-Handle 模块主要包括 请求合法性检测、请求数据体分析、权限校验等模块组成，相关具体的模块设计图如下所示：
二. 相关组件介绍 # 2.1 Request-Handle组件类 # 为了把Request模块统一打包对外服务，所以这里我们需要把Request-Handle组件抽象为一个RequestHandle类，这个类主要包含一些相关模块方法，可以被外部类引用，在请求校验阶段做出贡献。
2.2 请求合法性检测 # 对于网络请求来源复杂，我们首先不能让请求轻易进入消耗计算机资源的环节，所以这部分很关键，但是这部分具有很强的不确定性。因为随着计算机技术的发展，爬虫技术等模拟技术，黑客攻击的升级，这部分可能面临着修改的可能性，因此这部分除了进行基础的请求过滤外，还需要留下相关的扩展函数，便于后期进行调整。
请求合法性检测在实现层是RequestHandle类的一个函数，函数名为checkRequest，这个函数主要完成两部分工作。
路由放行：调用RequestHandle类子函数isRouteIgnore，这个部分主要检查当前请求的控制器和方法是不是在路由忽略列表，如果在列表内，则放过这个请求，这个应用场景主要针对一些权限初始化接口，比如用户登录、获取token 接口。
请求参数校验：调用RequestHandle类子函数checkHeader，这个部分主要对于header头部参数里的一些约定条件进行检测，目前主要包括的参数包括JWT令牌数据、请求来源from参数，这两个检测过程均为调用RequestHandle内部函数。
2.2.1 JWT组件包 # JWT 是通用令牌协议，基于JWT可以做用户安全校验、同时开源社区提供了相关的代码包，可以帮助系统框架快速构建JWT令牌模块。
但是，在安装了JWT包后，我们不能直接使用开源社区的裸包，我们需要在AK-FRAME封装JWT子模块，子模块主要提供生成JWT和解析JWT的代码包，JWT封装层注意封装的用户单元信息不要采用uid，要采用用户名，便于后期做分布式系统，基于用户名的JWT，可以在各个系统之间可以做到统一登录。
校验JWT模块，这个是JWT包中的一个方法，名称为checkJWT，这个函数在RequestHandle类子函数checkHeader中被调用，主要对header头部传输进来的JWT数据做数据段的检验，包括JWT长度，和相关数据段拆分，如果JWT验证成功，则要把拆分后的数据体组成数组返回上一级，便于上一级函数把数据加载进控制器基础类相关属性。
2.2.2 请求参数匹配函数（filterRequestParames方法） # 需要在 RequestHandle类中实现出请求参数匹配函数，这个是一个扩展单元，目前可以在函数内部仅仅做header部分的from参数判断，比如参数值可以为app，web，wechat，如果不在列表，则返回false，由上级接收到返回值后决定是否放行请求，在以后可能会对更多的请求参数进行过滤，这个函数将起到过滤效果。
2.3 请求数据体分析（getRequestData方法） # 如果上面的流程已经顺利通过，那么这个请求在安全程度上已经是合法的了，那么将进行非常重要的两部分操作。
这个方法将调用ak-frame中的request目录下的requestData工具类，
请求数据体抽取：对于request 请求体的相关参数进行抽取，这部分是requestData工具类的实现，这个工具类基于TP5.1的request部分做了一层封装，提供一些基础方法，比如findGetDataByKey,findPostDataByKey等，这层封装既可以满足已经定制化请求数据，还可以降级对于TP框架的耦合度。
检查路由权限：这部分流程则需要检查当前请求所处的路由是够属于前面部分解析的JWT所对应的用户拥有的权限，首先会取出控制器基础类中的用户名，然后去缓存中查询是否有对应的用户权限，如果没有则调用权限包中的权限分析方法对于JWT解析出的用户名进行权限获取，如果已经存在则把缓存权限取出来，这两条线路最终都需要对于当前路由和用户权限列表中进行搜索，如果找到则放行，否则就拒绝访问。</description></item><item><title>1.4 权限设计-最小操作与功能单元</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.4/</guid><description>在设计统一权限系统之前,我们需要思考第一个问题,在系统权限层次上,到底哪些部分是实体,哪些部分是虚体? 比如你去公司上班,公司具有门禁系统,你需要刷卡入门,假设你需要穿过5道门,想一下在这些动作中,是如何归并你的权限范围的.
在这些门禁中,都相当于一个操作,每个操作都有不同的标识符,你拥有的标识符越多,你就拥有越多的权限. 现在思考一下目前操作系统中比较流行的RBAC或者基于用户权限这种比较流行的权限系统,都是在不断的给用户赋予标识符,所以我们的新权限系统中首先需要思考第一个问题,我们系统中最小的操作实体是什么?
一. 最小操作单元 # 最小操作单元,顾名思义就是系统最小能够对外提供服务的功能元素,我们是API后台系统,所以针对新版系统,最小操作单元就是一个个API,这是系统的最小控制力度.
最小操作单元在数据表存储为一张单表,单表必须存在下面相关字段:
id : 序号 name : 最小操作单元名称(必须英文,以后应对分布式) name_comment : (name英文所对应的中文) module : API的module部分 controller : API的控制器名称 method : API的方法名称 comment : 描述 二. 最小功能单元 # 最小操作单元是孤零零的API,这是系统的最小实体,但是这个力度太小,所以不能成为养老服务库中的功能单元,所以我们还需要在最小操作单元的基础上聚合成一个个最小功能单元,最小功能单元组装成服务库.
系统功能单元，就是最小操作单元的聚合体，在数据存储结构上也是一张单表,单表必须存在下面相关字段:
id : 序号 name : 功能名称 (必须英文,以后应对分布式) name_comment: (name英文所对应的中文) ids : 最小操作单元的id集合(逗号分割) ids_name : ids所对应的最小操作单元英文名称列表(逗号分割,以后应对分布式) comment : 功能单元描述. 三. 两者间关系 # 下图描述最小功能单元与最小操作单元间关系.
下面以老人管理功能为例。</description></item><item><title>1.5 权限设计-系统结构设计</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.5/</guid><description> 系统结构设计 # 一. 系统总体结构图 # 二. 系统 # 目标：构建一个千变万化的系统结构。 首先系统和目录是虚拟的，可以随意构造。通过选取功能库中的功能，来建立不同的系统。
系统在数据表存储为一张单表,单表必须存在下面相关字段:
id : 序号 name : 系统名称 comment : 描述 三. 目录(功能) # 功能菜单不在是之前的三级权限，功能可以停止在任意目录级别, 根据type进行类别判断。当type为func时，此目录为功能层。
目录（功能），在数据存储结构上也是一张单表,单表必须存在下面相关字段:
id : 序号 system_id : 系统id name: 目录名称 par_id : 上级目录id type : 目录类别 （dir-目录、func-功能） comment : 功能单元描述. 四. 系统结构构建流程 # 下图描述系统结构的关联：</description></item><item><title>1.6 权限设计-基于Plan的权限方案设计</title><link>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.6/</guid><description>基于Plan的权限方案设计 # 一. Plan的结构组成 # 权限Plan是基于构造出来的系统结构，基于系统模板，构造出一个个不同的权限Plan，具体的Plan构造方式如下。
二. Plan数据结构设计 # 为了有结构的保存用户Plan权限，我们需要一张单独的数据表，这张数据表主要包括以下几个字段：
id : 序号 plan_name: paln名称 plan_json : 基于系统目录结构构造的Plan json，用于web端或其他来展示。 ids : 操作单元的ids，用来判断用户权限。 数据结构样例解析如下: # 为了方便前端展示，我们把plan的数据结构分为两种模式存储，json的格式大致为 {&amp;ldquo;系统&amp;rdquo;:{&amp;ldquo;一级目录1&amp;rdquo;:{&amp;ldquo;二级目录1&amp;rdquo;:[&amp;ldquo;功能1&amp;rdquo;]},&amp;ldquo;一级目录2&amp;rdquo;:{&amp;ldquo;二级目录2&amp;rdquo;:[&amp;ldquo;功能2&amp;rdquo;]}}}
为了方便api对于权限进行判断，我们对plan所拥有的api权限，使用操作单元的ids进行存储，这层可用来对于用户权限快速查询.
这部分功能单元部分 还需要把下属的操作单元ids包括进来，把权限力度降到最低。
三. Plan相关功能包 # 上面阐述了Plan相关的数据结构设计，在相关的数据结构基础上，还需要一个Plan权限操作包，操作包中包含下面方法：
校验路由权限： module ， controller ， method 是否属于用户plan范围内
获取指定Plan的数据结构：数组结构
存储Plan数据结构
3.1 权限校验功能 # 这部分需要检查当前请求的路由是否属于用户拥有的权限，首先应该去缓存中获取用户的权限信息，如果没有，则需要进行权限获取。取得用户权限之后，需要对于当前的路由和用户的权限进行比对，如果成功，则放行，否则将无权访问。</description></item></channel></rss>