<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Request Handle 顾名思义 ,它的主要职责用来承载用户API请求,基于这个包将会衍生出框架的控制器基础类，也可以让当前类成为控制器基础类，控制器基础类将被每个实体业务控制器继承,所以它处在AK-FRAME层面.
所以在AK-FRAME层面,我们有request目录用来存储request相关的类实现文件,配置文件,相关工具包文件.
一. 工作流程组成部分 # 1.1 Request-Handle 模块设计图 # Request-Handle 模块主要包括 请求合法性检测、请求数据体分析、权限校验等模块组成，相关具体的模块设计图如下所示：
二. 相关组件介绍 # 2.1 Request-Handle组件类 # 为了把Request模块统一打包对外服务，所以这里我们需要把Request-Handle组件抽象为一个RequestHandle类，这个类主要包含一些相关模块方法，可以被外部类引用，在请求校验阶段做出贡献。
2.2 请求合法性检测 # 对于网络请求来源复杂，我们首先不能让请求轻易进入消耗计算机资源的环节，所以这部分很关键，但是这部分具有很强的不确定性。因为随着计算机技术的发展，爬虫技术等模拟技术，黑客攻击的升级，这部分可能面临着修改的可能性，因此这部分除了进行基础的请求过滤外，还需要留下相关的扩展函数，便于后期进行调整。
请求合法性检测在实现层是RequestHandle类的一个函数，函数名为checkRequest，这个函数主要完成两部分工作。
路由放行：调用RequestHandle类子函数isRouteIgnore，这个部分主要检查当前请求的控制器和方法是不是在路由忽略列表，如果在列表内，则放过这个请求，这个应用场景主要针对一些权限初始化接口，比如用户登录、获取token 接口。
请求参数校验：调用RequestHandle类子函数checkHeader，这个部分主要对于header头部参数里的一些约定条件进行检测，目前主要包括的参数包括JWT令牌数据、请求来源from参数，这两个检测过程均为调用RequestHandle内部函数。
2.2.1 JWT组件包 # JWT 是通用令牌协议，基于JWT可以做用户安全校验、同时开源社区提供了相关的代码包，可以帮助系统框架快速构建JWT令牌模块。
但是，在安装了JWT包后，我们不能直接使用开源社区的裸包，我们需要在AK-FRAME封装JWT子模块，子模块主要提供生成JWT和解析JWT的代码包，JWT封装层注意封装的用户单元信息不要采用uid，要采用用户名，便于后期做分布式系统，基于用户名的JWT，可以在各个系统之间可以做到统一登录。
校验JWT模块，这个是JWT包中的一个方法，名称为checkJWT，这个函数在RequestHandle类子函数checkHeader中被调用，主要对header头部传输进来的JWT数据做数据段的检验，包括JWT长度，和相关数据段拆分，如果JWT验证成功，则要把拆分后的数据体组成数组返回上一级，便于上一级函数把数据加载进控制器基础类相关属性。
2.2.2 请求参数匹配函数（filterRequestParames方法） # 需要在 RequestHandle类中实现出请求参数匹配函数，这个是一个扩展单元，目前可以在函数内部仅仅做header部分的from参数判断，比如参数值可以为app，web，wechat，如果不在列表，则返回false，由上级接收到返回值后决定是否放行请求，在以后可能会对更多的请求参数进行过滤，这个函数将起到过滤效果。
2.3 请求数据体分析（getRequestData方法） # 如果上面的流程已经顺利通过，那么这个请求在安全程度上已经是合法的了，那么将进行非常重要的两部分操作。
这个方法将调用ak-frame中的request目录下的requestData工具类，
请求数据体抽取：对于request 请求体的相关参数进行抽取，这部分是requestData工具类的实现，这个工具类基于TP5.1的request部分做了一层封装，提供一些基础方法，比如findGetDataByKey,findPostDataByKey等，这层封装既可以满足已经定制化请求数据，还可以降级对于TP框架的耦合度。
检查路由权限：这部分流程则需要检查当前请求所处的路由是够属于前面部分解析的JWT所对应的用户拥有的权限，首先会取出控制器基础类中的用户名，然后去缓存中查询是否有对应的用户权限，如果没有则调用权限包中的权限分析方法对于JWT解析出的用户名进行权限获取，如果已经存在则把缓存权限取出来，这两条线路最终都需要对于当前路由和用户权限列表中进行搜索，如果找到则放行，否则就拒绝访问。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:type" content="website"><meta property="og:image" content="https://res.cloudinary.com/malloc/image/upload/v1666510486/icefiredb/logo_z8koem.png"><meta property="og:title" content="1.3 AK-FRAME设计-Request Handle设计阐述"><meta property="og:description" content="Request Handle 顾名思义 ,它的主要职责用来承载用户API请求,基于这个包将会衍生出框架的控制器基础类，也可以让当前类成为控制器基础类，控制器基础类将被每个实体业务控制器继承,所以它处在AK-FRAME层面.
所以在AK-FRAME层面,我们有request目录用来存储request相关的类实现文件,配置文件,相关工具包文件.
一. 工作流程组成部分 # 1.1 Request-Handle 模块设计图 # Request-Handle 模块主要包括 请求合法性检测、请求数据体分析、权限校验等模块组成，相关具体的模块设计图如下所示：
二. 相关组件介绍 # 2.1 Request-Handle组件类 # 为了把Request模块统一打包对外服务，所以这里我们需要把Request-Handle组件抽象为一个RequestHandle类，这个类主要包含一些相关模块方法，可以被外部类引用，在请求校验阶段做出贡献。
2.2 请求合法性检测 # 对于网络请求来源复杂，我们首先不能让请求轻易进入消耗计算机资源的环节，所以这部分很关键，但是这部分具有很强的不确定性。因为随着计算机技术的发展，爬虫技术等模拟技术，黑客攻击的升级，这部分可能面临着修改的可能性，因此这部分除了进行基础的请求过滤外，还需要留下相关的扩展函数，便于后期进行调整。
请求合法性检测在实现层是RequestHandle类的一个函数，函数名为checkRequest，这个函数主要完成两部分工作。
路由放行：调用RequestHandle类子函数isRouteIgnore，这个部分主要检查当前请求的控制器和方法是不是在路由忽略列表，如果在列表内，则放过这个请求，这个应用场景主要针对一些权限初始化接口，比如用户登录、获取token 接口。
请求参数校验：调用RequestHandle类子函数checkHeader，这个部分主要对于header头部参数里的一些约定条件进行检测，目前主要包括的参数包括JWT令牌数据、请求来源from参数，这两个检测过程均为调用RequestHandle内部函数。
2.2.1 JWT组件包 # JWT 是通用令牌协议，基于JWT可以做用户安全校验、同时开源社区提供了相关的代码包，可以帮助系统框架快速构建JWT令牌模块。
但是，在安装了JWT包后，我们不能直接使用开源社区的裸包，我们需要在AK-FRAME封装JWT子模块，子模块主要提供生成JWT和解析JWT的代码包，JWT封装层注意封装的用户单元信息不要采用uid，要采用用户名，便于后期做分布式系统，基于用户名的JWT，可以在各个系统之间可以做到统一登录。
校验JWT模块，这个是JWT包中的一个方法，名称为checkJWT，这个函数在RequestHandle类子函数checkHeader中被调用，主要对header头部传输进来的JWT数据做数据段的检验，包括JWT长度，和相关数据段拆分，如果JWT验证成功，则要把拆分后的数据体组成数组返回上一级，便于上一级函数把数据加载进控制器基础类相关属性。
2.2.2 请求参数匹配函数（filterRequestParames方法） # 需要在 RequestHandle类中实现出请求参数匹配函数，这个是一个扩展单元，目前可以在函数内部仅仅做header部分的from参数判断，比如参数值可以为app，web，wechat，如果不在列表，则返回false，由上级接收到返回值后决定是否放行请求，在以后可能会对更多的请求参数进行过滤，这个函数将起到过滤效果。
2.3 请求数据体分析（getRequestData方法） # 如果上面的流程已经顺利通过，那么这个请求在安全程度上已经是合法的了，那么将进行非常重要的两部分操作。
这个方法将调用ak-frame中的request目录下的requestData工具类，
请求数据体抽取：对于request 请求体的相关参数进行抽取，这部分是requestData工具类的实现，这个工具类基于TP5.1的request部分做了一层封装，提供一些基础方法，比如findGetDataByKey,findPostDataByKey等，这层封装既可以满足已经定制化请求数据，还可以降级对于TP框架的耦合度。
检查路由权限：这部分流程则需要检查当前请求所处的路由是够属于前面部分解析的JWT所对应的用户拥有的权限，首先会取出控制器基础类中的用户名，然后去缓存中查询是否有对应的用户权限，如果没有则调用权限包中的权限分析方法对于JWT解析出的用户名进行权限获取，如果已经存在则把缓存权限取出来，这两条线路最终都需要对于当前路由和用户权限列表中进行搜索，如果找到则放行，否则就拒绝访问。"><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.3/"><meta property="article:section" content="DocCenter"><title>1.3 AK-FRAME设计-Request Handle设计阐述 | 工匠之芯-文档中心</title><link rel=manifest href=/icorer_docs/manifest.json><link rel=icon href=/icorer_docs/favicon.ico type=image/x-icon><link rel=stylesheet href=/icorer_docs/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css integrity="sha256-RhgbyTN1upMgJudTs3xA5v+LsWqe93DHi8xmPkV3sbo=" crossorigin=anonymous><script defer src=/icorer_docs/flexsearch.min.js></script>
<script defer src=/icorer_docs/en.search.min.ee165dfe19442132c4eb704018a9e6fe19ae45173fbd75bc2175474a26f0b1ac.js integrity="sha256-7hZd/hlEITLE63BAGKnm/hmuRRc/vXW8IXVHSibwsaw=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/icorer_docs/><span>工匠之芯-文档中心</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://icorer.com/ target=_blank rel=noopener>工匠之芯</a></li><li><a href=https://github.com/gitsrc target=_blank rel=noopener>Open Source</a></li></ul><ul><li class=book-section-flat><a href=https://icorer.com/icorer_docs/doccenter/>项目总览</a><ul><li><input type=checkbox id=section-aed24396fef473497b12e93db0aa8548 class=toggle>
<label for=section-aed24396fef473497b12e93db0aa8548 class="flex justify-between"><a href=https://icorer.com/icorer_docs/doccenter/redishub/>RedisHub</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/>系统设计</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.1/>1.1基础运行框架</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.2/>1.2配置解析器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.3/>1.3通信组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.4/>1.4 协议解析器与拦截器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.5/>1.5 NetHandle组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.6/>1.6 集群 MSET 指令支持</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.7/>1.7 集群 MGET 指令支持</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.8/>1.9 Redis集群状态更新</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.9/>1.8 TCP连接池</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.10/>1.10 RESP协议解析</a></li></ul></li><li><span>系统模块测试</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/2.1/>2.1 NetHandle组件测试</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/2.2/>2.2 中间件完整测试</a></li></ul></li><li><span>中间件部署</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/deploy/3.1/>3.1 部署文档</a></li></ul></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/system_access/>系统接入</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/system_access/4.1/>4.1 phpredis对接redishub</a></li></ul></li></ul></li><li><input type=checkbox id=section-14e1ec26ce57d625211daa6855b123ba class=toggle>
<label for=section-14e1ec26ce57d625211daa6855b123ba class="flex justify-between"><a href=https://icorer.com/icorer_docs/doccenter/redistun/>RedisTun</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/>系统设计</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/1.1/>1.1基础运行框架</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/1.2/>1.2配置解析器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/1.3/>1.3通信组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/1.4/>1.4 协议解析器与拦截器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/1.5/>1.5 NetHandle组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/1.6/>1.6 哈希分操器组件</a></li></ul></li><li><span>系统模块测试</span><ul></ul></li><li><span>中间件部署</span><ul></ul></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/system_access/>系统接入</a><ul></ul></li></ul></li><li><input type=checkbox id=section-a22dab337e8b55a3f7712060bcd10bb9 class=toggle checked>
<label for=section-a22dab337e8b55a3f7712060bcd10bb9 class="flex justify-between"><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/>AK-2019</a></label><ul><li><span>系统设计</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.1/>框架层次设计</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.2/>1.2 AK-FRAME设计-Request Handle设计</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.3/ class=active>1.3 AK-FRAME设计-Request Handle设计阐述</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.4/>1.4 权限设计-最小操作与功能单元</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.5/>1.5 权限设计-系统结构设计</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/designs/1.6/>1.6 权限设计-基于Plan的权限方案设计</a></li></ul></li></ul></li><li><input type=checkbox id=section-1453ce2c5ecb8c18c2860dade55163de class=toggle>
<label for=section-1453ce2c5ecb8c18c2860dade55163de class="flex justify-between"><a role=button>PulseFlow</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/overviews/>PulseFlow概览</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/overviews/1.1/>1.1 安装文档</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/overviews/1.2/>1.2 使用文档</a></li></ul></li><li><span>PulseFlow插件端</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/pulgin_designed/2.1/>2.1 扩展总览</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/pulgin_designed/2.2/>2.2 数据结构</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/pulgin_designed/2.3/>2.3 功能流程</a></li></ul></li><li><span>PulseFlow后台端</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/plugin_backend/3.1/>3.1 后台总览</a></li></ul></li><li><span>运行情况</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/run_status/4.1/>4.1 运行跟踪报告</a></li></ul></li></ul></li><li><input type=checkbox id=section-404d707d87f9ef4c7b157ec13db25c80 class=toggle>
<label for=section-404d707d87f9ef4c7b157ec13db25c80 class="flex justify-between"><a href=https://icorer.com/icorer_docs/doccenter/logdarts/>LogDarts组件风险评估</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/designs/>风险分析</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/designs/1.1/>1.1 数据结构分析</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/designs/1.2/>1.2 代码流程分析</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/designs/1.3/>1.3 异常监控分析</a></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/icorer_docs/svg/menu.svg class=book-icon alt=Menu></label>
<strong>1.3 AK-FRAME设计-Request Handle设计阐述</strong>
<label for=toc-control><img src=/icorer_docs/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#11-request-handle-模块设计图>1.1 Request-Handle 模块设计图</a></li></ul><ul><li><a href=#21-request-handle组件类>2.1 Request-Handle组件类</a></li><li><a href=#22-请求合法性检测>2.2 请求合法性检测</a><ul><li><a href=#221-jwt组件包>2.2.1 JWT组件包</a></li><li><a href=#222-请求参数匹配函数filterrequestparames方法>2.2.2 请求参数匹配函数（filterRequestParames方法）</a></li></ul></li><li><a href=#23-请求数据体分析getrequestdata方法>2.3 请求数据体分析（getRequestData方法）</a></li></ul></nav></aside></header><article class=markdown><p>Request Handle 顾名思义 ,它的主要职责用来承载用户API请求,基于这个包将会衍生出框架的控制器基础类，也可以让当前类成为控制器基础类，控制器基础类将被每个实体业务控制器继承,所以它处在AK-FRAME层面.</p><p>所以在AK-FRAME层面,我们有request目录用来存储request相关的类实现文件,配置文件,相关工具包文件.</p><h1 id=一-工作流程组成部分>一. 工作流程组成部分
<a class=anchor href=#%e4%b8%80-%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e7%bb%84%e6%88%90%e9%83%a8%e5%88%86>#</a></h1><h2 id=11-request-handle-模块设计图>1.1 Request-Handle 模块设计图
<a class=anchor href=#11-request-handle-%e6%a8%a1%e5%9d%97%e8%ae%be%e8%ae%a1%e5%9b%be>#</a></h2><p>Request-Handle 模块主要包括 请求合法性检测、请求数据体分析、权限校验等模块组成，相关具体的模块设计图如下所示：</p><center><img src=https://icorer.com/icorer_docs/uploads/ak-2019/images/m_552c0c93c0535b20a4a893f081314523_r.png width=50%></center><h1 id=二-相关组件介绍>二. 相关组件介绍
<a class=anchor href=#%e4%ba%8c-%e7%9b%b8%e5%85%b3%e7%bb%84%e4%bb%b6%e4%bb%8b%e7%bb%8d>#</a></h1><h2 id=21-request-handle组件类>2.1 Request-Handle组件类
<a class=anchor href=#21-request-handle%e7%bb%84%e4%bb%b6%e7%b1%bb>#</a></h2><p>为了把Request模块统一打包对外服务，所以这里我们需要把Request-Handle组件抽象为一个RequestHandle类，这个类主要包含一些相关模块方法，可以被外部类引用，在请求校验阶段做出贡献。</p><h2 id=22-请求合法性检测>2.2 请求合法性检测
<a class=anchor href=#22-%e8%af%b7%e6%b1%82%e5%90%88%e6%b3%95%e6%80%a7%e6%a3%80%e6%b5%8b>#</a></h2><p>对于网络请求来源复杂，我们首先不能让请求轻易进入消耗计算机资源的环节，所以这部分很关键，但是这部分具有很强的不确定性。因为随着计算机技术的发展，爬虫技术等模拟技术，黑客攻击的升级，这部分可能面临着修改的可能性，因此这部分除了进行基础的请求过滤外，还需要留下相关的扩展函数，便于后期进行调整。</p><p>请求合法性检测在实现层是RequestHandle类的一个函数，函数名为checkRequest，这个函数主要完成两部分工作。</p><ol><li><p>路由放行：调用RequestHandle类子函数isRouteIgnore，这个部分主要检查当前请求的控制器和方法是不是在路由忽略列表，如果在列表内，则放过这个请求，这个应用场景主要针对一些权限初始化接口，比如用户登录、获取token 接口。</p></li><li><p>请求参数校验：调用RequestHandle类子函数checkHeader，这个部分主要对于header头部参数里的一些约定条件进行检测，目前主要包括的参数包括JWT令牌数据、请求来源from参数，这两个检测过程均为调用RequestHandle内部函数。</p></li></ol><h3 id=221-jwt组件包>2.2.1 JWT组件包
<a class=anchor href=#221-jwt%e7%bb%84%e4%bb%b6%e5%8c%85>#</a></h3><p>JWT 是通用令牌协议，基于JWT可以做用户安全校验、同时开源社区提供了相关的代码包，可以帮助系统框架快速构建JWT令牌模块。</p><p>但是，在安装了JWT包后，我们不能直接使用开源社区的裸包，我们需要在AK-FRAME封装JWT子模块，子模块主要提供生成JWT和解析JWT的代码包，JWT封装层注意封装的用户单元信息不要采用uid，要采用用户名，便于后期做分布式系统，基于用户名的JWT，可以在各个系统之间可以做到统一登录。</p><p>校验JWT模块，这个是JWT包中的一个方法，名称为checkJWT，这个函数在RequestHandle类子函数checkHeader中被调用，主要对header头部传输进来的JWT数据做数据段的检验，包括JWT长度，和相关数据段拆分，如果JWT验证成功，则要把拆分后的数据体组成数组返回上一级，便于上一级函数把数据加载进控制器基础类相关属性。</p><h3 id=222-请求参数匹配函数filterrequestparames方法>2.2.2 请求参数匹配函数（filterRequestParames方法）
<a class=anchor href=#222-%e8%af%b7%e6%b1%82%e5%8f%82%e6%95%b0%e5%8c%b9%e9%85%8d%e5%87%bd%e6%95%b0filterrequestparames%e6%96%b9%e6%b3%95>#</a></h3><p>需要在 RequestHandle类中实现出请求参数匹配函数，这个是一个扩展单元，目前可以在函数内部仅仅做header部分的from参数判断，比如参数值可以为app，web，wechat，如果不在列表，则返回false，由上级接收到返回值后决定是否放行请求，在以后可能会对更多的请求参数进行过滤，这个函数将起到过滤效果。</p><h2 id=23-请求数据体分析getrequestdata方法>2.3 请求数据体分析（getRequestData方法）
<a class=anchor href=#23-%e8%af%b7%e6%b1%82%e6%95%b0%e6%8d%ae%e4%bd%93%e5%88%86%e6%9e%90getrequestdata%e6%96%b9%e6%b3%95>#</a></h2><p>如果上面的流程已经顺利通过，那么这个请求在安全程度上已经是合法的了，那么将进行非常重要的两部分操作。</p><p>这个方法将调用ak-frame中的request目录下的requestData工具类，</p><ol><li><p>请求数据体抽取：对于request 请求体的相关参数进行抽取，这部分是requestData工具类的实现，这个工具类基于TP5.1的request部分做了一层封装，提供一些基础方法，比如findGetDataByKey,findPostDataByKey等，这层封装既可以满足已经定制化请求数据，还可以降级对于TP框架的耦合度。</p></li><li><p>检查路由权限：这部分流程则需要检查当前请求所处的路由是够属于前面部分解析的JWT所对应的用户拥有的权限，首先会取出控制器基础类中的用户名，然后去缓存中查询是否有对应的用户权限，如果没有则调用权限包中的权限分析方法对于JWT解析出的用户名进行权限获取，如果已经存在则把缓存权限取出来，这两条线路最终都需要对于当前路由和用户权限列表中进行搜索，如果找到则放行，否则就拒绝访问。</p></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#11-request-handle-模块设计图>1.1 Request-Handle 模块设计图</a></li></ul><ul><li><a href=#21-request-handle组件类>2.1 Request-Handle组件类</a></li><li><a href=#22-请求合法性检测>2.2 请求合法性检测</a><ul><li><a href=#221-jwt组件包>2.2.1 JWT组件包</a></li><li><a href=#222-请求参数匹配函数filterrequestparames方法>2.2.2 请求参数匹配函数（filterRequestParames方法）</a></li></ul></li><li><a href=#23-请求数据体分析getrequestdata方法>2.3 请求数据体分析（getRequestData方法）</a></li></ul></nav></div></aside></main></body></html>