<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="1.8 TCP连接池 # 1.8.1 连接池是什么 # 我们常见的池很多，比如内存池，线程池，对象池，连接池等。顾名思义，池子干的事情都是一样的，把一类相同的事物放到一个池里面，已备不时之需，好比我们的蓄水池一样，把平日多余的水储蓄起来，一方面防止洪水到来时候对下游造成洪涝灾害，另一方面还可以合理灌溉资源利用，比如还可以水力发电。同样连接池是把已经已经建立好的连接放入一个池子，当请求到来可以直接拿来使用，这样就即解决了频繁的创建关闭连接带来的开销，也保护了后端服务，防止同时有大量连接涌入，造成危害。
1.8.2 连接池的种类 # 其实也就是连接池的使用场景
可以是一个独立部署的服务，通过套接字提供代理服务。例如我们的常用的dbproxy。
可以是一个服务内部进程间共享的连接池，这种相对更加轻量，可以理解为项目级别，只对内提供服务。
进程内的连接池，更加轻量，当前进程内的线程或者协程可以使用。
RedisHub 实现的连接池就是 进程内的连接池，使用连接池有以下好处：
减少客户端使用连接时，创建和销毁连接的时间和系统资源开销，这里涉及到TCP的三次握手也四次挥手，还有TCP的慢启动预热。 避免极端情况大量连接直接涌入后端服务，对整个系统服务造成危害。 但同时也有一些缺点，比如空闲状态下也要维护一定数量的连接，占用客户端和服务端的资源，这里可以根据实际需求动态调配连接数，达到效率和资源利用的平衡。哪有一点资源不占用，还想系统高效稳定的事情，建个水坝还得占片地，护坝人间断性的职守呢。
1.8.3 TCP连接池初始化方式 # TCP连接池的最终目标就是对程序体内部需要使用的TCP连接进行池化管理，连接不够使用时自动扩容、连接过剩的时候能够自动回收，所以 我们首先需要考虑TCP连接池的初始化方式。连接池的初始化方式主要包括如下两种：
当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，创建连接对象，请求结束的时候，归还至连接池.
进程启动的时候，创建固定数量的连接对象，当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，继续等待或者服务降级; 不为空的话正常服务，请求结束的时候，归还至连接池.
RedisHub 中间件的TCP连接池初始化方式选择第一种。针对第二种连接池的实现方案，可以查阅本人另外一个项目RedisTun。
1.8.4 连接池源码分析 - 获取一个可用链接 # func (node *redisNode) getConn() (*redisConn, error) { //需要针对当前的redis-node的tcp连接池进行内存操作，在并发场景下，首先先上锁。 node.mutex.Lock() //如果当前node已经进入不可用状态。 if node.closed { node.mutex.Unlock() return nil, fmt.Errorf(&#34;getConn: connection has been closed&#34;) } //从TCP连接池中清理陈旧的TCP连接，这里面使用了LIST数据结构，可以把陈旧连接进行归并、一并处理。 //如果连接远程node节点时候设置了TCP连接存活时间 则 进行检验。 if node.aliveTime > 0 { for { //从list中选择一个元素，如果conns列表为空 则跳出检查 elem := node."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:type" content="website"><meta property="og:image" content="https://res.cloudinary.com/malloc/image/upload/v1666510486/icefiredb/logo_z8koem.png"><meta property="og:title" content="1.8 TCP连接池"><meta property="og:description" content="1.8 TCP连接池 # 1.8.1 连接池是什么 # 我们常见的池很多，比如内存池，线程池，对象池，连接池等。顾名思义，池子干的事情都是一样的，把一类相同的事物放到一个池里面，已备不时之需，好比我们的蓄水池一样，把平日多余的水储蓄起来，一方面防止洪水到来时候对下游造成洪涝灾害，另一方面还可以合理灌溉资源利用，比如还可以水力发电。同样连接池是把已经已经建立好的连接放入一个池子，当请求到来可以直接拿来使用，这样就即解决了频繁的创建关闭连接带来的开销，也保护了后端服务，防止同时有大量连接涌入，造成危害。
1.8.2 连接池的种类 # 其实也就是连接池的使用场景
可以是一个独立部署的服务，通过套接字提供代理服务。例如我们的常用的dbproxy。
可以是一个服务内部进程间共享的连接池，这种相对更加轻量，可以理解为项目级别，只对内提供服务。
进程内的连接池，更加轻量，当前进程内的线程或者协程可以使用。
RedisHub 实现的连接池就是 进程内的连接池，使用连接池有以下好处：
减少客户端使用连接时，创建和销毁连接的时间和系统资源开销，这里涉及到TCP的三次握手也四次挥手，还有TCP的慢启动预热。 避免极端情况大量连接直接涌入后端服务，对整个系统服务造成危害。 但同时也有一些缺点，比如空闲状态下也要维护一定数量的连接，占用客户端和服务端的资源，这里可以根据实际需求动态调配连接数，达到效率和资源利用的平衡。哪有一点资源不占用，还想系统高效稳定的事情，建个水坝还得占片地，护坝人间断性的职守呢。
1.8.3 TCP连接池初始化方式 # TCP连接池的最终目标就是对程序体内部需要使用的TCP连接进行池化管理，连接不够使用时自动扩容、连接过剩的时候能够自动回收，所以 我们首先需要考虑TCP连接池的初始化方式。连接池的初始化方式主要包括如下两种：
当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，创建连接对象，请求结束的时候，归还至连接池.
进程启动的时候，创建固定数量的连接对象，当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，继续等待或者服务降级; 不为空的话正常服务，请求结束的时候，归还至连接池.
RedisHub 中间件的TCP连接池初始化方式选择第一种。针对第二种连接池的实现方案，可以查阅本人另外一个项目RedisTun。
1.8.4 连接池源码分析 - 获取一个可用链接 # func (node *redisNode) getConn() (*redisConn, error) { //需要针对当前的redis-node的tcp连接池进行内存操作，在并发场景下，首先先上锁。 node.mutex.Lock() //如果当前node已经进入不可用状态。 if node.closed { node.mutex.Unlock() return nil, fmt.Errorf(&#34;getConn: connection has been closed&#34;) } //从TCP连接池中清理陈旧的TCP连接，这里面使用了LIST数据结构，可以把陈旧连接进行归并、一并处理。 //如果连接远程node节点时候设置了TCP连接存活时间 则 进行检验。 if node.aliveTime > 0 { for { //从list中选择一个元素，如果conns列表为空 则跳出检查 elem := node."><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_docs/doccenter/redishub/designs/1.9/"><meta property="article:section" content="DocCenter"><title>1.8 TCP连接池 | 工匠之芯-文档中心</title><link rel=manifest href=/icorer_docs/manifest.json><link rel=icon href=/icorer_docs/favicon.ico type=image/x-icon><link rel=stylesheet href=/icorer_docs/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css integrity="sha256-RhgbyTN1upMgJudTs3xA5v+LsWqe93DHi8xmPkV3sbo=" crossorigin=anonymous><script defer src=/icorer_docs/flexsearch.min.js></script>
<script defer src=/icorer_docs/en.search.min.b4ceeb102583c24afd86cea861a906fdcb3c2b7d8cca04ff929c199c038d080d.js integrity="sha256-tM7rECWDwkr9hs6oYakG/cs8K32MygT/kpwZnAONCA0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/icorer_docs/><span>工匠之芯-文档中心</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://icorer.com/ target=_blank rel=noopener>工匠之芯</a></li><li><a href=https://github.com/gitsrc target=_blank rel=noopener>Open Source</a></li></ul><ul><li class=book-section-flat><a href=https://icorer.com/icorer_docs/doccenter/>项目总览</a><ul><li><input type=checkbox id=section-aed24396fef473497b12e93db0aa8548 class=toggle checked>
<label for=section-aed24396fef473497b12e93db0aa8548 class="flex justify-between"><a href=https://icorer.com/icorer_docs/doccenter/redishub/>RedisHub</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/>系统设计</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.1/>1.1基础运行框架</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.2/>1.2配置解析器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.3/>1.3通信组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.4/>1.4 协议解析器与拦截器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.5/>1.5 NetHandle组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.6/>1.5 集群 MSET 指令支持</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.7/>1.7 集群 MGET 指令支持</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.8/>1.9 Redis集群状态更新</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.9/ class=active>1.8 TCP连接池</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.10/>1.10 RESP协议解析</a></li></ul></li><li><span>系统模块测试</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/icefiredb-crdt-kv/>icefiredb-crdt-kv</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/icefiredb-ipfs-log/>icefiredb-ipfs-log</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/icefiredb_proxy/>icefiredb-proxy</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/redhub/>redhub-frame</a></li></ul></li><li><span>中间件部署</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/deploy/orbitdb/>OrbitDB</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/deploy/threaddb/>ThreadDB</a></li></ul></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/system_access/>系统接入</a><ul></ul></li></ul></li><li><input type=checkbox id=section-1453ce2c5ecb8c18c2860dade55163de class=toggle>
<label for=section-1453ce2c5ecb8c18c2860dade55163de class="flex justify-between"><a role=button>PulseFlow</a></label><ul><li><input type=checkbox id=section-b349698f86361cb77fa3daf6029bb134 class=toggle>
<label for=section-b349698f86361cb77fa3daf6029bb134 class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/overview/>OverView</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/network/>NetWork</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/storage/>Storage</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/protocol/>Protocol</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/codec/>Codec</a></li></ul></li></ul></li><li><input type=checkbox id=section-14e1ec26ce57d625211daa6855b123ba class=toggle>
<label for=section-14e1ec26ce57d625211daa6855b123ba class="flex justify-between"><a role=button>RedisTun</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/quick_start/>Quick Start</a><ul></ul></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/>Designs</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/network/>Network layer</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/storage/>Storage layer</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/protocol/>Protocol layer</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/codec/>Codec layer</a></li></ul></li><li><span>Develop</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-crdt-kv/>icefiredb-crdt-kv</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-ipfs-log/>icefiredb-ipfs-log</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb_proxy/>icefiredb-proxy</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/redhub/>redhub-frame</a></li></ul></li><li><span>Project Comparison</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/orbitdb/>OrbitDB</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/threaddb/>ThreadDB</a></li></ul></li></ul></li><li><input type=checkbox id=section-404d707d87f9ef4c7b157ec13db25c80 class=toggle>
<label for=section-404d707d87f9ef4c7b157ec13db25c80 class="flex justify-between"><a role=button>LogDarts</a></label><ul><li><input type=checkbox id=section-658ed1b71722eedc365fde2c5579594f class=toggle>
<label for=section-658ed1b71722eedc365fde2c5579594f class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/overview/>OverView</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/network/>NetWork</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/storage/>Storage</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/protocol/>Protocol</a></li></ul></li></ul></li><li><input type=checkbox id=section-a22dab337e8b55a3f7712060bcd10bb9 class=toggle>
<label for=section-a22dab337e8b55a3f7712060bcd10bb9 class="flex justify-between"><a role=button>AK-2019</a></label><ul><li><input type=checkbox id=section-549f710dc768b95bd2287ab37bb3db61 class=toggle>
<label for=section-549f710dc768b95bd2287ab37bb3db61 class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/overview/>OverView</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/network/>NetWork</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/storage/>Storage</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/protocol/>Protocol</a></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/icorer_docs/svg/menu.svg class=book-icon alt=Menu></label>
<strong>1.8 TCP连接池</strong>
<label for=toc-control><img src=/icorer_docs/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#181--连接池是什么>1.8.1 连接池是什么</a></li><li><a href=#182--连接池的种类>1.8.2 连接池的种类</a></li><li><a href=#183-tcp连接池初始化方式>1.8.3 TCP连接池初始化方式</a></li><li><a href=#184-连接池源码分析---获取一个可用链接>1.8.4 连接池源码分析 - 获取一个可用链接</a></li><li><a href=#185-连接池源码分析----放回可用连接进入池>1.8.5 连接池源码分析 - 放回可用连接进入池</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=18-tcp连接池>1.8 TCP连接池
<a class=anchor href=#18-tcp%e8%bf%9e%e6%8e%a5%e6%b1%a0>#</a></h1><h3 id=181--连接池是什么>1.8.1 连接池是什么
<a class=anchor href=#181--%e8%bf%9e%e6%8e%a5%e6%b1%a0%e6%98%af%e4%bb%80%e4%b9%88>#</a></h3><p>我们常见的池很多，比如内存池，线程池，对象池，连接池等。顾名思义，池子干的事情都是一样的，把一类相同的事物放到一个池里面，已备不时之需，好比我们的蓄水池一样，把平日多余的水储蓄起来，一方面防止洪水到来时候对下游造成洪涝灾害，另一方面还可以合理灌溉资源利用，比如还可以水力发电。同样连接池是把已经已经建立好的连接放入一个池子，当请求到来可以直接拿来使用，这样就即解决了频繁的创建关闭连接带来的开销，也保护了后端服务，防止同时有大量连接涌入，造成危害。</p><h3 id=182--连接池的种类>1.8.2 连接池的种类
<a class=anchor href=#182--%e8%bf%9e%e6%8e%a5%e6%b1%a0%e7%9a%84%e7%a7%8d%e7%b1%bb>#</a></h3><p>其实也就是连接池的使用场景</p><ol><li><p>可以是一个独立部署的服务，通过套接字提供代理服务。例如我们的常用的dbproxy。</p></li><li><p>可以是一个服务内部进程间共享的连接池，这种相对更加轻量，可以理解为项目级别，只对内提供服务。</p></li><li><p>进程内的连接池，更加轻量，当前进程内的线程或者协程可以使用。</p></li></ol><p>RedisHub 实现的连接池就是 进程内的连接池，使用连接池有以下好处：</p><ol><li>减少客户端使用连接时，创建和销毁连接的时间和系统资源开销，这里涉及到TCP的三次握手也四次挥手，还有TCP的慢启动预热。</li><li>避免极端情况大量连接直接涌入后端服务，对整个系统服务造成危害。</li></ol><p>但同时也有一些缺点，比如空闲状态下也要维护一定数量的连接，占用客户端和服务端的资源，这里可以根据实际需求动态调配连接数，达到效率和资源利用的平衡。哪有一点资源不占用，还想系统高效稳定的事情，建个水坝还得占片地，护坝人间断性的职守呢。</p><h3 id=183-tcp连接池初始化方式>1.8.3 TCP连接池初始化方式
<a class=anchor href=#183-tcp%e8%bf%9e%e6%8e%a5%e6%b1%a0%e5%88%9d%e5%a7%8b%e5%8c%96%e6%96%b9%e5%bc%8f>#</a></h3><p>TCP连接池的最终目标就是对程序体内部需要使用的TCP连接进行池化管理，连接不够使用时自动扩容、连接过剩的时候能够自动回收，所以 我们首先需要考虑TCP连接池的初始化方式。连接池的初始化方式主要包括如下两种：</p><ol><li><p>当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，创建连接对象，请求结束的时候，归还至连接池.</p></li><li><p>进程启动的时候，创建固定数量的连接对象，当请求到来的时候，尝试从连接池中获取连接对象，如果连接池为空，继续等待或者服务降级; 不为空的话正常服务，请求结束的时候，归还至连接池.</p></li></ol><p>RedisHub 中间件的TCP连接池初始化方式选择第一种。针对第二种连接池的实现方案，可以查阅本人另外一个项目RedisTun。</p><h3 id=184-连接池源码分析---获取一个可用链接>1.8.4 连接池源码分析 - 获取一个可用链接
<a class=anchor href=#184-%e8%bf%9e%e6%8e%a5%e6%b1%a0%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90---%e8%8e%b7%e5%8f%96%e4%b8%80%e4%b8%aa%e5%8f%af%e7%94%a8%e9%93%be%e6%8e%a5>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>redisNode</span>) <span style=color:#a6e22e>getConn</span>() (<span style=color:#f92672>*</span><span style=color:#a6e22e>redisConn</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//需要针对当前的redis-node的tcp连接池进行内存操作，在并发场景下，首先先上锁。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//如果当前node已经进入不可用状态。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>closed</span> {  
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;getConn: connection has been closed&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//从TCP连接池中清理陈旧的TCP连接，这里面使用了LIST数据结构，可以把陈旧连接进行归并、一并处理。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//如果连接远程node节点时候设置了TCP连接存活时间 则 进行检验。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>aliveTime</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>//从list中选择一个元素，如果conns列表为空 则跳出检查
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>conns</span>.<span style=color:#a6e22e>Back</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>elem</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>//成功获取到一条TCP连接，进行生命期时间校验
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>conn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>redisConn</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>//如果当前获取的TCP连接是在合法生命周期内部的，立刻退出，但是这个元素还在list中，下次获取仍然能够获取到
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>aliveTime</span>).<span style=color:#a6e22e>After</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>//运行到这里，代表TCP连接生命期超时，删除此元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>conns</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//经过前面的操作，前面目的在于清理超时TCP连接
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>conns</span>.<span style=color:#a6e22e>Len</span>() <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>//没有TCP连接可用，所以需要新建连接，立刻需要释放锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>DialTimeout</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>address</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>connTimeout</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//var writerMemory bytes.Buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		
</span></span><span style=display:flex><span>		<span style=color:#75715e>//创建新的redis连接内存对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>conn</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>redisConn</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span>:            <span style=color:#a6e22e>c</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>br</span>:           <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>c</span>),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>bw</span>:           <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewWriter</span>(<span style=color:#a6e22e>c</span>),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>readTimeout</span>:  <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>readTimeout</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>writeTimeout</span>: <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>writeTimeout</span>,
</span></span><span style=display:flex><span>			<span style=color:#75715e>//writerMemory: &amp;writerMemory,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//设置内存缓冲区
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//conn.bwm = RedSHandle.NewWriterHandle(conn.writerMemory)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//conn.readerParser = RedisFastParser.NewParserHandle(conn.c)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>conn</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//获取到一条已经存在的存活TCP连接，这条TCP的生命周期也在合法时间内，所以：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 1.取出元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 2.删除元素在list中的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 3.立刻解锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>conns</span>.<span style=color:#a6e22e>Back</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>conns</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//重置内存缓冲区
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//elem.Value.(*redisConn).writerMemory.Reset()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>Value</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>redisConn</span>), <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=185-连接池源码分析----放回可用连接进入池>1.8.5 连接池源码分析 - 放回可用连接进入池
<a class=anchor href=#185-%e8%bf%9e%e6%8e%a5%e6%b1%a0%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90----%e6%94%be%e5%9b%9e%e5%8f%af%e7%94%a8%e8%bf%9e%e6%8e%a5%e8%bf%9b%e5%85%a5%e6%b1%a0>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>node</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>redisNode</span>) <span style=color:#a6e22e>releaseConn</span>(<span style=color:#a6e22e>conn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>redisConn</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//需要针对当前的redis-node的tcp连接池进行内存操作，在并发场景下，首先先上锁。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//连接仍然有待处理的回复，只需将其关闭即可，避免可能的TCP粘包连接。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>pending</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>closed</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>shutdown</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//如果连接池的当前长度已经超过池的最高界限，或者node没有开启tcp存活时间选项。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>conns</span>.<span style=color:#a6e22e>Len</span>() <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>keepAlive</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>aliveTime</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>shutdown</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//更新当前conn的时间，并放入LIST数据结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>t</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>conns</span>.<span style=color:#a6e22e>PushFront</span>(<span style=color:#a6e22e>conn</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//重置内存缓冲区
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//conn.writerMemory.Reset()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#181--连接池是什么>1.8.1 连接池是什么</a></li><li><a href=#182--连接池的种类>1.8.2 连接池的种类</a></li><li><a href=#183-tcp连接池初始化方式>1.8.3 TCP连接池初始化方式</a></li><li><a href=#184-连接池源码分析---获取一个可用链接>1.8.4 连接池源码分析 - 获取一个可用链接</a></li><li><a href=#185-连接池源码分析----放回可用连接进入池>1.8.5 连接池源码分析 - 放回可用连接进入池</a></li></ul></li></ul></nav></div></aside></main></body></html>