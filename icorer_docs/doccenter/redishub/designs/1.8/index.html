<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="1.9 Redis集群状态更新 # RedisHub中间件除了要沟通客户端 与 服务端 这两方，还需要及时获取Redis集群的状态信息，并把状态信息转换或更新必要的内存数据结构，内存数据结构最终会被中间件用来承载redis请求。
1.9.1 状态信息来源 # 集群状态信息的来源主要包括：
被动方式：集群内部指令执行周期内的MOVE、ASK信号 主动方式：集群 CLUSTER SLOTS 指令 1.9.2 集群槽位状态信息更新 # 关于集群槽位的信息更新，我们主要包括以下两方面策略：
为了具备更好的性能，我们采用chan 共享内存监听 采用读写锁，提高关键内存共享区的读写安全性及性能 针对更新操作做了秒级限流操作，保障中间件的稳定性。 核心源码分析 如下：
func (cluster *Cluster) handleUpdate() { for { //获取chan列表的更新信号 msg := <-cluster.updateList // TODO: control update frequency by updateTime and movedTime? cluster.rwLock.RLock() clusterLastUpdateTime := cluster.updateTime cluster.rwLock.RUnlock() //如果集群的上一次更新时间 加上窗口值（1s） 小于 此次集群更新指令产生的时间: 证明集群更新频率过高，控制频率。 if clusterLastUpdateTime.Add(1 * time.Second).Before(msg.movedTime) { //针对集群进行状态更新 err := cluster.Update(msg.node) if err != nil { log."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:type" content="website"><meta property="og:image" content="https://res.cloudinary.com/malloc/image/upload/v1666510486/icefiredb/logo_z8koem.png"><meta property="og:title" content="1.9 Redis集群状态更新"><meta property="og:description" content="1.9 Redis集群状态更新 # RedisHub中间件除了要沟通客户端 与 服务端 这两方，还需要及时获取Redis集群的状态信息，并把状态信息转换或更新必要的内存数据结构，内存数据结构最终会被中间件用来承载redis请求。
1.9.1 状态信息来源 # 集群状态信息的来源主要包括：
被动方式：集群内部指令执行周期内的MOVE、ASK信号 主动方式：集群 CLUSTER SLOTS 指令 1.9.2 集群槽位状态信息更新 # 关于集群槽位的信息更新，我们主要包括以下两方面策略：
为了具备更好的性能，我们采用chan 共享内存监听 采用读写锁，提高关键内存共享区的读写安全性及性能 针对更新操作做了秒级限流操作，保障中间件的稳定性。 核心源码分析 如下：
func (cluster *Cluster) handleUpdate() { for { //获取chan列表的更新信号 msg := <-cluster.updateList // TODO: control update frequency by updateTime and movedTime? cluster.rwLock.RLock() clusterLastUpdateTime := cluster.updateTime cluster.rwLock.RUnlock() //如果集群的上一次更新时间 加上窗口值（1s） 小于 此次集群更新指令产生的时间: 证明集群更新频率过高，控制频率。 if clusterLastUpdateTime.Add(1 * time.Second).Before(msg.movedTime) { //针对集群进行状态更新 err := cluster.Update(msg.node) if err != nil { log."><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_docs/doccenter/redishub/designs/1.8/"><meta property="article:section" content="DocCenter"><title>1.9 Redis集群状态更新 | 工匠之芯-文档中心</title><link rel=manifest href=/icorer_docs/manifest.json><link rel=icon href=/icorer_docs/favicon.ico type=image/x-icon><link rel=stylesheet href=/icorer_docs/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css integrity="sha256-RhgbyTN1upMgJudTs3xA5v+LsWqe93DHi8xmPkV3sbo=" crossorigin=anonymous><script defer src=/icorer_docs/flexsearch.min.js></script>
<script defer src=/icorer_docs/en.search.min.b4ceeb102583c24afd86cea861a906fdcb3c2b7d8cca04ff929c199c038d080d.js integrity="sha256-tM7rECWDwkr9hs6oYakG/cs8K32MygT/kpwZnAONCA0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/icorer_docs/><span>工匠之芯-文档中心</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://icorer.com/ target=_blank rel=noopener>工匠之芯</a></li><li><a href=https://github.com/gitsrc target=_blank rel=noopener>Open Source</a></li></ul><ul><li class=book-section-flat><a href=https://icorer.com/icorer_docs/doccenter/>项目总览</a><ul><li><input type=checkbox id=section-aed24396fef473497b12e93db0aa8548 class=toggle checked>
<label for=section-aed24396fef473497b12e93db0aa8548 class="flex justify-between"><a href=https://icorer.com/icorer_docs/doccenter/redishub/>RedisHub</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/>系统设计</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.1/>1.1基础运行框架</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.2/>1.2配置解析器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.3/>1.3通信组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.4/>1.4 协议解析器与拦截器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.5/>1.5 NetHandle组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.6/>1.5 集群 MSET 指令支持</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.7/>1.7 集群 MGET 指令支持</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.8/ class=active>1.9 Redis集群状态更新</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.9/>1.8 TCP连接池</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.10/>1.10 RESP协议解析</a></li></ul></li><li><span>系统模块测试</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/icefiredb-crdt-kv/>icefiredb-crdt-kv</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/icefiredb-ipfs-log/>icefiredb-ipfs-log</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/icefiredb_proxy/>icefiredb-proxy</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/redhub/>redhub-frame</a></li></ul></li><li><span>中间件部署</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/deploy/orbitdb/>OrbitDB</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/deploy/threaddb/>ThreadDB</a></li></ul></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/system_access/>系统接入</a><ul></ul></li></ul></li><li><input type=checkbox id=section-1453ce2c5ecb8c18c2860dade55163de class=toggle>
<label for=section-1453ce2c5ecb8c18c2860dade55163de class="flex justify-between"><a role=button>PulseFlow</a></label><ul><li><input type=checkbox id=section-b349698f86361cb77fa3daf6029bb134 class=toggle>
<label for=section-b349698f86361cb77fa3daf6029bb134 class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/overview/>OverView</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/network/>NetWork</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/storage/>Storage</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/protocol/>Protocol</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/codec/>Codec</a></li></ul></li></ul></li><li><input type=checkbox id=section-14e1ec26ce57d625211daa6855b123ba class=toggle>
<label for=section-14e1ec26ce57d625211daa6855b123ba class="flex justify-between"><a role=button>RedisTun</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/quick_start/>Quick Start</a><ul></ul></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/>Designs</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/network/>Network layer</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/storage/>Storage layer</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/protocol/>Protocol layer</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/codec/>Codec layer</a></li></ul></li><li><span>Develop</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-crdt-kv/>icefiredb-crdt-kv</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-ipfs-log/>icefiredb-ipfs-log</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb_proxy/>icefiredb-proxy</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/redhub/>redhub-frame</a></li></ul></li><li><span>Project Comparison</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/orbitdb/>OrbitDB</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/threaddb/>ThreadDB</a></li></ul></li></ul></li><li><input type=checkbox id=section-404d707d87f9ef4c7b157ec13db25c80 class=toggle>
<label for=section-404d707d87f9ef4c7b157ec13db25c80 class="flex justify-between"><a role=button>LogDarts</a></label><ul><li><input type=checkbox id=section-658ed1b71722eedc365fde2c5579594f class=toggle>
<label for=section-658ed1b71722eedc365fde2c5579594f class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/overview/>OverView</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/network/>NetWork</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/storage/>Storage</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/protocol/>Protocol</a></li></ul></li></ul></li><li><input type=checkbox id=section-a22dab337e8b55a3f7712060bcd10bb9 class=toggle>
<label for=section-a22dab337e8b55a3f7712060bcd10bb9 class="flex justify-between"><a role=button>AK-2019</a></label><ul><li><input type=checkbox id=section-549f710dc768b95bd2287ab37bb3db61 class=toggle>
<label for=section-549f710dc768b95bd2287ab37bb3db61 class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/overview/>OverView</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/network/>NetWork</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/storage/>Storage</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/protocol/>Protocol</a></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/icorer_docs/svg/menu.svg class=book-icon alt=Menu></label>
<strong>1.9 Redis集群状态更新</strong>
<label for=toc-control><img src=/icorer_docs/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#191-状态信息来源>1.9.1 状态信息来源</a></li><li><a href=#192-集群槽位状态信息更新>1.9.2 集群槽位状态信息更新</a></li><li><a href=#192-指令move-ask-信号跟踪>1.9.2 指令MOVE 、ASK 信号跟踪</a></li></ul></nav></aside></header><article class=markdown><h1 id=19-redis集群状态更新>1.9 Redis集群状态更新
<a class=anchor href=#19-redis%e9%9b%86%e7%be%a4%e7%8a%b6%e6%80%81%e6%9b%b4%e6%96%b0>#</a></h1><p>RedisHub中间件除了要沟通客户端 与 服务端 这两方，还需要及时获取Redis集群的状态信息，并把状态信息转换或更新必要的内存数据结构，内存数据结构最终会被中间件用来承载redis请求。</p><h2 id=191-状态信息来源>1.9.1 状态信息来源
<a class=anchor href=#191-%e7%8a%b6%e6%80%81%e4%bf%a1%e6%81%af%e6%9d%a5%e6%ba%90>#</a></h2><p>集群状态信息的来源主要包括：</p><ol><li>被动方式：集群内部指令执行周期内的MOVE、ASK信号</li><li>主动方式：集群 CLUSTER SLOTS 指令</li></ol><h2 id=192-集群槽位状态信息更新>1.9.2 集群槽位状态信息更新
<a class=anchor href=#192-%e9%9b%86%e7%be%a4%e6%a7%bd%e4%bd%8d%e7%8a%b6%e6%80%81%e4%bf%a1%e6%81%af%e6%9b%b4%e6%96%b0>#</a></h2><p>关于集群槽位的信息更新，我们主要包括以下两方面策略：</p><ol><li>为了具备更好的性能，我们采用chan 共享内存监听</li><li>采用读写锁，提高关键内存共享区的读写安全性及性能</li><li>针对更新操作做了秒级限流操作，保障中间件的稳定性。</li></ol><p>核心源码分析 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>cluster</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cluster</span>) <span style=color:#a6e22e>handleUpdate</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//获取chan列表的更新信号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>updateList</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// TODO: control update frequency by updateTime and movedTime?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>rwLock</span>.<span style=color:#a6e22e>RLock</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>clusterLastUpdateTime</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>updateTime</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>rwLock</span>.<span style=color:#a6e22e>RUnlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//如果集群的上一次更新时间 加上窗口值（1s） 小于 此次集群更新指令产生的时间: 证明集群更新频率过高，控制频率。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>clusterLastUpdateTime</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>).<span style=color:#a6e22e>Before</span>(<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>movedTime</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>//针对集群进行状态更新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>node</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;handleUpdate: %v\n&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>KafkaLoger</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;redistun handleUpdate wrong. err: %s&#34;</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=192-指令move-ask-信号跟踪>1.9.2 指令MOVE 、ASK 信号跟踪
<a class=anchor href=#192-%e6%8c%87%e4%bb%a4move-ask-%e4%bf%a1%e5%8f%b7%e8%b7%9f%e8%b8%aa>#</a></h2><p>如果客户端在请求redis集群的过程中、redis集群出现集群槽位重新分配，会对于请求产生MOVE、ASK信号，为了让中间件支持数据的无缝迁移，我们针对MOVE、ASK进行了特殊处理。</p><p>核心源码分析 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#75715e>// 检查回复类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>resp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>checkReply</span>(<span style=color:#a6e22e>reply</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>resp</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>kRespOK</span>, <span style=color:#a6e22e>kRespError</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reply</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>kRespMove</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>//此处在高并发+slots循环多次集中迁移时，会出现数据的多级别MOVE，对于多级别MOVE 要进行到底，一般频率为20万次中出现10次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//所以采用循环进行多级MOVE处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>//尝试第一次MOVE，并对结果进行判断，如果reply类型不再是MOVE类型，则证明摆脱多级MOVE，则把结果返回出去
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>//由于结果可能会发生变化，因此再进行判断
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>reply</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>handleMove</span>(<span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>reply</span>.(<span style=color:#a6e22e>redisError</span>).<span style=color:#a6e22e>Error</span>(), <span style=color:#a6e22e>cmd</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>respType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>checkReply</span>(<span style=color:#a6e22e>reply</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>//如果reply类型不是MOVE类型，则 准备跳出循环、对结果进行判断，选择条件返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>respType</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>kRespMove</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>respType</span>) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>kRespOK</span>, <span style=color:#a6e22e>kRespError</span>:
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reply</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>kRespAsk</span>:
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>handleAsk</span>(<span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>reply</span>.(<span style=color:#a6e22e>redisError</span>).<span style=color:#a6e22e>Error</span>(), <span style=color:#a6e22e>cmd</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>kRespConnTimeout</span>:
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>handleConnTimeout</span>(<span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>cmd</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>kRespClusterDown</span>: <span style=color:#75715e>//如果redis集群宕机，则返回宕机错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#75715e>//选取可用的节点 更新集群状态信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>UpdateSlotsInfoByRandomNode</span>(<span style=color:#a6e22e>node</span>)
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reply</span>, <span style=color:#a6e22e>Cluster_Down_Error</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#75715e>//此处return为了跳出多级MOVE的for循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reply</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>//return cluster.handleMove(node, reply.(redisError).Error(), cmd, args)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>kRespAsk</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>handleAsk</span>(<span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>reply</span>.(<span style=color:#a6e22e>redisError</span>).<span style=color:#a6e22e>Error</span>(), <span style=color:#a6e22e>cmd</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>kRespConnTimeout</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>handleConnTimeout</span>(<span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>cmd</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>kRespClusterDown</span>: <span style=color:#75715e>//如果redis集群宕机，则返回宕机错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//选取可用的节点 更新集群状态信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>UpdateSlotsInfoByRandomNode</span>(<span style=color:#a6e22e>node</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reply</span>, <span style=color:#a6e22e>Cluster_Down_Error</span>
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#191-状态信息来源>1.9.1 状态信息来源</a></li><li><a href=#192-集群槽位状态信息更新>1.9.2 集群槽位状态信息更新</a></li><li><a href=#192-指令move-ask-信号跟踪>1.9.2 指令MOVE 、ASK 信号跟踪</a></li></ul></nav></div></aside></main></body></html>