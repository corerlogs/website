<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>风险分析 on 工匠之芯-文档中心</title><link>https://icorer.com/icorer_docs/doccenter/logdarts/designs/</link><description>Recent content in 风险分析 on 工匠之芯-文档中心</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://icorer.com/icorer_docs/doccenter/logdarts/designs/index.xml" rel="self" type="application/rss+xml"/><item><title>OverView</title><link>https://icorer.com/icorer_docs/doccenter/logdarts/designs/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/logdarts/designs/overview/</guid><description> OverView #</description></item><item><title>1.1 数据结构分析</title><link>https://icorer.com/icorer_docs/doccenter/logdarts/designs/1.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/logdarts/designs/1.1/</guid><description>二. 数据结构分析 # 2.1 数据结构构造（已审查） # 组件数据结构采用数组进行存储，数组的数据结构如下图：
数组结构的各部分阐述如下：
TOTAL_COUNT：记录的总数量
TOTAL_SIZE ： 数据包的总大小，通过这个参数可以控制每次UDP数据包的大小临界值。
每一个数据元包括：log_str、log_struct、log_length这三部分。
log_str：这个元素是一个数组，每个元素就是一个完整的日志字符串。
log_struct：这个元素是一个数组，每个数组元素是个三元组，是构造log_str的源数据。
log_length：这个元素是一个数组，每个元素都是一个数值型数据，代表当前id对应的字符串的长度。
2.2 数据结构操作：(添加、删除）(已审查) # 2.2.1 添加操作 （已审查） # 当调用set和count函数添加数据时，组件会同时添加log_str、log_struct、log_length三个元素，由于这三个元素添加时数组ID均相同，所以三个元素在结构上是可以通过id进行统一索引的，类似的模型代码如下。
$log_size = strlen($log); self::$gauae_metrics_logs[&amp;#39;LOGS_DATA&amp;#39;][&amp;#39;log_str&amp;#39;][] = $log; self::$gauae_metrics_logs[&amp;#39;LOGS_DATA&amp;#39;][&amp;#39;log_struct&amp;#39;][] = $logPacker; self::$gauae_metrics_logs[&amp;#39;LOGS_DATA&amp;#39;][&amp;#39;log_length&amp;#39;][] = $log_size; self::$gauae_metrics_logs[&amp;#39;TOTAL_COUNT&amp;#39;]++; self::$gauae_metrics_logs[&amp;#39;TOTAL_SIZE&amp;#39;] += $log_size; TOTAL_COUNT在添加的时候会进行递增，TOTAL_SIZE会在添加的时候自动把当前的数据包长度进行添加。
2.2.1 删除操作 （已审查） # 当调用send_count_metrics_log、send_gauae_metrics_log函数发送发送数据是，组件会同时删除log_str、log_struct、log_length三个元素，并同时调整TOTAL_COUNT、TOTAL_SIZE数值。
foreach (self::$gauae_metrics_logs[&amp;#39;LOGS_DATA&amp;#39;][&amp;#39;log_str&amp;#39;] as $key =&amp;gt; $val) { $udpPakData .= $val; //发送前组装最终字符串 $log_size = self::$gauae_metrics_logs[&amp;#39;LOGS_DATA&amp;#39;][&amp;#39;log_length&amp;#39;][$key]; //获取当前位置的长度 unset(self::$gauae_metrics_logs[&amp;#39;LOGS_DATA&amp;#39;][&amp;#39;log_str&amp;#39;][$key]); unset(self::$gauae_metrics_logs[&amp;#39;LOGS_DATA&amp;#39;][&amp;#39;log_length&amp;#39;][$key]); unset(self::$gauae_metrics_logs[&amp;#39;LOGS_DATA&amp;#39;][&amp;#39;log_struct&amp;#39;][$key]); self::$gauae_metrics_logs[&amp;#39;TOTAL_COUNT&amp;#39;]--; self::$gauae_metrics_logs[&amp;#39;TOTAL_SIZE&amp;#39;] -= $log_size; } self::sendUdpPackage(self::$IP, self::$PORT, $udpPakData); //发送UDP TOTAL_COUNT在删除的时候会进行递减，TOTAL_SIZE会在删除的时候自动把当前的数据包长度进行缩减。</description></item><item><title>1.2 代码流程分析</title><link>https://icorer.com/icorer_docs/doccenter/logdarts/designs/1.2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/logdarts/designs/1.2/</guid><description>三. 代码流程分析 # 组件模块从代码执行流程上来看，主要包括：
对象实例化
数据包组装
保存数据结构
发送数据包
3.1 对象实例化（已审查） # 组件采用单对象实例设计，主要的判断逻辑如下：
相关模型代码如下：
public static function getLoger() { if (!isset(self::$Loger)) { self::$Loger = new self(); } return self::$Loger; } 3.2 数据包组装（构造 $logPacker）（已审查） # 这里的数据包组装并不是直接组装成最终的字符串，而是组装为数据结构体，结构包括metrics_name、typeInfo、指标量这三部分，相关模型代码如下：
public static function encode_count_metrics($metrics_name,$serviceName,$labelType=[],$siteName,$countNum=1,$biz_parameter=&amp;#39;&amp;#39;){ $ret = array(); $ret[]=$metrics_name; $part2 = &amp;#39;type=&amp;#39;.implode(&amp;#39;.&amp;#39;,$labelType).&amp;#39;&amp;amp;service=&amp;#39;.$serviceName.&amp;#39;&amp;amp;site=&amp;#39;.$siteName; if (!empty($biz_parameter)){ $part2.=&amp;#39;&amp;amp;biz_parameter=&amp;#39;.$biz_parameter; } $ret[]=$part2; $ret[]=$countNum; return $ret; } 3.3 保存数据结构 （消费 $logPacker）（已审查） # 这个是关键的一步，它的作用在于把数据包结构数据进行再一次结构化，变为真正可用的全局数据结构，总体结构如下图：
相关代码模型如下：
private function save_count_metrics_log($logPacker) { $log = implode(&amp;#39;|&amp;#39;, $logPacker) .</description></item><item><title>1.3 异常监控分析</title><link>https://icorer.com/icorer_docs/doccenter/logdarts/designs/1.3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_docs/doccenter/logdarts/designs/1.3/</guid><description>组件也包含异常监控部分，但是为了减少对于业务代码的影响，在异常监控部分进行了改造：
组件内部通过异常机制进行错误跟踪。 组件和外部调用之间通过错误码进行状态反馈。 组件内部的异常产生主要集中于 初始化配置 和 UDP发送两大部分，目前对这两部分进行了调整。
4.1初始化配置 （已审查） # 初始化配置主要作用是分析配置文件，根据配置文件内容初始化相关的环境参数，配置过程在一个PHP生命期内只会进行一次，这部分代码已经调整为错误码返回，相关的模型代码样例如下：
if (!is_array(self::$EXCEPTION_LIST) || empty(self::$EXCEPTION_LIST[&amp;#39;CLIENT_CONFIG&amp;#39;])) { // throw new \Exception(&amp;#39;Exception List File is Lose&amp;#39;, 1000); //原来采用抛出异常 return FILE_NOT_FOUND_ERR; //现在采用返回错误码 } else { self::$CLIENT_EXCEPTION_LIST = self::$EXCEPTION_LIST[&amp;#39;CLIENT_CONFIG&amp;#39;]; } 这种调整可以有效降低组件代码和业务系统的耦合性。
4.2 UDP发送（已审查） # UDP发送函数内部仍然采用异常机制进行上报异常，但是在组件内部调用UDP发送函数时，如果抓取到异常，会向外层反馈异常错误码，而不是继续抛出异常。
#总结 以上两个部分的代码逻辑已经完全审核。</description></item></channel></rss>