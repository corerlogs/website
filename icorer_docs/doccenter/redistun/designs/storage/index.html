<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Storage layer design # The storage layer is responsible for data storage, and the data storage here includes different storage media of web2 and web3. For web2, the storage media we face includes disk, OSS, and for web3, the storage media we face includes IPFS, blockchain, and smart contracts.Currently, the storage types supported by IceFireDB mainly include the following.
Engine type describe Driver directory LevelDB LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:type" content="website"><meta property="og:image" content="https://res.cloudinary.com/malloc/image/upload/v1666510486/icefiredb/logo_z8koem.png"><meta property="og:title" content="Storage layer"><meta property="og:description" content="Storage layer design # The storage layer is responsible for data storage, and the data storage here includes different storage media of web2 and web3. For web2, the storage media we face includes disk, OSS, and for web3, the storage media we face includes IPFS, blockchain, and smart contracts.Currently, the storage types supported by IceFireDB mainly include the following.
Engine type describe Driver directory LevelDB LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values."><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_docs/doccenter/redistun/designs/storage/"><meta property="article:section" content="DocCenter"><title>Storage layer | 工匠之芯-文档中心</title><link rel=manifest href=/icorer_docs/manifest.json><link rel=icon href=/icorer_docs/favicon.ico type=image/x-icon><link rel=stylesheet href=/icorer_docs/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css integrity="sha256-RhgbyTN1upMgJudTs3xA5v+LsWqe93DHi8xmPkV3sbo=" crossorigin=anonymous><script defer src=/icorer_docs/flexsearch.min.js></script>
<script defer src=/icorer_docs/en.search.min.d96be161117e105e2baa9f99837584c6fb294755df57559aab605279890791d6.js integrity="sha256-2WvhYRF+EF4rqp+Zg3WExvspR1XfV1Waq2BSeYkHkdY=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/icorer_docs/><span>工匠之芯-文档中心</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://icorer.com/ target=_blank rel=noopener>工匠之芯</a></li><li><a href=https://github.com/gitsrc target=_blank rel=noopener>Open Source</a></li></ul><ul><li class=book-section-flat><a href=https://icorer.com/icorer_docs/doccenter/>项目总览</a><ul><li><input type=checkbox id=section-aed24396fef473497b12e93db0aa8548 class=toggle>
<label for=section-aed24396fef473497b12e93db0aa8548 class="flex justify-between"><a href=https://icorer.com/icorer_docs/doccenter/redishub/>RedisHub</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/>系统设计</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.1/>1.1基础运行框架</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.2/>1.2配置解析器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.3/>1.3通信组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.4/>1.4 协议解析器与拦截器</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.5/>1.5 NetHandle组件</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.6/>1.5 集群 MSET 指令支持</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.7/>1.7 集群 MGET 指令支持</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.8/>1.9 Redis集群状态更新</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.9/>1.8 TCP连接池</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/designs/1.10/>1.10 RESP协议解析</a></li></ul></li><li><span>系统模块测试</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/2.1/>2.1 NetHandle组件测试</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/module_test/2.2/>2.2 中间件完整测试</a></li></ul></li><li><span>中间件部署</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/deploy/3.1/>3.1 部署文档</a></li></ul></li><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/system_access/>系统接入</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redishub/system_access/4.1/>4.1 phpredis对接redishub</a></li></ul></li></ul></li><li><input type=checkbox id=section-1453ce2c5ecb8c18c2860dade55163de class=toggle>
<label for=section-1453ce2c5ecb8c18c2860dade55163de class="flex justify-between"><a role=button>PulseFlow</a></label><ul><li><input type=checkbox id=section-b349698f86361cb77fa3daf6029bb134 class=toggle>
<label for=section-b349698f86361cb77fa3daf6029bb134 class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/overview/>OverView</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/network/>NetWork</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/storage/>Storage</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/protocol/>Protocol</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/pulseflow/architecture/codec/>Codec</a></li></ul></li></ul></li><li><input type=checkbox id=section-14e1ec26ce57d625211daa6855b123ba class=toggle checked>
<label for=section-14e1ec26ce57d625211daa6855b123ba class="flex justify-between"><a role=button>RedisTun</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/quick_start/>Quick Start</a><ul></ul></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/>Designs</a><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/network/>Network layer</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/storage/ class=active>Storage layer</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/protocol/>Protocol layer</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/designs/codec/>Codec layer</a></li></ul></li><li><span>Develop</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-crdt-kv/>icefiredb-crdt-kv</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb-ipfs-log/>icefiredb-ipfs-log</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/icefiredb_proxy/>icefiredb-proxy</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/develop/redhub/>redhub-frame</a></li></ul></li><li><span>Project Comparison</span><ul><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/orbitdb/>OrbitDB</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/redistun/project-comparison/threaddb/>ThreadDB</a></li></ul></li></ul></li><li><input type=checkbox id=section-404d707d87f9ef4c7b157ec13db25c80 class=toggle>
<label for=section-404d707d87f9ef4c7b157ec13db25c80 class="flex justify-between"><a role=button>LogDarts</a></label><ul><li><input type=checkbox id=section-658ed1b71722eedc365fde2c5579594f class=toggle>
<label for=section-658ed1b71722eedc365fde2c5579594f class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/overview/>OverView</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/network/>NetWork</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/storage/>Storage</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/logdarts/architecture/protocol/>Protocol</a></li></ul></li></ul></li><li><input type=checkbox id=section-a22dab337e8b55a3f7712060bcd10bb9 class=toggle>
<label for=section-a22dab337e8b55a3f7712060bcd10bb9 class="flex justify-between"><a role=button>AK-2019</a></label><ul><li><input type=checkbox id=section-549f710dc768b95bd2287ab37bb3db61 class=toggle>
<label for=section-549f710dc768b95bd2287ab37bb3db61 class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/overview/>OverView</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/network/>NetWork</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/storage/>Storage</a></li><li><a href=https://icorer.com/icorer_docs/doccenter/ak-2019/architecture/protocol/>Protocol</a></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/icorer_docs/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Storage layer</strong>
<label for=toc-control><img src=/icorer_docs/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#storage-model>Storage model</a></li><li><a href=#nosql-storage-engine>NoSQL storage engine</a><ul><li><a href=#instruction-broadcast-model><strong>Instruction broadcast model</strong></a></li><li><a href=#full-storage-model><strong>Full storage model</strong></a></li></ul></li><li><a href=#icegiant-synchronizer>IceGiant Synchronizer</a></li></ul></nav></aside></header><article class=markdown><h1 id=storage-layer-design>Storage layer design
<a class=anchor href=#storage-layer-design>#</a></h1><p>The storage layer is responsible for data storage, and the data storage here includes different storage media of web2 and web3. For web2, the storage media we face includes disk, OSS, and for web3, the storage media we face includes IPFS, blockchain, and smart contracts.Currently, the storage types supported by IceFireDB mainly include the following.</p><table><thead><tr><th>Engine type</th><th>describe</th><th>Driver directory</th></tr></thead><tbody><tr><td>LevelDB</td><td>LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.</td><td>Default</td></tr><tr><td>Badger</td><td>BadgerDB is an embeddable, persistent and fast key-value (KV) database written in pure Go.</td><td><a href=https://github.com/IceFireDB/IceFireDB/tree/main/driver/badger>Badger</a></td></tr><tr><td>OSS</td><td>Object storage is a technology that stores and manages data in an unstructured format called objects.</td><td><a href=https://github.com/IceFireDB/IceFireDB/tree/main/driver/oss>OSS</a></td></tr><tr><td>IPFS</td><td>IPFS (the InterPlanetary File System) is a hypermedia distribution protocol addressed by content and identities. It enables the creation of completely distributed applications, and in doing so aims to make the web faster, safer, and more open.</td><td><a href=https://github.com/IceFireDB/IceFireDB/tree/main/driver/ipfs>IPFS</a></td></tr><tr><td>CRDT-KV</td><td>The IceFireDB-CRDT-KV engine can support decentralized P2P networking, data synchronization and consistency between nodes. It is a component of the IceFireDB software ecosystem, thanks to the open source of IPFS.</td><td><a href=https://github.com/IceFireDB/IceFireDB/tree/main/driver/crdt>CRDT-KV</a></td></tr><tr><td>IPFS-LOG</td><td>icefiredb-ipfs-log is a distributed immutable, operation-based conflict-free replication data structure that relies on ipfs to store data and merges each peer node data based on pubsub conflict-free. You can easily implement custom data structures such as kv, event, nosql, etc. based on icefiredb-ipfs-log.</td><td><a href=https://github.com/IceFireDB/IceFireDB/tree/main/driver/ipfs-log>IPFS-LOG</a></td></tr><tr><td>OrbitDB</td><td>OrbitDB is a serverless, distributed, peer-to-peer database. OrbitDB uses IPFS as its data storage and IPFS Pubsub to automatically sync databases with peers.</td><td><a href=https://github.com/IceFireDB/IceFireDB/tree/main/driver/orbitdb>OrbitDB</a></td></tr></tbody></table><h2 id=storage-model>Storage model
<a class=anchor href=#storage-model>#</a></h2><p>The NoSQL storage layer of each individual IceGiant mainly includes the codec layer and the underlying KV storage layer. the underlying KV engine currently supports levelDB, badgerDB, IPFS and OSS, and the main data storage includes two ways:</p><ol><li><p>instruction broadcast model based on IPFS-LOG\CRDT_KV\OrbitDB</p></li><li><p>Native data storage model based on LevelDB\Badger\OSS\IPFS</p></li></ol><p>Multiple IceFireDB nodes will be divided into groups according to data sets, and each group will form a highly available storage area structure.</p><h2 id=nosql-storage-engine>NoSQL storage engine
<a class=anchor href=#nosql-storage-engine>#</a></h2><p>The core of each node is the database engine. By default, IceGiant node integrates KV storage engines such as levelDB, badgerDB, IPFS, OSS, etc., and implements the protocol coding layer of NoSQL on the KV storage relationship. Currently, the data storage of NoSQL mainly includes the following two ways:</p><h3 id=instruction-broadcast-model><strong>Instruction broadcast model</strong>
<a class=anchor href=#instruction-broadcast-model>#</a></h3><p>Based on ipfs-log,crdt and libp2p(pubsub), an immutable and operation-based conflict-free replication data model for distributed systems is implemented. Based on ipfs-log, various data structures such as event and kv are encapsulated, and multi-node database instruction broadcast is implemented based on this engine;At that bottom of IceFireDB, we abstract the variable kv engine base on badgerdb and leveldb. any node will broadcast the whole network when it is writing instruction, and the bottom driver of IceFireDB of each node will execute the broadcast instruction to ensure the final consistency of data.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>           Log A                Log B
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>     logA.append(&#34;one&#34;)   logB.append(&#34;hello&#34;)
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>             v                    v
</span></span><span style=display:flex><span>          +-----+             +-------+
</span></span><span style=display:flex><span>          |&#34;one&#34;|             |&#34;hello&#34;|
</span></span><span style=display:flex><span>          +-----+             +-------+
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>     logA.append(&#34;two&#34;)   logB.append(&#34;world&#34;)
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>             v                    v
</span></span><span style=display:flex><span>       +-----------+       +---------------+
</span></span><span style=display:flex><span>       |&#34;one&#34;,&#34;two&#34;|       |&#34;hello&#34;,&#34;world&#34;|
</span></span><span style=display:flex><span>       +-----------+       +---------------+
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>       logA.join(logB) &lt;----------+
</span></span><span style=display:flex><span>             |
</span></span><span style=display:flex><span>             v
</span></span><span style=display:flex><span>+---------------------------+
</span></span><span style=display:flex><span>|&#34;one&#34;,&#34;hello&#34;,&#34;two&#34;,&#34;world&#34;|
</span></span><span style=display:flex><span>+---------------------------+
</span></span></code></pre></div><h3 id=full-storage-model><strong>Full storage model</strong>
<a class=anchor href=#full-storage-model>#</a></h3><p>In addition to the first implementation mode, we are also building the structure of the second type of data, so that the complete data will grow on ipfs. At first, there is an ipfs driver in the IceFireDB driver layer, which will encode and process the upper-level commands into a unified kv data structure, store and change the value, and the generated new cid will be connected with key. However, at present, there is no key broadcast network with multiple nodes and data synchronization. When we connect with the broadcast network, we can build a data model originally grown on LevelDB\Badger\OSS\IPFS.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>+-------------------------------------------------------------+
</span></span><span style=display:flex><span>|                            Codec                            |
</span></span><span style=display:flex><span>|    +-----------+                           +-----------+    |
</span></span><span style=display:flex><span>|    |   Encode  |                           |   Decode  |    |
</span></span><span style=display:flex><span>|    +-----------+                           +-----------+    |
</span></span><span style=display:flex><span>|                 support: kv、list、hash、set                 |
</span></span><span style=display:flex><span>+----------+---------------------------------------^----------+
</span></span><span style=display:flex><span>           |                                       |
</span></span><span style=display:flex><span>+----------+---------------------------------------+----------+
</span></span><span style=display:flex><span>|          |put              KV Engine             |Get       |
</span></span><span style=display:flex><span>|    +-----v----+                            +-----+----+     |
</span></span><span style=display:flex><span>|    | put(a,b) |                            |  Get(a)  |     |
</span></span><span style=display:flex><span>|    +-----+----+                            +-----+----+     |
</span></span><span style=display:flex><span>|          | a:b            +-------+              | a        |
</span></span><span style=display:flex><span>|    +-----v----+    +------&gt; store &lt;----+   +-----v----+     |
</span></span><span style=display:flex><span>|    |  CID(b)  +----+      +-------+    +---+ cat(hash)|     |
</span></span><span style=display:flex><span>|    +-----+----+                            +-----+----+     |
</span></span><span style=display:flex><span>|          | add(b)                                | cat      |
</span></span><span style=display:flex><span>|  --------v---------------------------------------v-----     |
</span></span><span style=display:flex><span>|           Leveldb\Badger\OSS\IPFS\CRDT\IPFS-LOG             |
</span></span><span style=display:flex><span>+-------------------------------------------------------------+
</span></span></code></pre></div><h2 id=icegiant-synchronizer>IceGiant Synchronizer
<a class=anchor href=#icegiant-synchronizer>#</a></h2><p>The storage layer of IceFireDB not only includes a complete storage server, but IceGiant Synchronizer, which is currently under construction, also belongs to the ecological software layer of the storage layer.</p><p>IceGiant Synchronizer is an application directly above the database engine. All incoming database requests pass through IceGiant Synchronizer, which determines whether the requests should be processed, whether data writes should be propagated to other parts of the network, and whether local data should be written and customer requests should be responded to.</p><p>IceGiant Synchronizer can also provide data write aggregation function, allowing multiple data requests to be merged and written into a single network storage request. It also allows users to cross-mix data sets between different nodes, encouraging further data decentralization, while keeping the operation overhead low.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#storage-model>Storage model</a></li><li><a href=#nosql-storage-engine>NoSQL storage engine</a><ul><li><a href=#instruction-broadcast-model><strong>Instruction broadcast model</strong></a></li><li><a href=#full-storage-model><strong>Full storage model</strong></a></li></ul></li><li><a href=#icegiant-synchronizer>IceGiant Synchronizer</a></li></ul></nav></div></aside></main></body></html>