<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>内核源码 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/en/tags/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/</link><description>Recent content in 内核源码 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 08 Mar 2020 11:45:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/en/tags/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux内核-内存管理: Out Of Memory Management 源码分析</title><link>https://icorer.com/icorer_blog/en/posts/linux-kernel-memory-management-out-of-memory-management-source-code-analysis/</link><pubDate>Sun, 08 Mar 2020 11:45:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/linux-kernel-memory-management-out-of-memory-management-source-code-analysis/</guid><description>我们这篇文章中描述了Linux内核对于 Out Of Memory Management 场景下的相关策略，接下来我们将进行Linux 5.0内核的OOM内核源码分析。
一. 关键数据结构针对源码部分，我们首先需要阐述oom_kill部分的核心数据结构。
文件路径：/linux/include/linux/oom.h
1.1 oom_control 结构体首先，我们给出具体的内核定义：
1/* 2 * Details of the page allocation that triggered the oom killer that are used to 3 * determine what should be killed. 4 */ 5struct oom_control { 6 /* Used to determine cpuset */ 7 struct zonelist *zonelist; 8 9 /* Used to determine mempolicy */ 10 nodemask_t *nodemask; 11 12 /* Memory cgroup in which oom is invoked, or NULL for global oom */ 13 struct mem_cgroup *memcg; 14 15 /* Used to determine cpuset and node locality requirement */ 16 const gfp_t gfp_mask; 17 18 /* 19 * order == -1 means the oom kill is required by sysrq, otherwise only 20 * for display purposes.</description></item><item><title>Linux内核-内存管理: Out Of Memory Management - OOM</title><link>https://icorer.com/icorer_blog/en/posts/linux-kernel-memory-management-out-of-memory-management-oom/</link><pubDate>Sat, 07 Mar 2020 11:49:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/linux-kernel-memory-management-out-of-memory-management-oom/</guid><description>一. 引言这篇文章，我们将要讨论的是内存不足(OOM)管理器，OOM检查是否有足够的可用内存来满足系统运行需求，如果没有足够的可用内存则进行进程kill操作。这是Linux内核虚拟内存模块中一个有争议的部分，有人建议在很多情况下删除它。所以在使用OOM的时候，首先需要确认OOM是否在待操作的Linux内核中存在，还需要确定OOM在Linux内核中的开启与关闭选项。
二. 检查可用内存（Checking Available Memory）对于某些操作，例如使用brk()扩展堆或使用mremap()重新映射地址空间，系统将检查是否有足够的可用内存来满足请求。请注意，这与当前文章后面介绍的out_of_memory()是不同部分，Linux内核的内存分配机制和内存可用度检查用于尽可能避免系统处于OOM状态。
检查可用内存时，所需的页数作为参数传递给vm_enough_memory()。除非系统管理员指定系统应超量使用内存，否则将检查可用内存的装载。为了确定有多少页面是可用的，Linux总结了以下数据位：
Total page cache (总页面缓存)：页面缓存很容易回收。 Total free pages (总空闲页面)：总可用页面，它们已经可用。 Total free swap pages(总自由交换页) ：用户空间页面可能会被换出。 Total pages managed by swapper_space(由swapper_space管理的总页面)： 尽管这将重复计算空闲交换页面。这是平衡某些情况，此选项有时保留但不使用。 Total pages used by the dentry cache(dentry缓存使用的总页面)： 这部分内存很容易被回收，主要用于vfs Total pages used by the inode cache (inode缓存使用的总页面)： 这部分内存很容易被回收，主要用于vfs-inode索引 如果在此处添加的页面总数足以满足请求，则vm_enough_memory() 将true返回给调用方。 如果返回false，则调用者知道该内存不可用，通常决定将-ENOMEM返回给用户空间。
三. 确定OOM状态（Determining OOM Status）当机器内存不足时，将回收旧的页面框架，但是尽管回收了页面，但仍可能发现即使以最高优先级进行扫描，也无法释放足够的页面来满足请求。如果无法释放页帧，则会调用out_of_memory() 以查看系统是否内存不足，是否需要终止进程。 不幸的是，系统可能没有内存不足，只需要等待IO完成或页面交换到外部存储。不幸的是，这不是因为系统具有内存，而是因为这个函数被不必要地调用，导致不必要地关闭进程。在决定终止一个进程之前，它要经过以下检查表。
是否还有足够的交换空间(nr_swap_pages&amp;gt; 0) ？如果是，则不进行OOM 从上次失败到现在已经超过5秒了吗?如果是，则不进行OOM 我们在最后一秒失败了吗?如果没有，则不进行OOM 如果在过去5秒内没有10次失败，就不进行OOM 最近5秒钟内进程是否被杀死？ 如果是，则不进行OOM 四. 选择一个进程（Selecting a Process）函数select_bad_process()负责选择要终止的进程。它通过逐步执行每个正在运行的任务并计算使用badness()函数杀死它的适合程度来做出决定。坏度的计算方法如下，请注意，平方根是使用int_sqrt()计算的整数近似值。
1badness_for_task = total_vm_for_task / (sqrt(cpu_time_in_seconds) * 2sqrt(sqrt(cpu_time_in_minutes))) 这个公式是为了选择一个使用大量内存但寿命不是很长的进程。已经运行了很长时间的进程不太可能是导致内存不足的原因，因此这个计算可能会选择一个使用了大量内存但没有运行很长时间的进程。如果该进程是根进程或具有CAP_SYS_ADMIN功能，则将坏度值除以4，因为假定根特权进程表现良好。类似地，如果它具有CAP_SYS_RAWIO功能(访问原始设备)特权，则坏度值进一步除以4，因为不希望杀死一个直接访问硬件的进程。</description></item></channel></rss>