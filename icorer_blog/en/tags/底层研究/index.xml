<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>底层研究 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/en/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/</link><description>Recent content in 底层研究 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 12 Jul 2023 21:25:16 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/en/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>Cosmos meet CometBFT</title><link>https://icorer.com/icorer_blog/en/posts/cosmos/cosmos-meet-cometbft/</link><pubDate>Wed, 12 Jul 2023 21:25:16 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/cosmos/cosmos-meet-cometbft/</guid><description>Why Now? What’s Next? CometBFT 的目标是什么？ CometBFT 背后是谁？ 接下来的步骤是什么？ Common Questions CometBFT底层的共识算法是什么？ CometBFT 会放弃 Tendermint 共识算法吗？ Tendermint Core 是否会有多个竞争分叉为跨链提供动力？ 这会导致任何链分叉吗？ 如果我在基于 Tendermint Core 的网络上进行验证，我的操作是否存在任何问题？ tendermint-rs会发生什么？ tm-db 或 tm-load-test 会发生什么情况？ CometBFT，这是一个适用于链间及其他领域的状态机复制引擎！ CometBFT 是 Tendermint Core 的分叉和继承者，并将作为支持 Interchain Stack 的官方复制引擎。 CometBFT 的长期愿景是成为可靠、安全、大规模、特定应用区块链复制引擎的首选。
Interchain 基金会、Informal Systems、Cosmos SDK 团队以及 Cosmos 生态系统中的众多其他团队一直在共同努力。这篇文章解决了围绕此次发布的一些最重要的问题。请放心，我们一直在努力让升级或采用 CometBFT 尽可能顺利。我们将介绍背景详细信息、CometBFT 愿景和目标、这项工作背后的团队以及技术影响方面的后续步骤。
Why Now?我们决定以这个新名称开发旗舰 Cosmos 共识引擎，以标志着席卷整个生态系统的多项重要变化。
在技术方面，跨链在过去几年中取得了显着的发展。我们生活在一个 IBC 原生的多链世界。 ABCI 2.0 是 Interchain Stack 中缺失的关键部分，设计或质量保证方面（例如模块化、集成或严格测试）也是如此。此外，放弃 Tendermint Core v0.35 和 v0.36 版本暴露了开发方式的技术限制；请参阅此处了解更多详细信息。</description></item><item><title>Tendermint ABCI分布式KV存储引擎分析</title><link>https://icorer.com/icorer_blog/en/posts/web3/tendermint-distributed-kv-storage-engine-analysis/</link><pubDate>Tue, 23 May 2023 21:25:16 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/web3/tendermint-distributed-kv-storage-engine-analysis/</guid><description>背景介绍 1.Tendermint KV 模块分析 1.1 ABCI应用拦截Tendermint状态机 1.2 ABCI应用Application结构体分析 1.3 ABCI应用处理Tendermint 区块Deliver事务 1.4 ABCI应用处理Tendermint 区块Commit事务 1.5 ABCI应用处理Tendermint 区块Query事务 1.6 ABCI应用处理Tendermint 区块Check事务 1.7 KV存储引擎状态处理 2.Tendermint KV运行实践 2.1 安装Tendermint 2.1.1 二进制安装 2.1.3 源代码安装 2.1.3 运行Tendermint 2.1.4 重新安装 2.2 Tendermint KV编译及运行 2.3 Tendermint KV 运行测试 2.3.1 Tendermint Core RPC 交易广播 2.3.2 Tendermint Core RPC 查询广播 3.总结 附录 背景介绍Tendermint 是一个基于共识算法的分布式系统，它提供了一种在去中心化环境下实现可靠、安全、高效的数据存储和交互的方法。在这个环境中，一个分布式 KV 存储引擎是非常有用的，它可以让不同的节点在共享一个数据集合的同时保持数据的一致性和可靠性。
Tendermint 为分布式 KV 存储引擎提供了一些核心组件，其中最重要的是 ABCI（Application Blockchain Interface）接口和 KV 存储引擎。ABCI 接口定义了应用程序和 Tendermint Core 之间的交互协议，它规定了应用程序需要实现哪些方法以处理交易、查询和状态更改。Tendermint开源的 ts-db存储引擎则提供了一个标准的键值存储接口，可以将数据持久化到磁盘中，同时支持可插拔的存储引擎（例如 LevelDB、RocksDB 等）。</description></item><item><title>EIP-4844改进提议：分片Blob事务</title><link>https://icorer.com/icorer_blog/en/posts/web3/eip-4844-reduced-l2-fees/</link><pubDate>Mon, 27 Feb 2023 23:35:16 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/web3/eip-4844-reduced-l2-fees/</guid><description>EIP-4844 分片Blob事务以简单、向前兼容的方式扩展以太坊的数据可用性。
一、摘要 二、动机 三、Specification 规范 3.1 Parameters 参数 3.2 Type aliases 类型别名 3.3 Cryptographic Helpers 加密助手 3.4 Helpers 3.5 New transaction type 新的交易类型 3.6 Header extension 头扩展 3.7 Beacon chain validation 信标链验证 3.8 Opcode to get versioned hashes 获取版本哈希的操作码 3.9 Point evaluation precompile 点评估预编译 3.10 Gas accounting 3.11 Networking 网络 四、基本原理 4.1 On the path to sharding 在分片的路上 4.2 How rollups would function 4.3 Versioned hashes &amp;amp; precompile return data 版本化哈希和预编译返回数据 4.</description></item><item><title>SBT vs SSI：Web3对数字身份解决方案的探索</title><link>https://icorer.com/icorer_blog/en/posts/web3/soulbound-tokens-vs-self-sovereign-identity/</link><pubDate>Wed, 14 Dec 2022 11:55:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/web3/soulbound-tokens-vs-self-sovereign-identity/</guid><description>在题为“去中心化社会:寻找Web 3的灵魂”的研究论文中，以太坊(ETH)的联合创始人Vitalik Buterin 与 Glen Weyl、Puja Ahluwalia Ohlhaver 一起，介绍了“灵魂绑定令牌”(SBTs)的概念，作为对数字身份的一种全新看法。这篇文章谈到了数字身份在Web3中的重要性，以及满足Web3的高度金融化，建立同等数量的信任和社会关系的重要性。
然而，我们不禁注意到SBTs的用例与自我主权身份(SSI)所做的是多么接近。SSI已经在为创造一个可信的社会铺平道路。我们想比较Vitalik等人的灵魂绑定令牌假说和SSI，看看当我们进入Web3时，哪一个最有效。
在其最简单的形式中，灵魂绑定令牌是可以在数字钱包中显示的不可转移的可替换令牌。这些代币是由一个灵魂(个体)发给另一个灵魂的。他们不能和任何人交易。一旦获得一个SBT，它就被绑定到那个人身上，因此得名soulbound。
SSI使用数据发布者、验证者和持有者之间的关系来创建一个以用户为中心的模型。在这种模式下，持有者可以选择与验证者共享他们需要的确切信息(而不是更多)。然后，验证者可以将信息与发行者的签名(有时存储在区块链上)进行交叉引用，以确保持有人的数据是有效的。
SBT的吸引力在于它们的不可转让性，它们与接受者绑定在一起。它们可以用于代表其所有者声明凭证和形成在线身份。类似于一组徽章，您可以有多个SBT用于各种凭证，从驾驶执照到代表音乐会门票的令牌。
另一方面，SSI 的不同之处在于它们的默认可见性是私有的和账本外的，而 SBT 默认是公开的和账本上的。SSI侧重于允许用户控制他们的数据，并将发布的文档保存在私人数字钱包中，默认的隐私模式让持有者对他们的个人数据以及如何访问这些数据有更多的控制权。
SBT vs NFT vs SSI 作为一种身份解决方案，SBT 的功能类似于不可替代令牌 ( NFT )。关键区别在于它们缺乏可转移性。SBT 现在正在建设中，但面临一个关键障碍：隐私。
SBT 是 Web3 中表达自我的一种方式，类似于加密货币和 NFT 的所有权。然而，他们可以将现代面临的许多当前身份问题复制到一个新的公共和不可变平台上，这是 SBT 的主要缺点。
围绕SBTs的建立存在紧张关系，一些人担心它可能会建立一个公共的社会价值体系，类似于中国的社会信用体系。有人担心，如果被广泛采用，我们在现实世界中取得的成就和犯下的错误可能等同于与该行动相关的SBT。这将为你的每一项成就和犯下的每一个错误建立一个终身的账本，没有交易功能。
从这个意义上说，SBT不能避免人为错误；发行人有可能将SBT发送给不正确的持有人，这可能会导致许多隐私问题。已经有一个案例，一个人创造了一个“混蛋SBT”，一个令牌，使用与NFT相同的技术，但可以被发送给一个人，然后他只能通过支付费用来删除它。SBTs的这一方面有可能造成巨大的伤害，并可能贬低Web3的灵魂。
SSI 的存在是为了解决当前在以数字为中心的社会中面临的关键身份问题。通过创建一个用户控制他们的数据并有权将其发送给他们希望的任何人的系统，我们开始促进真正的数据所有权成为一种社会规范。公司和个人之间的数据交易可以像消息传递一样简单。通过不建立固有的面向公众的身份系统，SSI 可以解决数据盗窃和中心化数据孤岛的问题，而发行人和持有人之间没有任何歧义。
SBTs是建立在预先存在的Web3概念上的，比如NFT，这为社区采用它们提供了一条强有力的途径，特别是因为开发人员已经习惯了这种工具。然而，随着社区开始理解SBTs的公共性质以及由此产生的隐私问题(例如，在线行为的可追溯性)，他们将开始寻找保护隐私的替代方案。
另一方面，SSI近年来受到大学的青睐，并在管理机构中拥有强大的市场，特别是考虑到最近发生的事件，如新冠肺炎。对SSI的兴趣已经开始增长，欧盟委员会提议所有欧洲人都应该拥有一个安全的数字身份。这种政府采用水平将有利于SSI进一步扩展到教育和医疗保健等全球关键领域。
SBTs和SSI都因解决了Web3当前的身份混乱而获得公众关注。SBT寻求利用社区对NFT的熟悉程度来确保快速无缝的采用。然而，SSI希望通过专注于隐私的技术来解决这些问题，这项技术是经过多年研究开发出来的。尽管如此，这两个系统都有潜力为我们的数字生活增加价值。尽管如此，SSI是唯一一个足够深入地解决身份和隐私问题的方案，让Web3真正被大众接受，并将我们置于我们自己生态系统的中心。
了解更多 Ethereum&amp;rsquo;s Vitalik Buterin Lists &amp;lsquo;Worthwhile&amp;rsquo; Ideas for Developers to Work On
6 Key Points in Vitalik Buterin&amp;rsquo;s Vision for Ethereum Presented at EthCC These Are Some Topics Ethereum Developers Disagree With Vitalik Buterin On</description></item><item><title>身份验证世界中的自主身份：架构和领域用例</title><link>https://icorer.com/icorer_blog/en/posts/web3/self-sovereign-identity-in-a-world-of-authenticationarchitecture-and-domain-usecases/</link><pubDate>Tue, 13 Dec 2022 11:55:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/web3/self-sovereign-identity-in-a-world-of-authenticationarchitecture-and-domain-usecases/</guid><description>摘要自我主权身份 (SSI) 预计将以某种形式成为每个人生活的一部分。在与第三方组织打交道时，验证和验证一个人是否是他们声称的真实人物的能力以及保护个人属性的能力可能会产生广泛的影响。利用区块链和其他去中心化技术，SSI 是一个不断发展的研究领域。在去中心化结构中保护个人信息的方面可能对公共和私营部门有益。
在本文中，我们描述了 SSI 框架架构以及跨领域（如医疗保健、金融、零售和政府）的可能用例。该论文还将 SSI 及其去中心化架构与当前广泛采用的公钥基础设施 (PKI) 模型进行了对比。
1.介绍在数字领域有目的地验证您的身份的能力是大多数（如果不是全部）在线活动的基础。我们根据妥协对我们生活的负面影响，在不同级别保护这种在线身份。随着我们生活中越来越多的时间在网上进行交易，人们在管理数字身份的方式上也越来越精明。对所有帐户使用相同的“简单”密码曾经是一种常见的做法。现在这被视为灾难的根源，知道如果一个在线帐户被泄露，那么您的所有帐户都可能暴露 [1]。组织正在帮助用户转向需要多因素身份验证和更强密码的更安全的在线身份实践。这些步骤极大地提高了在线身份安全性，但标准在线身份管理系统的架构本质上是不安全的。区块链和去中心化身份的发展促成了自我主权身份 (SSI) 框架的创建。 SSI 框架在许多领域都有巨大的实现可能性，在这些领域中存在对个人隐私的驱动 [2]。
这些框架的开发旨在提高用户个人身份信息 (PII) 的整体安全性。 PII 的示例包括用户姓名、地址、护照号码、驾照号码、纳税人识别号码、患者识别号码、财务记录等。个人健康信息 (PHI) 是最受追捧的信息之一，黑客在 PII 之后，主要原因是医疗保健中使用的身份与社会安全号码 (SSN) 相关联，而社会安全号码对于个人来说永远不会改变 [3]。组织使用其他 PHI（例如家庭住址和电话号码）来确定身份可能会发生变化。使用窃取的 PHI 进行冒充会使个人陷入可能导致严重经济损失的境地。 SSI 在医疗保健行业的使用可以帮助保护用户数据并限制患者 PHI 的扩散。使用 SSI 模型的医疗保健提供者只有在获得患者批准/许可的情况下才能访问患者 PHI。
与公钥基础设施 (PKI) 类似，SSI 使用非对称密钥作为加密体系结构以及数字签名来确保对等方之间的安全通信 [4]。 PKI 利用一组中央机构来存储身份、证书和公共加密密钥的关联数据库。相反，SSI 使用去中心化账本技术 (DLT) 来关联去中心化标识符 (DID) 和公共加密密钥。在 SSI 实现中，DID 及其对称密钥对的公共部分是唯一可公开访问的与实体相关的信息。该实体保留他们认为合适时共享的身份信息详细信息。
本文描述了 SSI 体系结构及其主要组件，以及 PKI 和 SSI 中使用的机制之间的比较。我们还研究了如何在医疗保健、金融、零售和政府等不同领域利用 SSI，在这些领域中需要身份验证和数据安全，并且在某些情况下是法规要求的
本文介绍的架构是一个利用区块链、去中心化身份 (DID) 以及其他去中心化和加密技术的身份框架。该框架侧重于个人身份的自我主权理念。自我主权可以定义为可以控制自己身份的细节。这包括用户能够根据信息的预期接收者共享特定身份属性和获得的凭证的能力。用户将向接收者提供一个配置文件，其中该配置文件仅包括接收者为特定操作所需的那些身份详细信息。
SSI 架构的主要目标是实现 CIA 三元组；机密性、完整性和可用性。其他框架通过依赖于不同结构的不同架构技术来实现这些目标。提出的框架优先考虑信息安全和用户访问控制。</description></item><item><title>Self-Sovereign Identity：什么是自我主权身份？</title><link>https://icorer.com/icorer_blog/en/posts/web3/what-is-self-sovereign-identity/</link><pubDate>Mon, 12 Dec 2022 11:55:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/web3/what-is-self-sovereign-identity/</guid><description>如今，我们日常生活的许多方面都依赖数字服务，从在线购物到所谓的 Web2.0 中的金融服务。我们使用多个（如果不是数百个）帐户与不同的集中式网络平台（例如社交媒体或电子邮件服务）进行交互。问题是，当我们无法访问我们的帐户时，我们就会失去我们的数字身份，因为网站无法再识别我们是谁。这意味着我们实际上并不拥有我们的身份和数据。这有问题。我们需要收回数据和数字身份的所有权，而自主身份可以实现这一点，为我们进入 Web3.0 铺平道路。
自我主权身份是指一种让个人控制其数字身份的方法。自我主权身份 (SSI) 是一项运动，它声称数字身份应该与一个人的人类身份一样合法，同时所有人都可以访问、保护隐私并且不依赖于单一的政府或公司。
那么究竟什么是自我主权身份呢？自我主权身份是指一种让个人控制其数字身份的方法。为了更好地理解这个概念，让我们看一下两个模型：
Web 2.0 - 集中式模型我们的电子邮件帐户、网站帐户和社交媒体帐户目前允许数字服务在线识别我们。我们要么为每个平台创建一个帐户，要么使用 Facebook 或 Google 等服务提供商提供的单点登录。无论我们使用哪种方法，我们的数据都由帐户提供商集中存储。这种模式产生了一些严重的问题：
管理困难：我们努力管理众多帐户以访问不同的数字平台。此外，这些平台可以单方面决定关闭我们的帐户，或代表我们管理它。
安全和依赖风险：由于我们的大多数帐户都与我们的电子邮件地址相关联，如果我们的电子邮件访问受到威胁，黑客可以通过“忘记我的密码”方法更改密码来轻松接管使用该电子邮件的其他帐户。例如，黑客可以伪装成数字化的你，并在 Facebook 上欺骗你的家人和朋友。
隐私的脆弱性：如果我们使用的服务被黑客入侵，我们的数据很可能会被泄露，因为它是集中存储的。根据身份盗窃研究中心的数据，到 2021 年 10 月，将近 2.815 亿人受到某种数据泄露的影响。
缺乏数据自主权：我们无法控制我们的数据如何被使用或与其他平台共享。更糟糕的是，这些数据是代表我们的身份。
Web 3.0 - 去中心化模型为了克服中心化身份模型的上述所有问题，我们需要引入去中心化身份模型，从而实现自我主权身份。个人与对应方（例如个人、组织或物联网）之间的关系是点对点的。它不再依赖中心化的实体，而是利用去中心化的网络，即区块链技术。这种方法的一些好处：
弹性网络：区块链网络永远不会宕机，而集中式网络由公司运营。 可验证凭证：数据和信息由身份所有者选择的受信任方（例如政府和银行）作为凭证发布。如果授予访问权限，其他节点可以验证链上的凭证。 建立信任：不变性是区块链的本质，它确保了可验证凭证的真实性。例如，同行可以通过链上证明来验证文凭是否由大学颁发。 控制数据：自主身份的所有者可以决定何时共享凭据，以及共享哪些凭据。 自我主权身份是一种以用户为中心的数字身份，我们作为用户可以完全控制我们的在线身份，但它不仅适用于个人，也适用于组织甚至设备 (IoT) 或程序。我们相信在不久的将来，我们都将使用自主身份在数字世界中进行点对点交互，而不是依赖于其他方基于账户的数字身份。
身份类型 真实身份人类身份是一个复杂的话题，几个世纪以来哲学家们一直在争论这个问题，而我所说的任何话都无法解决这些争论。我将人的身份简化为两部分，这两部分对于一个人成为社会上有生产力的成员来说都是必不可少的。
内在同一性：这就是我们照镜子时所看到的。这是我们的性别认同、政治认同或文化认同。在我们与最亲密的知己的关系中，这就是我们的身份。它是我们固有的，是身份的最真实形式。
外在身份：这是其他人（通常是机构）识别我们的方式。驾照是最普遍的例子。虽然旨在证明您有资格在公共道路上行驶，但它也是金融机构、机场和酒吧识别您的方式。它之所以有效，是因为机构信任，并且有了驾照，您始终可以得到担保。而且它不仅限于政府、教育、专业和会员凭证都以同样的方式工作。
数字身份一些最大的社交媒体、博客和其他互联网平台的存在基本上是为了帮助人们表达他们内在的身份。但是（值得注意的是）仍然没有很好的方法来数字化管理我们的外在身份。我们仍然使用纸质文件和塑料卡来访问我们生活中一些最重要的服务，使我们身份的一些最敏感和最重要的方面受到欺诈。令人恐惧的是，在日益数字化的世界中，我们有时必须扫描、通过电子邮件发送或发送这些文件的照片才能完成一些基本的事情，例如获得购房资格或开设银行账户。
自我主权身份自我主权身份是真实身份与数字世界的结合，最终将使人们的生活更美好。它仍处于起步阶段，要真正使数字身份像现实世界一样合法，还有很长的路要走身份。但最近有几项非常有前途的技术进步代表了巨大的突破，其中最重要的是数字钱包的出现和可验证凭证的标准化，这些共同创造了一条首次将我们的外在身份在线化的途径。
技术组成 SSI 架构由 W3C 定义的七项关键技术组成。这七项技术是：
去中心化标识符：Decentralized Identifiers 可验证凭证：Verifiable Credentials 去中心化公钥基础设施：Decentralized Public Key Infrastructure 区块链和分布式账本技术：Blockchain and Distributed Ledger Technology 可验证数据注册表：Verifiable Data Registry 代理程序：Agents 数字钱包：Digital Wallets 接下来详细描述每一个组成部分：</description></item><item><title>采用零信任模型的13个必备功能</title><link>https://icorer.com/icorer_blog/en/posts/zerotrust/13-must-have-features-to-adopting-a-zero-trust-model/</link><pubDate>Sun, 11 Dec 2022 11:55:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/zerotrust/13-must-have-features-to-adopting-a-zero-trust-model/</guid><description> 处理服务网格安全性的最佳方法是采用零信任模型，这意味着每个连接，无论其来源如何，都必须经过验证和保护。为了帮助您评估服务网格技术并实施零信任安全，我们展示了13个必备功能，以确保您的应用程序连接安全。
1. 传输层安全性（TLS 和 mTLS）提供端到端加密以保护任何一对端点之间的移动数据。它可能是最基本的组件，但令人惊讶的是并非所有服务网格都完全支持双向 TLS。 2.授权例如，Open Policy Agent (OPA) 将服务 API 策略定义为代码。授权是身份验证的另一面，一旦您验证了他们的身份，便可以控制谁可以访问哪些资源。
3.证书管理从集中式平台控制和执行 SSL 证书以验证连接。证书轮换可能是一个痛苦的管理步骤，应该从容应对。这应该是可扩展的以支持外部权限，这意味着它将与您已经使用的企业身份和访问管理解决方案一起工作。
4.基于角色的联合出入控制(RBAC)和委托向用户授予与其职责相适应的权限，并再次在所有地方始终如一地应用此权限。这些控制可以应用于不同级别的操作员管理服务网格，也适用于构建在网格中运行的应用程序的开发人员。
5.联合信任域跨环境安全地验证用户和应用程序，在任何地方一致地扩展验证策略。否则，您将花费大量精力尝试保持各种角色的更新和同步——并且可能会犯一些错误。
6.联邦信息处理标准 (FIP) 140-2意味着您的服务网格技术已经过验证，可以满足美国政府制定的特定严格安全标准。有许多政府法规和行业最佳实践，但 FIPS 是一种常用的安全基准方法。
7.多租户和隔离让服务网格中的用户和应用程序安全地共享资源。拥有 RBAC 后，您可以安全地定义谁可以触摸什么，并有效地为不同角色创建隔离的工作区。 服务网格的授权策略也可用于防止不需要的流量到达您的应用程序。
8. 内置 Web 应用程序防火墙 (WAF)筛选入站流量中的威胁并阻止攻击渗透到您的边界。对于任何暴露在互联网上的边缘网关来说，它对于传入的用户和应用程序连接请求都是必不可少的,WAF除了边界网关模型，还需要内置进入各类端点程序，让WAF可以增强东西流量应用层的安全性。
9.数据丢失防护 (DLP)监控数据泄露或泄露，以防止数据丢失和数据泄漏。如果您的应用程序以某种方式受到损害，您不希望数据逃离您的边界。
10.与机密管理集成对于管理密码、安全令牌和加密密钥等敏感凭证的 Kubernetes。您会惊奇地发现这些信息仍然被硬编码到应用程序中或以纯文本形式存储的频率。
11.多集群访问可观察性提供整个系统所有活动的完整日志聚合和可审计性。这对于事件发生后的实时监控和取证都非常有用。对于分布式应用程序，有必要获得一个整体视图。许多人使用 Prometheus 和 Grafana 等开源工具来实现可观察性。 12.漏洞扫描和发布查找、解决和警告系统中的任何弱点。安全性取决于其最薄弱的环节，因此检查您的防御措施是否存在漏洞非常重要。 13.集群中继的安全拉取模型在整个系统中安全地共享配置。这非常微妙，但您希望确保任何配置更改都在请求时分发到边缘，并且仅在请求时分发。
附录 What is mtls The zero trust authorization core What is Certificate Management RBAC vs. ABAC: What’s the Difference Creating Federation Trust between organizations FIPS 140-2 OWASP Coraza WAF Web application firewall (WAF) What is DLP</description></item><item><title>Drand去中心化可验证随机数</title><link>https://icorer.com/icorer_blog/en/posts/web3/verifiable-random-number-drand-program-experiment/</link><pubDate>Thu, 08 Dec 2022 11:55:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/web3/verifiable-random-number-drand-program-experiment/</guid><description>Drand最初来自DEDIS实验室，由于使用基于配对的密码学，drand 能够以非常简单和有效的方式生成随机性，并以可靠的方式将其交付给客户端。Drand 旨在成为一种分布式服务，以与应用程序无关、安全且高效的方式提供公共随机性。随着 drand 的成熟，越来越多的组织（包括 NIST、Cloudflare、Kudelski Security、智利大学和协议实验室）开始感兴趣，并决定共同努力建立一个跨越这些组织的 drand 网络。
Drand 旨在成为一种互联网基础设施级服务，为应用程序提供随机性，类似于 NTP 提供计时信息和证书透明服务器提供证书吊销信息的方式，Drand去中心化随机数方案可以提供 去中心化随机性与可验证性两大核心功能。
为什么去中心化随机性很重要多年来，一代公共随机性(通常称为common coins)吸引了密码学研究社区的持续兴趣。许多分布式系统，包括各种共识机制、Tor等匿名网络或区块链系统，都假定可以访问这种公共随机性。例如，在最近的权益证明区块链中，矿工在每个时期都是通过一个共同的随机源随机选出的。然而，拥有一个不可偏置的、分布式的、可扩展的公共随机资源仍然是一个主要的缺失部分。目前存在一些集中式解决方案，尽管它们确实提供了一个统一的随机性来源，但这些信标既不可验证也不分散。可验证性是必要的。对于权益证明系统中的示例，可验证性是必要的，在该系统中，区块生产者需要证明他已被选为给定时期的矿工。
实验代码 1 2package main 3 4import ( 5 &amp;#34;context&amp;#34; 6 &amp;#34;encoding/hex&amp;#34; 7 &amp;#34;log&amp;#34; 8 &amp;#34;time&amp;#34; 9 10 &amp;#34;github.com/drand/drand/client&amp;#34; 11 &amp;#34;github.com/drand/drand/client/http&amp;#34; 12) 13 14var urls = []string{ 15 &amp;#34;https://api.drand.sh&amp;#34;, 16 &amp;#34;https://drand.cloudflare.com&amp;#34;, 17} 18 19var chainHash, _ = hex.DecodeString(&amp;#34;8990e7a9aaed2ffed73dbd7092123d6f289930540d7651336225dc172e51b2ce&amp;#34;) 20 21func main() { 22 c, err := client.New( 23 client.From(http.ForURLs(urls, chainHash)...), 24 client.WithChainHash(chainHash), 25 ) 26 27 if err !</description></item><item><title>Curl-VS-Guzzle 性能测试</title><link>https://icorer.com/icorer_blog/en/posts/curl-vs-guzzle-performance-test/</link><pubDate>Fri, 22 Feb 2019 13:40:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/curl-vs-guzzle-performance-test/</guid><description>Curl-VS-Guzzle 性能测试这里项目围绕Curl 和 Guzzle这两个HTTP请求组件进行一些压力测试,看一下性能差距.我们围绕两个组件的连接复用情况来测试.(文章中会强调opcache的作用)
一. 测试阐述 测试curl和guzzle在连接复用情况下的性能差别 (guzzle不开启opcache) 测试curl和guzzle在连接复用情况下的性能差别 (guzzle开启opcache) 二. 性能测试过程2.1 测试条件 在相同的Nginx,PHP,LibCurl库环境 测试脚本包含curl对象的复用,每次测试请求执行10次外部http请求 2.2 Guzzle测试代码 1//GuzzleClient.php 2use \GuzzleHttp\Client; 3class GuzzleClient 4{ 5 protected static $guzzleClientConnection = null; 6 7 public static function getGuzzleClient($baseUrl, $persistent = true) 8 { 9 if (!$persistent || !self::$guzzleClientConnection) { 10 self::$guzzleClientConnection = new Client([&amp;#39;base_uri&amp;#39; =&amp;gt; $baseUrl]); 11 } 12 13 return self::$guzzleClientConnection; 14 } 15 16} 17 18//get_loop_simple.php 内部循环调用多次 19for ($i=0;$i&amp;lt;10;$i++){ 20 try { 21 //获取Client静态变量,复用curl单体 22 $client = GuzzleClient::getGuzzleClient(&amp;#34;http://127.</description></item><item><title>IO读取缓冲器-BufReader</title><link>https://icorer.com/icorer_blog/en/posts/io-read-buffer-bufreader/</link><pubDate>Thu, 03 Jan 2019 16:59:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/io-read-buffer-bufreader/</guid><description>一. IO问题思考IO读取缓冲器,顾名思义就是针对系统的IO读取操作添加一层缓冲层,有这层缓冲层到底有啥好处呢?针对这个问题,我先问大家以下几个问题.
对于IO读取操作,无论针对的是对象,还是针对网络,每次IO操作均需要陷入内核调用,频繁内核调用会严重影响性能,请问有没有什么办法优化这部分? 针对网络IO读取过程,网络时好时坏,如何让网络IO能够发挥最大的性能潜力,在网络好的时候抓紧多读,在网络差的时候适当少读? 对于文件读取,和网络短连接读取,我们可以很快的根据EOF来结束io连接,但是对于网络长连接,我们无法即使获取到IO的EOF事件,我们该如何避免数据包读取过程的最终状态判断造成的延时问题? 如何提高文件读取,网络读取的内存使用率? 针对上面三个问题,我们均可以使用IO读取缓冲器来解决.
二. 无IO缓冲器IO无用户态缓冲器下,[数据源]和[数据接收端]这两方之间通过程序语言提供的IO API进行数据通信,这种通信模式图如下:
从上图可以看到
三. 缓冲器作用缓冲器建立在传统IO对象上,在传统的IO操作基础上,我们不立刻把读取到的数据传达给调用层代码,而是放进内存缓冲区,并启动针对缓冲区的两个指针(写入指针,读取指针).
相关的模型图如下:</description></item><item><title>源码阅读：YAF框架系列文章(3) - (yaf_application.c)</title><link>https://icorer.com/icorer_blog/en/posts/source-code-reading-yaf-framework-series-articles-3-yaf_application.c/</link><pubDate>Thu, 22 Nov 2018 15:33:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/source-code-reading-yaf-framework-series-articles-3-yaf_application.c/</guid><description>这个文件主要围绕Yaf_Application类的注册，这里，按照倒叙的方式来进行讲解。
一、注册yaf_application类
1YAF_STARTUP_FUNCTION(application) { 2//定义一个zend_class_entry实例变量 3 zend_class_entry ce; 4 5/* 初始化一个CLASS ENTRY 6#define YAF_INIT_CLASS_ENTRY(ce, name, name_ns, methods) \ 7 if(YAF_G(use_namespace)) { \ 8 INIT_CLASS_ENTRY(ce, name_ns, methods); \ 9 } else { \ 10 INIT_CLASS_ENTRY(ce, name, methods); \ 11 } 12*/ 13 YAF_INIT_CLASS_ENTRY(ce, &amp;#34;Yaf_Application&amp;#34;, &amp;#34;Yaf\\Application&amp;#34;, yaf_application_methods); 14 15 // https://src.icorer.com/xref/php-src/Zend/zend_API.c#2752 16 //注册一个类到内核类表中 17 yaf_application_ce = zend_register_internal_class_ex(&amp;amp;ce, NULL); 18 //修改类属性为终极类 19 yaf_application_ce-&amp;gt;ce_flags |= ZEND_ACC_FINAL; 20 21 //声明一个属性定义，为Protected类型 22 zend_declare_property_null(yaf_application_ce, 23 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_CONFIG), ZEND_ACC_PROTECTED); 24 zend_declare_property_null(yaf_application_ce, 25 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_DISPATCHER), ZEND_ACC_PROTECTED); 26 27 //声明一个NULL元素，为static protected类型 28 zend_declare_property_null(yaf_application_ce, 29 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_APP), ZEND_ACC_STATIC | ZEND_ACC_PROTECTED); 30 zend_declare_property_null(yaf_application_ce, 31 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_MODULES), ZEND_ACC_PROTECTED); 32 //声明一个布尔类型的元素，为protected类型 33 zend_declare_property_bool(yaf_application_ce, 34 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_RUN), 0, ZEND_ACC_PROTECTED); 35 //声明一个字符串类型的元素 ， 为protected类型 36 zend_declare_property_string(yaf_application_ce, 37 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_ENV), YAF_G(environ_name), ZEND_ACC_PROTECTED); 38 //声明一个长整数类型的元素，为protected类型 39 zend_declare_property_long(yaf_application_ce, 40 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_ERRNO), 0, ZEND_ACC_PROTECTED); 41 zend_declare_property_string(yaf_application_ce, 42 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_ERRMSG), &amp;#34;&amp;#34;, ZEND_ACC_PROTECTED); 43 44 return SUCCESS; 45} 二、添加类方法 上面讲解了创建一个类的过程，但是类中还有很多方法，通过yaf_application_methods方法集进行管理，具体对于函数的添加代码如下。</description></item><item><title>高级编程：PHP扩展的 INI 配置文件操作</title><link>https://icorer.com/icorer_blog/en/posts/ini-configuration-file-manipulation-for-php-extensions/</link><pubDate>Thu, 22 Nov 2018 10:24:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/ini-configuration-file-manipulation-for-php-extensions/</guid><description>Extension INI Entries (扩展INI配置项)Defining php.ini directives (i.e., INI entries) in an extension is easy. Most of the work involves setting up the global struct explained earlier in Section 14.10.3 Each entry in the INI structure is a global variable in the extension and thus has an entry in the global struct and is accessed using FOO_G(my_ini_setting). For the most part you can simply comment out the indicated sections in the skeleton created by ext_skel to get a working INI directive, but we will walk through it here anyway.</description></item><item><title>源码阅读：YAF框架系列文章(2) - (yaf.c)</title><link>https://icorer.com/icorer_blog/en/posts/source-code-reading-yaf-framework-series-articles-2-yaf.c/</link><pubDate>Thu, 22 Nov 2018 10:04:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/source-code-reading-yaf-framework-series-articles-2-yaf.c/</guid><description>这个文件是yaf框架的整体组成框架文件，因为yaf的设计思路是模块化的，因此在这个文件中进行了总体整合。整合的思路分为以下几个部分。
INI配置文件的解析 注册系统使用的常量 注册各个模块 对扩展模块的各个生命期做拦截监控 注册扩展模块 一、INI配置文件解析功能
在php_yaf.h文件中对于全局变量进行了定义工作，随后在yaf.c中进行了声明工作，声明操作 ZEND_DECLARE_MODULE_GLOBALS(yaf); ，声明操作之后，并在PHP_GINIT_FUNCTION钩子函数期进行了全局变量的初始化工作，框架进行了配置文件的加载过程，配置文件的操作定义如下：
1/** {{{ PHP_INI_MH(OnUpdateSeparator) 2 */ 3PHP_INI_MH(OnUpdateSeparator) { 4 YAF_G(name_separator) = ZSTR_VAL(new_value); 5 YAF_G(name_separator_len) = ZSTR_LEN(new_value); 6 return SUCCESS; 7} 8/* }}} */ 9 10/** {{{ PHP_INI 11 */ 12PHP_INI_BEGIN() 13 STD_PHP_INI_ENTRY(&amp;#34;yaf.library&amp;#34;, &amp;#34;&amp;#34;, PHP_INI_ALL, OnUpdateString, global_library, zend_yaf_globals, yaf_globals) 14 STD_PHP_INI_BOOLEAN(&amp;#34;yaf.action_prefer&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, action_prefer, zend_yaf_globals, yaf_globals) 15 STD_PHP_INI_BOOLEAN(&amp;#34;yaf.lowcase_path&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, lowcase_path, zend_yaf_globals, yaf_globals) 16 STD_PHP_INI_BOOLEAN(&amp;#34;yaf.use_spl_autoload&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, use_spl_autoload, zend_yaf_globals, yaf_globals) 17 STD_PHP_INI_ENTRY(&amp;#34;yaf.</description></item><item><title>源码阅读：YAF框架系列文章(1) - (php_yaf.h)</title><link>https://icorer.com/icorer_blog/en/posts/source-code-reading-yaf-framework-series-articles-1-php_yaf.h/</link><pubDate>Wed, 21 Nov 2018 14:30:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/source-code-reading-yaf-framework-series-articles-1-php_yaf.h/</guid><description>这个文件的核心使命是构建yaf基础定义，这部分定义主要包括
对于内核函数的宏定义 对于框架变量类型的宏定义 对于框架所使用的全局变量进行定义 一、对于内核函数进行宏定义
1#define YAF_STARTUP_FUNCTION(module) ZEND_MINIT_FUNCTION(yaf_##module) 2#define YAF_RINIT_FUNCTION(module) ZEND_RINIT_FUNCTION(yaf_##module) 3#define YAF_STARTUP(module) ZEND_MODULE_STARTUP_N(yaf_##module)(INIT_FUNC_ARGS_PASSTHRU) 4#define YAF_SHUTDOWN_FUNCTION(module) ZEND_MSHUTDOWN_FUNCTION(yaf_##module) 5#define YAF_SHUTDOWN(module) ZEND_MODULE_SHUTDOWN_N(yaf_##module)(INIT_FUNC_ARGS_PASSTHRU) 这个部分表现了yaf框架的模块化设计，yaf通过宏定义对于模块相关ZEND函数进行了封装，每个模块都将有自己的模块加载、关闭函数。例如YAF_STARTUP_FUNCTION(module) 的宏定义展开形式就是 zm_startup_yaf_module(int type, int module_number)
二、对于框架自定义变量类型进行定义
1#define yaf_application_t zval 2#define yaf_view_t zval 3#define yaf_controller_t zval 4#define yaf_request_t zval 5#define yaf_router_t zval 6#define yaf_route_t zval 7#define yaf_dispatcher_t zval 8#define yaf_action_t zval 9#define yaf_loader_t zval 10#define yaf_response_t zval 11#define yaf_config_t zval 12#define yaf_registry_t zval 13#define yaf_plugin_t zval 14#define yaf_session_t zval 15#define yaf_exception_t zval 三、对内核中将用到的函数做声明</description></item><item><title>设计文档：PulseFlow_IPC_Backend</title><link>https://icorer.com/icorer_blog/en/posts/design-document-pulseflow_ipc_backend/</link><pubDate>Wed, 22 Aug 2018 21:54:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/design-document-pulseflow_ipc_backend/</guid><description>PulseFLow还有一部分功能是集中在信息后端的，当PHP引擎发送信息给后端程序后，后端程序再把信息进行组装，发给下一级程序。
一 . 组成部分后端程序，分为以下几个部分：
配置中心：（配置文件 + 配置解析器）（采用ini文件配置格式）。
进程管理器：维持进程池，保持进程池的存活量。
信息发送： 信息组装 + 信息发送（UDP发送）
二. 工作流程2.1 总体流程图 2.2 系统模型（进程池模型） 后端组件采用进程池模型，主程序启动时，首先读取配置文件中关于进程池大小的配置选项，然后启动相关数量的子工作进程。
随后主进程进入稳定性极高的进程池监控流程，如果拦截到子进程有挂掉的情况发生，读取挂掉的状态并在相应的进程池位置开辟新的工作子进程。
通过进程池可以大大提高进程读取内核消息队列的效率，通过进程池管理程序可以大大提高整体后端程序的稳定性。
2.3 功能分配1. 主进程负责【管理进程池】，负责【创建可用的内核消息队列】。2. 工作子进程负责 【监控内核消息队列】&amp;mdash;&amp;gt;【读取消息】&amp;mdash;&amp;gt;【组装信息】&amp;mdash;&amp;gt;【UDP发送下游】</description></item><item><title>设计文档: PulseFLow PHP性能监控插件</title><link>https://icorer.com/icorer_blog/en/posts/design-documentation-pulseflow-php-performance-monitoring-plugin/</link><pubDate>Fri, 17 Aug 2018 13:18:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/design-documentation-pulseflow-php-performance-monitoring-plugin/</guid><description>一. 背景描述随着公司PHP项目体的不断增大，随着不同工程师的功能迭代，如何有效获取PHP项目的执行性能，对于系统整体模块显得异常重要，PulseFlow是一个公司团队内部自研地性能跟踪扩展，它可以在程序员无感知的情况下有效跟踪每一个函数的执行效率，主要分析CPU时间消耗、内存大小消耗，执行次数这三个指标，下面我们将从 PHP生命期 到 组件设计 到 性能优化这三个方面来进行阐述组件。
二 . 插件和 PHP生命期PHP生命周期通常包括 MI（模块初始化）、RI（请求初始化）、RS（请求终止）、MS（模块终止） 这四个步骤，这四个部分使我们能够进行功能渗透的生命期子过程。在MI阶段会包含INI配置文件的解析，在RI阶段会针对每一个CGI请求进行请求初始化操作，在RS阶段会针对每一个请求的关闭进行相关功能拦截。并不是每一次执行PHP均要经历这四个阶段，在CLI模式下，会完整经历这四个阶段，在PHP-FPM这种类CGI模式下，为了提高请求性能，并不会经历过全部阶段，它会着重经历RI、RS阶段。
了解了PHP的生命期轮廓后，我们绘制了下图阐述大概执行流程所属的生命期阶段。
三. 插件和ZEND引擎在上述的PHP生命周期阶段内，我们可以在不同的阶段分块插件的功能，其次，我们还需要和ZEND引擎打交道，因为ZEND引擎是真正的执行者，我们目前需要托管他们的 zend_execute_ex 内核函数，这个内核函数就是C语言的函数指针，这个内核函数顾名思义就是PHP的内核执行函数。
为了阐述方便，我们使用一个执行流程图，来看一下插件该如何拦截ZEND引擎的执行流程。 三. 开始造轮子3.1 插件流程分析首先，我们需要构建插件的执行流程，及各个部分的信息传送关系，我们目前把插件分为两部分，一部分是PHP扩展，用于在PHP生命周期内来进行性能拦截，这部分信息通常存储于 系统进程堆区 或者 系统进程静态区域，第二部分是后台数据转发程序，它负责从信息通道里读取PHP扩展写入的信息，并转发给相应的下一级程序，相关流程图如下。 3.2 环境选择（系统组件选择）这一步我们选择相应的环境，或者称之为系统组件选择，我们在选择相应组件时根据插件各个执行周期来进行选择。
3.2.1 PHP引擎环境 （PHP7+）首先PHP引擎我们选择7.0以上，因为 PHP7 与 PHP5 的内核数据结构差距甚大，目前针对PHP7，后面会移植代码覆盖PHP5版本。
3.2.2 插件语言 （C）虽然现在编写PHP扩展可以使用Go语言、zephir语言、但是为了和原PHP内核及Linux操作系统进行最好性能交互，我们选择C语言进行研发。
3.2.3 信息队列（System V 消息队列）在3.1中，我们提及了一个很重要的组件，并用红色进行了标记，PHP扩展和后台信息转发程序 如何 沟通？哪一条路最快？
为了选择这条信息通路，我们做了大量实验，覆盖面积包括TCP、unix domain socket、zeromq、nanomsg、共享内存、posix 内核消息队列、system V 内核消息队列，目前最快的是共享内存，其次是system V 和 posix 内核队列。
共享内存虽然是最快的，但是我们目前针对的模型是 多写、多读，为了不对PHP-FPM 内存 和 对系统内存能够更好更有力管理，在第一版中我们将采用system V内核队列，但是我们也已经开放了 共享内存版本的分支 和 给予epoll模型的 posix 内核队列 代码分支，这两个代码分值中均写好模型代码，在后面阶段将会一步步融入主线版本。
为什么选择 system V 队列？ 首先system V内核队列在 Linux Kernel 2.</description></item><item><title>检测并分析PHP扩展的内存泄露</title><link>https://icorer.com/icorer_blog/en/posts/detect-and-analyze-memory-leaks-in-php-extensions/</link><pubDate>Tue, 31 Jul 2018 09:11:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/detect-and-analyze-memory-leaks-in-php-extensions/</guid><description>1. 背景描述基于C/C++开发的程序，内存管理是很大程度上的工作，我们在这篇文章里来给大家讲解一下如何监控程序体可能存在的内存泄露。
工欲善其事必先利其器，这里选择使用 Valgrind 工作来进行内存监控。http://valgrind.org/
2. Valgrind工具安装1 git clone git://sourceware.org/git/valgrind.git 2 ./autogen.sh 3 ./configure --prefix=/usr/local/valgrind 4 make 5 make install 3. 测试命令样例1valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes php PulseFlow.php 4. 一次针对PHP扩展的内存泄露检测过程针对已经开源的 PulseFLow 插件，今天我们将进行相关的内存泄露检测，由于我们是对PHP扩展进行泄露检查，所以：
第一步，需要给PHP打开debug 编译参数，相关的编译参数如 ./configure --enable-debug 。
第二步，我们需要关闭zend 内存管理 ，添加相关的环境变量 export USE_ZEND_ALLOC=0 export ZEND_DONT_UNLOAD_MODULES=1 第三步，我们执行相关命令
1ZEND_DONT_UNLOAD_MODULES=1 USE_ZEND_ALLOC=0 valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes php PulseFlow.php 第四步，查看报告，获得总体报告如下
1==20296== LEAK SUMMARY: 2==20296== definitely lost: 0 bytes in 0 blocks 3==20296== indirectly lost: 0 bytes in 0 blocks 4==20296== possibly lost: 0 bytes in 0 blocks 5==20296== still reachable: 75,936 bytes in 29 blocks 6==20296== suppressed: 0 bytes in 0 blocks 5.</description></item><item><title>开源项目：PulseFLow 性能跟踪扩展</title><link>https://icorer.com/icorer_blog/en/posts/open-source-project-pulseflow-performance-tracking-extension/</link><pubDate>Wed, 25 Jul 2018 13:48:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/open-source-project-pulseflow-performance-tracking-extension/</guid><description>背景描述随着公司PHP项目体的不断增大，随着不同工程师的功能迭代，如何有效获取PHP项目的执行性能，对于系统整体模块显得异常重要，PulseFlow是一个性能跟踪扩展，它可以在程序员无感知的情况下有效跟踪每一个函数的执行效率，主要分析CPU时间消耗、内存大小消耗，这个组件除了能够快速记录每个函数体的性能信息，还具备一系列的发送机制，主要包括共享内存队列（System V 和 Posix）、UDP、Unix Domain Socket 等模式。
编译安装此为PHP扩展，按照正常的扩展安装，我们需要执行以下几步操作：
git clone https://github.com/gitsrc/PulseFlow.git 进入源码目录 phpize ./configure &amp;ndash;with-php-config= （ php-config文件路径） CFLAGS=&amp;rsquo;-g -lrt&amp;rsquo; CXXFLAGS=&amp;rsquo;-lrt' make make install 编译特别注意由于在扩展中使用了 posix 共享内存队列，所以我们编译时需要引入lrt库，上面在configure过程中附加的 CFLAGS 和 CXXFLAGS 参数用来给Makefile中的相应字段添加 -lrt，最终构造完后的Makefile对应配置应该为：
1CFLAGS = -g -lrt -O0 2 3CXXFLAGS = -lrt -g -O0 设计点1：PHP INI 配置选项PulseFlow由于是一个基于C语言的PHP扩展，为了保持程序体的扩展性，配置选项一律从php.ini文件中读取，本节将描述所有与扩展程序有关系的配置信息。
1.1 扩展功能开关参数 （PulseFlow.enabled）1.1.1 参数介绍这个参数是插件的功能开关，属于布尔类型，有效参数如下，默认 false：
true：开启 false：关闭 1.2 日志功能开关参数 （PulseFlow.debug）1.2.1 参数介绍这个参数是控制插件是否向页面输出调试信息，有效参数如下，默认 false：
true：开启 false：关闭 1.3 禁止跟踪函数列表 （PulseFlow.disable_trace_functions）1.3.1 参数介绍这个参数是一个逗号分隔的字符串，代表一系列函数列表，这个函数列表内的函数不进行性能跟踪，默认空字符串。
配置样例：PulseFlow.disable_trace_functions = &amp;ldquo;getLoader,findFile,loadClassLoader,getInitializer,findFileWithExtension,&amp;rdquo;
1.4 禁止跟踪类列表 （PulseFlow.disable_trace_class）1.4.1 参数介绍这个参数是一个逗号分隔的字符串，代表一系列类列表，这个类列表内的类不进行性能跟踪，默认空字符串。</description></item><item><title>编程笔记：C动态连接库编程</title><link>https://icorer.com/icorer_blog/en/posts/programming-notes-c-dynamic-link-library-programming/</link><pubDate>Tue, 24 Jul 2018 09:15:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/programming-notes-c-dynamic-link-library-programming/</guid><description>动态链接库，可以方便程序体扩展功能、更新组件，相对于编译时连接，具有更大的灵活性，下面我们从三个方面来讲解一个案例。
库函数定义在这里，我们首先定义一个简单的加法函数。
1#include &amp;lt;stdio.h&amp;gt; 2 3int add(int a,int b){ 4 return a+b; 5} 动态链接库编译我们通过编译命令对于源码文件进行编译，在linux系统中编译为so文件。
1gcc -shared -fPIC ./io.c -o add.so 编译参数解析 -shared该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接，相当于一个可执行文件。
-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。
测试动态链接库是否可用编写测试代码
1#include &amp;lt;stdio.h&amp;gt; 2#include &amp;lt;dlfcn.h&amp;gt; 3 4int main() { 5 void *handle = dlopen(&amp;#34;./add.so&amp;#34;, RTLD_LAZY); //打开动态链接库文件 6 char *dlerr = dlerror(); //跟踪动态链接库错误 7 8 if (handle == NULL || dlerr != NULL) { 9 printf(&amp;#34;%s\n&amp;#34;, dlerr); 10 return -1; 11 } 12 13 int (*add)(int, int) = dlsym(handle, &amp;#34;add&amp;#34;); //加载动态链接库函数 转换为函数指针 14 printf(&amp;#34;%d\n&amp;#34;, add(1, 2)); //根据函数指针调用动态链接库函数 15 return 0; 16} 编译测试代码时，需要链接dl库 ，编译命令如下：</description></item><item><title>阅读笔记：动态内存分配 + 指针小结</title><link>https://icorer.com/icorer_blog/en/posts/reading-notes-dynamic-memory-allocation-+-pointer-summary/</link><pubDate>Mon, 23 Jul 2018 17:36:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/reading-notes-dynamic-memory-allocation-+-pointer-summary/</guid><description>1.什么是内存的动态分配 2.怎样建立内存分配 3. 指针小结</description></item><item><title>阅读笔记：指针数组和多重指针</title><link>https://icorer.com/icorer_blog/en/posts/reading-notes-pointer-arrays-and-multiple-pointers/</link><pubDate>Mon, 23 Jul 2018 15:58:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/reading-notes-pointer-arrays-and-multiple-pointers/</guid><description>1. 什么是指针数组一个数组，其元素均为指针类型的数据，被成为指针数组。也就是说，指针数组中的每一个元素都存放一个地址，相当于一个指针变量。下面定义一个指针数组。 ##1.1 样例分析 2. 指向指针的指针</description></item><item><title>阅读笔记：指针数组和多重指针</title><link>https://icorer.com/icorer_blog/en/posts/reading-notes-c-language-function-pointer/</link><pubDate>Mon, 23 Jul 2018 13:51:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/reading-notes-c-language-function-pointer/</guid><description>1.指向函数的指针1.1什么是指针函数 1.2 怎样定义指向函数的指针变量定义指向函数的指针变量一般形式为： 例如 int (*p)(int a, int b); 这里的 “类型名” 是指函数返回值的类型。
1.2.1说明 定义指向函数的指针变量，并不意味着这个指针变量可以指向任何函数，它只能指向在定义时指定的类型的函数。在同一个程序中，一个指针变量可以先后指向同类型的不同函数。
在给指针变量赋值时，只需给出函数名，而不需要给出参数，如果带上参数，会让编译器误认为正在调用函数。
对指向函数的指针变量不能进行加减运算、因为这些云端是没有意义的。
通过函数名，只能调用一个函数，而通过函数指针变量，便可以实现动态调用不同的函数。
1.3 使用函数指针调用函数如果想调用一个函数，除了使用函数名进行调用之外，还可以使用指向此函数的函数指针变量进行调用，简单样例如下。
1#include &amp;lt;stdio.h&amp;gt; 2 3int main() { 4 int (*p)(int a, int b); 5 int add(int a, int b); //函数声明 6 p = add; //函数指针变量赋值 or p = &amp;amp;add; 7 int a = 100, b = 200; 8 int c = (*p)(a, b); //函数指针调用 9 printf(&amp;#34;%d\n&amp;#34;, c); 10 11 return 0; 12} 13 14int add(int a, int b) { 15 return a + b; 16} 1.</description></item><item><title>环境搭建：CLion 搭建 PHP 扩展开发环境</title><link>https://icorer.com/icorer_blog/en/posts/clion-builds-a-php-extension-development-environment/</link><pubDate>Tue, 10 Jul 2018 10:06:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/clion-builds-a-php-extension-development-environment/</guid><description>#1. PHP扩展代码框架搭建 此处，可以参考本博客原来的文章进行框架代码搭建。 【PHP扩展开发1：代码框架搭建】
2. 从源文件导入CLion工程 点击clion菜单栏File -&amp;gt; Import Project 选择扩展目录 -&amp;gt; 选择项目所要的文件 -&amp;gt; 点击确认 因为clion是由CMakeList.txt文件进行，所以当导入后clion会自动生成基本的配置文件。
#3. 修改CMakeList.txt 加入库文件索引等，样例配置如下。
1cmake_minimum_required(VERSION 3.10) 2project(PulseFlow C) 3 4set(CMAKE_C_STANDARD 11) 5 6set(SOURCE_FILES 7 php_PulseFlow.h 8 PulseFlow.c) 9 10add_executable(PulseFlow ${SOURCE_FILES}) 11 12add_custom_target(makefile COMMAND make &amp;amp;&amp;amp; sudo make install WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}) 13 14 15include_directories(.) 16set(PHP_SOURCE /usr/local/php/include/php) 17 18include_directories(${PHP_SOURCE}/main) 19include_directories(${PHP_SOURCE}/Zend) 20include_directories(${PHP_SOURCE}/sapi) 21include_directories(${PHP_SOURCE}/pear) 22include_directories(${PHP_SOURCE}) #4. 调试代码
4.1 在CMakeList.txt文件中添加编译命令1add_custom_target(makefile COMMAND make &amp;amp;&amp;amp; sudo make install WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}) 4.2 添加运行配置 (很重要 一定要选择 makefile编译)</description></item><item><title>编程笔记：C语言回调函数</title><link>https://icorer.com/icorer_blog/en/posts/programming-notes-c-language-callback-function/</link><pubDate>Mon, 09 Jul 2018 16:56:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/programming-notes-c-language-callback-function/</guid><description>在计算机程序设计中，回调函数，或简称回调（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。 假设我们要使用一个排序函数来对数组进行排序，那么在主程序(Main program)中，我们先通过库，选择一个库排序函数(Library function)。但排序算法有很多，有冒泡排序，选择排序，快速排序，归并排序。同时，我们也可能需要对特殊的对象进行排序，比如特定的结构体等。库函数会根据我们的需要选择一种排序算法，然后调用实现该算法的函数来完成排序工作。这个被调用的排序函数就是回调函数(Callback function)。
结合这幅图和上面对回调函数的解释，我们可以发现，要实现回调函数，最关键的一点就是要将函数的指针传递给一个函数(上图中是库函数)，然后这个函数就可以通过这个指针来调用回调函数了。注意，回调函数并不是C语言特有的，几乎任何语言都有回调函数。在C语言中，我们通过使用函数指针来实现回调函数。那函数指针是什么？不着急，下面我们就先来看看什么是函数指针。
什么是函数指针函数指针也是一种指针，只是它指向的不是整型，字符型而是函数。在C中，每个函数在编译后都是存储在内存中，并且每个函数都有一个入口地址，根据这个地址，我们便可以访问并使用这个函数。函数指针就是通过指向这个函数的入口，从而调用这个函数。
函数指针的使用函数指针的定义函数指针虽然也是指针，但它的定义方式却和其他指针看上去很不一样，我们来看看它是如何定义的：
1/* 方法1 */ 2void (*p_func)(int, int, float) = NULL; 3 4/* 方法2 */ 5typedef void (*tp_func)(int, int, float); 6tp_func p_func = NULL; 这两种方式都是定义了一个指向返回值为 void 类型，参数为 (int, int, float) 的函数指针。第二种方法是为了让函数指针更容易理解，尤其是在复杂的环境下；而对于一般的函数指针，直接用第一种方法就行了。 如果之前没见过函数指针，可能会觉得函数指针的定义比较怪，为什么不是 void ()(int, int, float)*p_func 而是 void (*p_func)(int, int, float) 这种形式？这个问题我也不知道，也没必要纠结，花点时间理解下它与普通指针的区别，实在不行就先记住它的形式。
函数指针的赋值在定义完函数指针后，我们就需要给它赋值了我们有两种方式对函数指针进行赋值：
1void (*p_func)(int, int, float) = NULL; 2p_func = &amp;amp;func1; 3p_func = func2; 上面两种方法都是合法的，对于第二种方法，编译器会隐式地将 func_2 由 void ()(int, int, float) 类型转换成 void (*)(int, int, float) 类型，因此，这两种方法都行。</description></item><item><title>源码阅读：PHP TSRM 线程安全管理器</title><link>https://icorer.com/icorer_blog/en/posts/source-code-reading-php-tsrm-thread-safety-manager/</link><pubDate>Sun, 08 Jul 2018 23:49:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/source-code-reading-php-tsrm-thread-safety-manager/</guid><description>TSRM 简介在查看php源代码或开发php扩展的时候，会出现大量 TSRMLS_ 宏字样在函数参数的位置，这些宏就是Zend为线程安全机制所提供的（Zend Thread Safety，简称ZTS）用于保证线程的安全 , 是防止多线程环境下以模块的形式加载并执行PHP解释器，导致内部一些公共资源读取错误，而提供的一种解决方法。
什么时候需要用 TSRM只要服务器是多线程环境并且PHP以模块的形式提供，那么就需要TSRM启用，例如apache下的 worker 模式(多进程多线程)环境，这种情况就必须要使用线程安全版本的PHP，也就是要启用TSRM , 在Linux下是编译PHP的时候指定是否开启TSRM、windows下是提供线程安全版本和非线程安全版本的PHP。
PHP 如何实现 TSRM正常多线程环境下操作公共的资源都是加上互斥锁，而PHP没有选择加锁，因为加锁可能多少会有些性能损耗，PHP的解决方法是为每一个线程都copy一份当前PHP内核所有的公共资源过来，每个线程指向自己的公共资源区，互不影响，各操作各的公共资源。
公共资源是什么就是各种各样的 struct 结构体 定义。
#TSRM数据结构
tsrm_tls_entry结构体tsrm_tls_entry 线程结构体、每个线程都有一份该结构体。
1typedef struct _tsrm_tls_entry tsrm_tls_entry; 2struct _tsrm_tls_entry { 3 void **storage; 4 int count; 5 THREAD_T thread_id; 6 tsrm_tls_entry *next; 7} 8static tsrm_tls_entry **tsrm_tls_table = NULL //线程指针表头指针 9static int tsrm_tls_table_size; //当前线程结构体数量 ###字段说明
void **storage ：资源指针、就是指向自己的公共资源内存区 int count : 资源数、就是 PHP内核 + 扩展模块 共注册了多少公共资源 THREAD_T thread_id ： 线程id tsrm_tls_entry *next：指向下一个线程指针，因为当前每一个线程指针都存在一个线程指针表里（类似于hash表），这个next可以理解成是hash冲突链式解决法.</description></item><item><title>PHP扩展开发2.2：线程安全</title><link>https://icorer.com/icorer_blog/en/posts/php-extension-development-2.2-thread-safety/</link><pubDate>Fri, 06 Jul 2018 17:26:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/php-extension-development-2.2-thread-safety/</guid><description>背景介绍 线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
一般来说，线程安全的函数应该为每个调用它的线程分配专门的空间，来储存需要单独保存的状态（如果需要的话），不依赖于“线程惯性”，把多个线程共享的变量正确对待（如，通知编译器该变量为“易失（volatile）”型，阻止其进行一些不恰当的优化），而且，线程安全的函数一般不应该修改全局对象。
很多C库代码（比如某些strtok的实现，它将“多次调用中需要保持不变的状态”储存在静态变量中，导致不恰当的共享）不是线程安全的，在多线程环境中调用这些函数时，要进行特别的预防措施，或者寻找别的替代方案。 更多线程安全信息请浏览维基百科：链接地址
在PHP初期，是作为单进程的CGI来运行的，所以并没有考虑线程安全问题。我们可以随意的在全局作用域中设置变量并在程序中对他进行修改、访问，内核申请的资源如果没有正确的释放，也会在CGI进程结束后自动地被清理干净。
后来，php被作为apache多进程模式下的一个模块运行，但是这仍然把php局限在一个进程里，我们设置的全局变量，只要在每个请求之前将其正确的初始化，并在每个请求之后正确的清理干净，便不会带来什么麻烦。由于对于一个进程来说，同一个时间只能处理一个请求，所以这是内核中加入了针对每个请求的内存管理功能，来防止服务器资源利用出现错误。
随着使用在多线程模式的软件系统越来越多，php内核中亟需一种新的资源管理方式，并最终在php内核中形成了一个新的抽象层：TSRM(Thread Safe Resource Management)。
线程安全与非线程安全在一个没有线程的程序中，我们往往倾向于把全局变量声明在源文件的顶部，编译器会自动的为它分配资源供我们在声明语句之下的程序逻辑中使用。（即使通过fork()出一个子进程，它也会重新申请一段内存，父子进程中的变量从此没有了任何联系）
但是在一个多线程的程序中，如果我们需要每个线程都拥有自己独立的资源的话，便需要为每个线程独立开辟出一个区域来存放它们各自的资源，在使用资源的时候，每个线程便会只在自己的那一亩三分地里找，而不会拔了别人的庄稼。
线程安全资源池（Thread-SafeDataPools）在扩展的ModuleInit里，扩展可以调用ts_allocate_id()函数来告诉 TRSM 自己需要多少资源。TRSM 接收后更新系统使用的资源，并得到一个指向刚分配的那份资源的id。
1typedef struct { 2 int sampleint; 3 char *samplestring; 4} php_sample_globals; 5int sample_globals_id; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 ts_allocate_id(&amp;amp;sample_globals_id, 10 sizeof(php_sample_globals), 11 (ts_allocate_ctor) php_sample_globals_ctor, 12 (ts_allocate_dtor) php_sample_globals_dtor); 13 return SUCCESS; 14} 当一个请求需要访问数据段的时候，扩展从TSRM层请求当前线程的资源池，以ts_allocate_id()返回的资源ID来获取偏移量。换句话说，在代码流中，你可能会在前面所说的MINIT语句中碰到SAMPLE_G(sampleint)=5;这样的语句。在线程安全的构建下，这个语句通过一些宏扩展如下：
1(((php_sample_globals*)(*((void ***)tsrm_ls))[sample_globals_id-1])-&amp;gt;sampleint = 5; 如果你看不懂上面的转换也不用沮丧，它已经很好的封装在PHPAPI中了，以至于许多开发者都不需要知道它怎样工作的。
当不在线程环境时因为在PHP的线程安全构建中访问全局资源涉及到在线程数据池查找对应的偏移量，这是一些额外的负载，结果就是它比对应的非线程方式（直接从编译期已经计算好的真实的全局变量地址中取出数据）慢一些。 考虑上面的例子，这一次在非线程构建下：
1typedef struct { 2 int sampleint; 3 char *samplestring; 4} php_sample_globals; 5php_sample_globals sample_globals; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 php_sample_globals_ctor(&amp;amp;sample_globals TSRMLS_CC); 10 return SUCCESS; 11} 首先注意到的是这里并没有定义一个int型的标识去引用全局的结构定义， 只是简单的在进程的全局空间定义了一个结构体。 也就是说SAMPLE_G(sampleint) = 5;展开后就是sample_globals.</description></item><item><title>PHP扩展开发2.1：PHP生命周期</title><link>https://icorer.com/icorer_blog/en/posts/php-extension-development-2.1-php-lifecycle/</link><pubDate>Fri, 06 Jul 2018 16:14:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/php-extension-development-2.1-php-lifecycle/</guid><description>#1. PHP SAPI 无论是Web模式、FastCgi模式、CLI模式，PHP的工作原理都是一样的，都是作为一种SAPI在运行（Server Application Programming Interface : the API sed by PHP to interface with Web Servers）。当我们在终端敲入php这个命令时候，它使用的是&amp;quot;”command lines api！它就像一个mini的web服务器一样来支持php完成这个请求，请求完成后再重新把控制权交给终端。简单来说,SAPI就是PHP和外部环境的代理器。它把外部环境抽象后,为内部的PHP提供一套固定的,统一的接口,使得PHP自身实现能够不受错综复杂的外部环境影响，保持一定的独立性
#2. PHP的启动与终止 PHP的启动和终止有两层含义，第一层是基于宿主进程、第二层是基于用户请求，前者被称为模块、后者成为请求。
在最初的初始化时候，就是PHP随着Apache的启动而诞生在内存里的时候，它会把自己所有已加载扩展的MINIT方法(全称Module Initialization，是由每个模块自己定义的函数。)都执行一遍。在这个时间里，扩展可以定义一些自己的常量、类、资源等所有会被用户端的PHP脚本用到的东西。但你要记住，这里定义的元素都会随着Apache常驻内存，可以被所有请求使用，直到Apache卸载掉PHP模块！
内核中预置了PHP_MINIT_FUNCTION()宏函数，来帮助我们实现这个功能：
1int minit_startTime = 0 ; 2PHP_MINT_FUNCTION(extension_name){ 3 minit_startTime = time(NULL); 4 php_printf(&amp;#34;%d\n&amp;#34;,minit_startTime); 5 return SUCCESS; 6} 当一个页面请求到来时候，PHP会迅速的开辟一个新的环境，并重新扫描自己的各个扩展，遍历执行它们各自的RINIT方法(俗称Request Initialization)，这时候一个扩展可能会初始化在本次请求中会使用到的变量等，还会初始化等会儿用户端（即PHP脚本）中的变量之类的，内核预置了PHP_RINIT_FUNCTION()这个宏函数来帮我们实现这个功能：
1int rinit_startTime = 0 ; 2PHP_RINIT_FUNCTION(extension_name){ 3 rinit_startTime = time(NULL); 4 php_printf(&amp;#34;%d\n&amp;#34;,rinit_startTime); 5 return SUCCESS; 6} 好了，现在这个页面请求执行的差不多了，可能是顺利的走到了自己文件的最后，也可能是出师未捷，半道被用户给die或者exit了，这时候PHP便会启动回收程序，收拾这个请求留下的烂摊子。它这次会执行所有已加载扩展的RSHUTDOWN（俗称RequestShutdown）方法，这时候扩展可以抓紧利用内核中的变量表之类的做一些事情，因为一旦PHP把所有扩展的RSHUTDOWN方法执行完，便会释放掉这次请求使用过的所有东西，包括变量表的所有变量、所有在这次请求中申请的内存等等。
内核预置了PHP_RSHUTDOWN_FUNCTION宏函数来帮助我们实现这个功能
1PHP_RSHUTDOWN_FUNCTION(extension_name){ 2 FILE*fp=fopen(&amp;#34;time_rshutdown.txt&amp;#34;,&amp;#34;a+&amp;#34;); 3 fprintf(fp,&amp;#34;%ld\n&amp;#34;,time(NULL)); 4 fclose(fp); 5 return SUCCESS; 6} 前面该启动的也启动了，该结束的也结束了，现在该Apache老人家歇歇的时候，当Apache通知PHP自己要Stop的时候，PHP便进入MSHUTDOWN（俗称ModuleShutdown）阶段。这时候PHP便会给所有扩展下最后通牒，如果哪个扩展还有未了的心愿，就放在自MSHUTDOWN方法里，这可是最后的机会了，一旦PHP把扩展的MSHUTDOWN执行完，便会进入自毁程序，这里一定要把自己擅自申请的内存给释放掉，否则就杯具了。</description></item><item><title>研究报告：JAVA 与 Golang 在 UDP服务器上的性能对比</title><link>https://icorer.com/icorer_blog/en/posts/performance-comparison-between-java-and-golang-on-udp-server/</link><pubDate>Tue, 03 Jul 2018 15:43:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/performance-comparison-between-java-and-golang-on-udp-server/</guid><description>背景介绍因工作需求，目前需要采用UDP协议来存储用户日志信息，目前采用了JAVA 和 Golang 两种途径。
#Linux内核优化（非常重要） 可以使用netstat -su 查看UDP是否有错包，如果查看到有UDP receive errors，可以调整UDP缓冲区的大小以应对大规模请求，主要参数如下
1net.core.rmem_max=26214400 2net.core.rmem_default=26214400 #客户端情况介绍 客户端采用PHP语言进行编写，由于PHP底层采用C实现，所以UDP客户端的性能应该算是最佳了，相关代码如下：
1&amp;lt;?php 2$islocalUdp = true; 3$server_ip = &amp;#39;127.0.0.1&amp;#39;; 4$server_port = 10000; 5$message = &amp;#39;loginfo&amp;#39;; 6 7if($islocalUdp){ 8 $socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP); 9 $ret = socket_sendto($socket, $message, strlen($message), 0, $server_ip, $server_port); 10}else{ 11 $message = &amp;#34;$server_ip**$server_port**$message&amp;#34;; 12 13 $ret = sendDataUds ($message,3,&amp;#39;/dev/shm/unix_udp_socks.sock&amp;#39;); 14} 15?&amp;gt; #JAVA服务端介绍 JAVA使用名声很大的Netty 网络包。
#Golang 服务端介绍 Golang服务端采用Net包中的ListenUDP进行程序编写，由于目前没有对大日志进行测试，所以不进行缓冲区中转编程，相关代码如下：
1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;log&amp;#34; 6 &amp;#34;net&amp;#34; 7) 8 9const ( 10 BUF_SIZE = 1024 11) 12 13func main() { 14 udp_addr, err := net.</description></item><item><title>Nginx FAST-CGI缓存优化</title><link>https://icorer.com/icorer_blog/en/posts/nginx-fast-cgi-cache-optimization/</link><pubDate>Sun, 24 Jun 2018 20:42:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/nginx-fast-cgi-cache-optimization/</guid><description>背景描述传统的LNMP架构中，PHP-FPM对于PHP脚本进行解析工作，Nginx反向代理的时候，会把PHP请求转达给PHP-FPM。对于一个PHP站点，PHP-FPM的工作压力很巨大，所以，如果我们在Nginx层面上做一个FAST-CGI缓存，则会大大缓解解析器的压力，达到更好的响应效果。
NGINX 缓存配置1. HTTP层配置 1fastcgi_cache_path /tmp/cache/fastcgi_cache levels=1:2 keys_zone=fastcgi-cache:10m inactive=2d max_size=512m; 2 3fastcgi_cache_key $scheme$request_method$host$request_uri;; 4proxy_buffering on; 5proxy_cache_valid any 10m; 6proxy_temp_path /tmp/cache/tmp; 7proxy_buffer_size 4k; 8proxy_buffers 100 8k; 9fastcgi_cache_lock on; 10fastcgi_cache_use_stale error timeout invalid_header updating http_500; 11fastcgi_ignore_headers Cache-Control Expires Set-Cookie; 这里的key_zone = fastcgi-cache, 就是在server层需要用到的代理zone
2. Server层配置 1location ~ [^/]\.php(/|$) 2{ 3 try_files $uri =404; 4 fastcgi_pass unix:/tmp/php-cgi.sock; 5 fastcgi_index index.php; 6 include fastcgi.conf; 7 add_header PHP-Cache $upstream_cache_status; //添加响应头部 8 fastcgi_cache fastcgi-cache; //设置缓存zone 9 fastcgi_cache_valid 200 60m; 10} 测试总结经过测试，对于实时性要求不是很高的系统，启用了缓存机制后，能够大大提高系统的访问速度，下图是本博客的全国测试结果。</description></item><item><title>源码阅读：C语言epoll模型</title><link>https://icorer.com/icorer_blog/en/posts/source-code-reading-c-language-epoll-model/</link><pubDate>Fri, 08 Jun 2018 18:02:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/source-code-reading-c-language-epoll-model/</guid><description>背景epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。
#模型代码 今天给大家分享一下EPOLL的相关模型代码：
服务端代码 1#include &amp;lt;sys/types.h&amp;gt; 2#include &amp;lt;sys/signalfd.h&amp;gt; 3#include &amp;lt;sys/epoll.h&amp;gt; 4#include &amp;lt;errno.h&amp;gt; 5#include &amp;lt;poll.h&amp;gt; 6#include &amp;lt;signal.h&amp;gt; 7#include &amp;lt;limits.h&amp;gt; 8#include &amp;lt;stdio.h&amp;gt; 9#include &amp;lt;stdlib.h&amp;gt; 10#include &amp;lt;unistd.h&amp;gt; 11#include &amp;lt;fcntl.h&amp;gt; 12#include &amp;lt;string.h&amp;gt; 13#include &amp;lt;assert.h&amp;gt; 14#include &amp;lt;sys/ioctl.h&amp;gt; 15#include &amp;lt;sys/socket.h&amp;gt; 16#include &amp;lt;netinet/in.h&amp;gt; 17#include &amp;lt;arpa/inet.h&amp;gt; 18#include &amp;#34;utarray.h&amp;#34; 19 20/***************************************************************************** 21 * This program demonstrates epoll-based event notification. It monitors for 22 * new client connections, input on existing connections or their closure, as 23 * well as signals.</description></item><item><title>解析 Go 中的函数调用</title><link>https://icorer.com/icorer_blog/en/posts/parsing-function-calls-in-go/</link><pubDate>Fri, 08 Jun 2018 10:17:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/parsing-function-calls-in-go/</guid><description>让我们来看一些简单的 Go 的函数，然后看看我们能否明白函数调用是怎么回事。我们将通过分析 Go 编译器根据函数生成的汇编来完成这件事。对于一个小小的博客来讲，这样的目标可能有点不切实际，但是别担心，汇编语言很简单。哪怕是 CPU 都能读懂。
这是我们的第一个函数。对，我们只是让两个数相加。 1func add(a, b int) int { 2 return a + b 3} 我们编译的时候需要关闭优化，这样方便我们去理解生成的汇编代码。我们用 go build -gcflags 'N -l' 这个命令来完成上述操作。然后我们可以用 go tool objdump -s main.add func 输出我们函数的具体细节（这里的 func 是我们的包名，也就是我们刚刚用 go build 编译出的可执行文件）。
如果你之前没有学过汇编，那么恭喜你，你将接触到一个全新的事物。另外我会在 Mac 上完成这篇博客的代码，因此所生成的是 Intel 64-bit 汇编。
1 main.go:20 0x22c0 48c744241800000000 MOVQ $0x0, 0x18(SP) 2 main.go:21 0x22c9 488b442408 MOVQ 0x8(SP), AX 3 main.go:21 0x22ce 488b4c2410 MOVQ 0x10(SP), CX 4 main.go:21 0x22d3 4801c8 ADDQ CX, AX 5 main.</description></item><item><title>Pecl_Http 与 unix domain socket 客户端封装</title><link>https://icorer.com/icorer_blog/en/posts/pecl_http-and-unix-domain-socket-client-package/</link><pubDate>Tue, 05 Jun 2018 09:44:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/pecl_http-and-unix-domain-socket-client-package/</guid><description>1. 背景描述Pecl/HTTP是一个PHP扩展，历史非常悠久了，从2005年至2018年不断完善其功能，它主要帮助PHP对于HTTP请求的相关操作。不同于CURL，其具有更丰富的扩展接口，既包括平常的请求，也包括对于HTTP数据的封包或拆包操作。
对于PHP和HTTP，大部分程序员关心的如何完成一个请求。但是更深一步，我们会发现HTTP数据包的文件格式也很重要，比如传统的HTTP请求性能很弱，对于请求密集型业务，传统的HTTP并不能达到很好的RPS，就算是开启了Keep-Alive，性能还是很弱。对于这种情况，我们失望的是HTTP请求，而不是HTTP的数据包格式，所以我们可以在数据封包拆包上继续使用HTTP协议，但是对于数据传输这层，我们可以采用性能更高的一些通路，比如Unix domain socket。
2. 研究难点HTTP的通信协议数据包格式总体来说并不复杂，但是为了便于系统研发及维护，一般都站在巨人的肩膀上进行研发，目前针对PHP进行数据拆包与封包的库很少。一方面我们可以从网上比较火的一些Http Client库中抽取相关的调用层，另一方面我们可以从pecl中找寻一些扩展库，基于pecl的扩展库都是基于C语言进行的研发，性能更强，而且安装也很方便。
在本文中，我们主要围绕Pecl/HTTP库进行相关阐述，在接下来的文章中，我们也会专门围绕Guzzle或者更合适的PHP库来讲解数据包的装包和拆包。
3. HTTP数据包：封包-拆包3.1 扩展类设计思路本文主要讲解HTTP数据包的封包和拆包操作，我们首先封装一个HTTP数据包相关接口，接口主要包括对于Get、Post的封包；对于数据包的解包操作。
1&amp;lt;?php 2interface HttpPack{ 3 public function encodeGetPack($url,$header); 4 public function encodePostPack($url,$header,$body); 5 public function decodePack($packStr); 6} 7?&amp;gt; 随后，我们定义了一个SimpleTun类来实现这个接口，具体函数实现在各节详细描述，此处为框架代码。 1&amp;lt;?php 2class SimpleTun implements HttpPack 3{ 4 public function encodeGetPack($url, $header) 5 { 6 // TODO: Implement encodeGetPack() method. 7 8 } 9 10 public function encodePostPack($url, $header, $body) 11 { 12 // TODO: Implement encodePostPack() method. 13 } 14 15 public function decodePack($packStr) 16 { 17 // TODO: Implement decodePack() method.</description></item></channel></rss>