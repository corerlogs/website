<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>性能测试 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/en/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link><description>Recent content in 性能测试 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 22 Feb 2019 13:40:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/en/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>Curl-VS-Guzzle 性能测试</title><link>https://icorer.com/icorer_blog/en/posts/curl-vs-guzzle-performance-test/</link><pubDate>Fri, 22 Feb 2019 13:40:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/curl-vs-guzzle-performance-test/</guid><description>Curl-VS-Guzzle 性能测试这里项目围绕Curl 和 Guzzle这两个HTTP请求组件进行一些压力测试,看一下性能差距.我们围绕两个组件的连接复用情况来测试.(文章中会强调opcache的作用)
一. 测试阐述 测试curl和guzzle在连接复用情况下的性能差别 (guzzle不开启opcache) 测试curl和guzzle在连接复用情况下的性能差别 (guzzle开启opcache) 二. 性能测试过程2.1 测试条件 在相同的Nginx,PHP,LibCurl库环境 测试脚本包含curl对象的复用,每次测试请求执行10次外部http请求 2.2 Guzzle测试代码 1//GuzzleClient.php 2use \GuzzleHttp\Client; 3class GuzzleClient 4{ 5 protected static $guzzleClientConnection = null; 6 7 public static function getGuzzleClient($baseUrl, $persistent = true) 8 { 9 if (!$persistent || !self::$guzzleClientConnection) { 10 self::$guzzleClientConnection = new Client([&amp;#39;base_uri&amp;#39; =&amp;gt; $baseUrl]); 11 } 12 13 return self::$guzzleClientConnection; 14 } 15 16} 17 18//get_loop_simple.php 内部循环调用多次 19for ($i=0;$i&amp;lt;10;$i++){ 20 try { 21 //获取Client静态变量,复用curl单体 22 $client = GuzzleClient::getGuzzleClient(&amp;#34;http://127.</description></item><item><title>测试报告：HTTP Post 与 Unix Domain Socket 通信性能对比</title><link>https://icorer.com/icorer_blog/en/posts/test-report-comparison-of-communication-performance-between-http-post-and-unix-domain-socket/</link><pubDate>Mon, 28 May 2018 09:35:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/test-report-comparison-of-communication-performance-between-http-post-and-unix-domain-socket/</guid><description>&lt;h2 id="背景描述">背景描述&lt;a class="anchorjs-link" href="#%e8%83%8c%e6%99%af%e6%8f%8f%e8%bf%b0">&lt;/a>&lt;/h2>&lt;p>因工作需求，项目需要在不同的程序语言框架中进行通信，目前对于进程通信的方式，互联网上主要有HTTP请求、IPC通信、Socket通信、共享内存通信，虽然共享内存效率最高，但是对于内存结构的设计与队列维持需要很高的系统实现能力，所以目前我测试了HTTP与Unix Socket这两种通信方案。&lt;/p>
&lt;h2 id="测试环境搭建">测试环境搭建&lt;a class="anchorjs-link" href="#%e6%b5%8b%e8%af%95%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba">&lt;/a>&lt;/h2>&lt;p>目前分为HTTP和Unix Socket通信两种测试环境，为了保持测试环境尽量统一，我们请求端用PHP语言、接受信息端用Go语言。
测试软件使用 Jmeter 4.0
操作系统：Centos 7
硬件条件：I5 CPU、8GB内存&lt;/p></description></item><item><title>Jmeter测试报表相关参数说明</title><link>https://icorer.com/icorer_blog/en/posts/jmeter-test-report-related-parameter-description/</link><pubDate>Fri, 18 May 2018 11:26:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/jmeter-test-report-related-parameter-description/</guid><description>背景介绍采用Jmeter测试工具对web系统作的负载测试，得出的响应报表，数据比较难懂，现作一具体说明。
以下是在一次具体负载测试中得出的具体数值，测试线程设置情况为：线程数：200，等待时间（ramp-up）：0秒，循环次数为永远，另：
线程组——这些元件用于指定运行的线程数和等候周期。每个线程模拟一个用户，而等候周期用于指定创建全部线程的时间。例如，线程数为5，等候时间为10秒，则创建每个线程之间的时间间隔为2秒。循环数定义了线程的运行时间。使用调度器，还可以设置运行的起始时间。 取样器——对于服务器HTTP、FTP或LDAP请求，这些元件是可配置请求。该教程仅侧重于Web Services请求。 监听器——这些元件用于请求数据的后期处理。例如，可以将数据保存到文件或用图表来说明结果。此时JMeter图表并没有提供许多配置选项；然而它是可扩展的，它始终可以添加额外的可视化效果或数据处理模块。 一、图形报表 图表底部参数的含义如下： 样本数目是总共发送到服务器的请求数。 最新样本是代表时间的数字,是服务器响应最后一个请求的时间。 吞吐量是服务器每分钟处理的请求数。 平均值是总运行时间除以发送到服务器的请求数。 中间值是代表时间的数字，有一半的服务器响应时间低于该值而另一半高于该值。 偏离表示服务器响应时间变化、离散程度测量值的大小，或者，换句话说，就是数据的分布。 二、 聚合报告 图表含义说明如下：
Label：说明是请求类型，如Http，FTP等请求。 Samples：也就是图形报表中的样本数目，总共发送到服务器的样本数目。 Average：也就是图形报表中的平均值，是总运行时间除以发送到服务器的请求数。 Median：也就是图形报表中的中间值，是代表时间的数字，有一半的服务器响应时间低于该值而另一半高于该值。 90%line：是指90%请求的响应时间比所得数值还要小。 Min：是代表时间的数字,是服务器响应的最短时间。 Max: 是代表时间的数字,是服务器响应的最长时间。 Error%:请求的错误百分比。 Throughput:也就是图形报表中的吞吐量，这里是服务器每单位时间处理的请求数，注意查看是秒或是分钟。 KB/sec:是每秒钟请求的字节数。 三、 使用分析在测试过程中，平均响应时间是我们性能测试的一个重要衡量指标，但是在测试中，特别是在聚合报告中，得出的90%Line,我这里参考《《LoadRunner 没有告诉你的》之一——描述性统计与性能结果分析》，我认为90%Line等同于该文作者提出的90%响应时间,这个数值对我们性能测试分析也很有参考价值。90%响应时间是说在发送的请求中，90%的用户响应时间都比得到的数值上要短，同时说明，一个系统在应用时，90%的用户响应时间都能达到这个数值，那么就为系统性能分析提供了很好的参考价值。
原文链接： https://blog.</description></item></channel></rss>