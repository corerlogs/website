<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CLang on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/en/tags/clang/</link><description>Recent content in CLang on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 09 Jul 2018 16:56:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/en/tags/clang/index.xml" rel="self" type="application/rss+xml"/><item><title>编程笔记：C语言回调函数</title><link>https://icorer.com/icorer_blog/en/posts/programming-notes-c-language-callback-function/</link><pubDate>Mon, 09 Jul 2018 16:56:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/programming-notes-c-language-callback-function/</guid><description>在计算机程序设计中，回调函数，或简称回调（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。 假设我们要使用一个排序函数来对数组进行排序，那么在主程序(Main program)中，我们先通过库，选择一个库排序函数(Library function)。但排序算法有很多，有冒泡排序，选择排序，快速排序，归并排序。同时，我们也可能需要对特殊的对象进行排序，比如特定的结构体等。库函数会根据我们的需要选择一种排序算法，然后调用实现该算法的函数来完成排序工作。这个被调用的排序函数就是回调函数(Callback function)。
结合这幅图和上面对回调函数的解释，我们可以发现，要实现回调函数，最关键的一点就是要将函数的指针传递给一个函数(上图中是库函数)，然后这个函数就可以通过这个指针来调用回调函数了。注意，回调函数并不是C语言特有的，几乎任何语言都有回调函数。在C语言中，我们通过使用函数指针来实现回调函数。那函数指针是什么？不着急，下面我们就先来看看什么是函数指针。
什么是函数指针函数指针也是一种指针，只是它指向的不是整型，字符型而是函数。在C中，每个函数在编译后都是存储在内存中，并且每个函数都有一个入口地址，根据这个地址，我们便可以访问并使用这个函数。函数指针就是通过指向这个函数的入口，从而调用这个函数。
函数指针的使用函数指针的定义函数指针虽然也是指针，但它的定义方式却和其他指针看上去很不一样，我们来看看它是如何定义的：
1/* 方法1 */ 2void (*p_func)(int, int, float) = NULL; 3 4/* 方法2 */ 5typedef void (*tp_func)(int, int, float); 6tp_func p_func = NULL; 这两种方式都是定义了一个指向返回值为 void 类型，参数为 (int, int, float) 的函数指针。第二种方法是为了让函数指针更容易理解，尤其是在复杂的环境下；而对于一般的函数指针，直接用第一种方法就行了。 如果之前没见过函数指针，可能会觉得函数指针的定义比较怪，为什么不是 void ()(int, int, float)*p_func 而是 void (*p_func)(int, int, float) 这种形式？这个问题我也不知道，也没必要纠结，花点时间理解下它与普通指针的区别，实在不行就先记住它的形式。
函数指针的赋值在定义完函数指针后，我们就需要给它赋值了我们有两种方式对函数指针进行赋值：
1void (*p_func)(int, int, float) = NULL; 2p_func = &amp;amp;func1; 3p_func = func2; 上面两种方法都是合法的，对于第二种方法，编译器会隐式地将 func_2 由 void ()(int, int, float) 类型转换成 void (*)(int, int, float) 类型，因此，这两种方法都行。</description></item><item><title>源码阅读：C语言epoll模型</title><link>https://icorer.com/icorer_blog/en/posts/source-code-reading-c-language-epoll-model/</link><pubDate>Fri, 08 Jun 2018 18:02:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/en/posts/source-code-reading-c-language-epoll-model/</guid><description>背景epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。
#模型代码 今天给大家分享一下EPOLL的相关模型代码：
服务端代码 1#include &amp;lt;sys/types.h&amp;gt; 2#include &amp;lt;sys/signalfd.h&amp;gt; 3#include &amp;lt;sys/epoll.h&amp;gt; 4#include &amp;lt;errno.h&amp;gt; 5#include &amp;lt;poll.h&amp;gt; 6#include &amp;lt;signal.h&amp;gt; 7#include &amp;lt;limits.h&amp;gt; 8#include &amp;lt;stdio.h&amp;gt; 9#include &amp;lt;stdlib.h&amp;gt; 10#include &amp;lt;unistd.h&amp;gt; 11#include &amp;lt;fcntl.h&amp;gt; 12#include &amp;lt;string.h&amp;gt; 13#include &amp;lt;assert.h&amp;gt; 14#include &amp;lt;sys/ioctl.h&amp;gt; 15#include &amp;lt;sys/socket.h&amp;gt; 16#include &amp;lt;netinet/in.h&amp;gt; 17#include &amp;lt;arpa/inet.h&amp;gt; 18#include &amp;#34;utarray.h&amp;#34; 19 20/***************************************************************************** 21 * This program demonstrates epoll-based event notification. It monitors for 22 * new client connections, input on existing connections or their closure, as 23 * well as signals.</description></item></channel></rss>