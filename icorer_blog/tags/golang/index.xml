<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GoLang on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/golang/</link><description>Recent content in GoLang on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 24 Dec 2019 13:18:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 十年</title><link>https://icorer.com/icorer_blog/posts/ten-years-of-go/</link><pubDate>Tue, 24 Dec 2019 13:18:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/ten-years-of-go/</guid><description>Russ Cox，代表Go团队
2019年11月8日
Happy birthday, Go!
这个周末，我们庆祝Go发布10周年，庆祝Go作为一种开源编程语言和构建现代网络软件的生态系统的10周年。
为了纪念这一时刻，Go gopher的创始人蕾妮·弗兰奇描绘了这一令人愉快的场景:
庆祝Go十周年让我回想起2009年11月上旬，那时我们正准备与世界分享Go。 我们不知道会有什么样的反应，也不知道是否有人会关心这种小小的语言。我希望，即使没有人最终使用Go，我们至少也会注意到一些好的想法，特别是Go的并发性和接口方法，它们可能会影响后续语言。
当人们对Go感到兴奋的时候，我研究了流行语言的历史，比如C、C++、Perl、Python和Ruby，考察了它们被广泛采用所花的时间。例如，在我看来，Perl似乎在上世纪90年代中后期就已经完全成形了，有了CGI脚本和web，但它是在1987年首次发布的。这一模式几乎适用于我所研究的每一种语言:一种新的语言要真正起飞，似乎需要大约十年的安静、稳定的改进和传播。
我在想:十年后会是什么样子?
今天，我们可以回答这个问题:Go无处不在，全世界至少有一百万开发者在使用它。
Go最初的目标是网络系统基础设施，也就是我们现在所说的云软件。如今，每个主要的云提供商都使用用Go编写的核心云基础设施，如Docker、Etcd、Istio、Kubernetes、Prometheus和Terraform;云计算基金会的大多数项目都是用Go编写的。无数的公司也在使用Go将他们自己的工作转移到云上，从从无到有的创业公司到现代化软件栈的企业。Go的应用范围也远远超出了它最初的云目标，从使用GoBot和TinyGo来控制微型嵌入式系统，到使用GRAIL进行大规模的大数据分析和机器学习来检测癌症，以及两者之间的一切。
所有这一切都说明，Go的成功超乎我们的想象。Go的成功不仅仅在于语言。它是关于语言，生态系统，特别是社区的合作。
在2009年，该语言是一个不错的主意，并带有一个实现的工作草图。 go命令不存在：我们运行了诸如6g的命令进行编译，并运行了6l的命令来链接二进制文件，这些命令使用makefiles自动执行。 我们在语句末尾键入分号。 整个程序在垃圾回收期间停止，然后努力利用两个内核。 Go只能在Linux和Mac，32位和64位x86和32位ARM上运行。
在过去的十年里，在全球Go开发人员的帮助下，我们已经将这个想法和草图发展成为一种富有成效的语言，它具有出色的工具、高质量的产品实现、最先进的垃圾收集器以及12个操作系统和10个体系结构支持。
任何编程语言都需要蓬勃发展的生态系统的支持。 开源版本是该生态系统的种子，但是从那时起，许多人贡献了自己的时间和才干，用出色的教程，书籍，课程，博客文章，播客，工具，集成以及可重复使用的Go来填充Go生态系统。 可通过go get导入的软件包。 没有这个生态系统的支持，Go永远不可能成功。
当然，生态系统需要蓬勃发展的社区的支持。 在2019年，全球有数十个Go会议，以及超过90个成员超过150个Go会议团体。GoBridge和Going Who Go通过指导，培训和会议奖学金帮助将新的声音带入Go社区。仅今年一年，他们就在社区成员教授和指导新加入者的研讨会上，教育了数百名来自传统代表性不足群体的人。
全球有超过一百万的Go开发人员，全球各地的公司都在寻求雇用更多的人。 实际上，人们经常告诉我们，学习Go帮助他们获得了技术行业的第一份工作。 最后，我们为Go感到最自豪的不是设计完善的功能或巧妙的代码，而是Go在这么多人的生活中产生的积极影响。我们的目标是创造一种语言，帮助我们成为更好的开发人员，我们很高兴Go帮助了这么多人。
作为＃GoTurns10，我希望每个人都花一点时间来庆祝Go社区以及我们所取得的一切。 代表Google的整个Go团队，感谢过去十年来加入我们的每个人。 让下一个更不可思议！
Original URL : https://blog.golang.org/10years</description></item><item><title>Go的垃圾收集者之旅 [Getting to Go: The Journey of Go's Garbage Collector]</title><link>https://icorer.com/icorer_blog/posts/getting-to-go-the-journey-of-gos-garbage-collector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://icorer.com/icorer_blog/posts/getting-to-go-the-journey-of-gos-garbage-collector/</guid><description>一 . 背景介绍这篇文章是一片演讲笔记，这是Richard L. Hudson于2018.06.18在国际内存管理研讨会(ISMM)上的演讲。
理查德·哈德森（Rick）因其在内存管理方面的工作而闻名，其中包括发明了Train，Sapphire和Mississippi Delta算法以及GC堆栈映射，这些算法能够以静态类型的语言（例如Modula-3，Java）进行垃圾收集 ，C＃和Go。 Rick目前是Google Go团队的成员，他致力于Go的垃圾回收和运行时问题。
Original URL : https://blog.golang.org/ismmkeynote
二. 演讲内容 在我们正式研究这些东西之前，我们首先需要展示一下GC在Go中看着像什么？
首先，Go程序有成千上万个堆栈，他们被Go调度器管理着并且总是在GC安全点被抢占。Go调度器将Go协程多路复用到系统线程上，希望每一个物理线程运行一个系统线程。我们通过复制堆栈和修改栈指针来管理栈及其大小。因为这些是本地操作所以很容易扩展。
接下来，我们需要讨论一个重要的内容，和传统C系统语言类似、Go也是一种“值定向”语言，而不是类似众多runtime管理型语言的“参考导向”语言。正如上面的例子展示了tar包中某一个类型如何在内存中布局存储，所有的字段均直接内嵌在Reader变量中。这使程序员可以在需要的时候更好的控制内存布局。可以把有关联值的字段进行临近分配，这样的策略有利于提高缓存的存储位置。
以值为导向有助于使用外部功能接口(有助于不同语言之间通信)，Go语言和C/C++语言能够很快的FFI (语言交互接口 ) 操作，谷歌内部有大量可用的功能、但是他们使用C++编写的。Go语言迫不及待的实现这些功能，因此Go必须使用外部功能访问接口来实现这些功能。
基于这个设计上的决定导致Go运行时必须执行一些惊人的东西，这些可能是Go和其他带有GC的计算机语言最重要的不同之处。
Go语言当然会有指针的存在，但是事实上Go甚至可以有内部指针[ interior pointer ]。这些指针可以让数据的整体具有活性，而且他们很常见。
Go语言有一套完善的预编译系统，从而一个单独的二进制运行体文件就可以包含完整的运行时环境。
运行时也不需要JIT热点重新编译，这有优点也有缺点。首先，这种模式下程序执行的可重现性要容易很多，这使得编译器改进的步伐变得更快。
可悲的是，我们没有机会像使用JITed系统那样可以反馈优化。因此，静态预编译存在上述优缺点。
Go 提供了两个旋钮用来控制GC。第一个是GCPercent，这个旋钮基本上是用来调整要使用的CPU和内存的数量，默认值为100、代表一半的堆专用于活动内存、一半的堆用来分配。当然，你可以按照你需要的比例方向就行旋钮调整。
最大堆，这个属性目前尚未发布、但已经在内部使用和评估了，这个参数允许编程人员控制最大的堆使用空间。内存不足、内存溢出(OOM)、在Go语言上很难；暂时的内存使用高峰应该通过增加CPU成本来解决，不是通过终止程序。基本上，如果GC遇到了内存压力，它应该通知应用程序应该减轻负载。当一切恢复正常之后，GC会通知应用程序让其恢复到正常负载。最大堆特性还为调度提供更多的灵活性。运行时不必总是对可用的内存量有多大的幻想，而是可以将堆的大小调整为最大堆的大小。
这结束了我们对垃圾回收器很重要的Go片段的讨论。
现在让我们来谈谈Go语言运行时以及我们如何到达这里，如何达到自己所在的位置。这句话是演讲者想表达Go运行时GC是如何一路发展的。
2014年，毫无疑问、如果Go不能以某种方式解决GC延迟问题，则Go是不会成功的。
其他新语言也会遇到同样的问题。Rust之类的语言采用了不通的解决方式，但是这里我们将讲述Go所走的道路。
为什么延迟如此的重要？
延迟是个累积量，数学对此是不能完全解释的。
99%的隔离式GC延迟服务级别目标(SLO)，例如 99% 的GC周期小于10ms，只是根本无法扩展。重要的是整个会话期间的延迟或一天中多次使用程序的延迟（这里表达的含义是：单次GC看着不重，但是无论对于单次长会话、还是长期运行的程序体，这会产生累计损害）。假设浏览一个网页的会话在一个会话中最终发出100个服务器请求，或者发出20个请求，并且一天中您有5个会话。 在这种情况下，只有37％的用户将在整个会话中获得一致的10毫秒以下体验。
正如我们所建议的那样，如果您希望这些用户中有99％的用户具有10ms以下的体验，则数学计算表明您确实需要定位4个9s或99.99％ile。
所以是2014年，杰夫·迪恩（Jeff Dean）发表了他的论文《The Tail at Scale》(规模的尾巴)，进一步探讨了这一问题。 由于它对Google的向前发展和试图以Google规模扩展产生严重影响，因此在Google周围被广泛阅读。
我们称这个问题为9s暴政。
那么，我们是如何对抗这场“暴政”的呢？
我们在2014年做了不少事情。
如果您想要10个答案，请再输入几个，然后选择前10个，这些就是您在搜索页面上输入的答案。如果请求超过50％ile，则重新发出请求或将请求转发到另一台服务器。 如果GC将要运行，请拒绝新请求或将请求转发到另一台服务器，直到完成GC。 依此类推。这段文字讲述的是类似负载均衡模式降低系统整体的响应时间。
所有这些变通办法来自非常聪明的人，他们有非常实际的问题，但他们没有解决GC延迟的根本问题。 在Google规模上，我们必须解决根本问题。 为什么？
冗余无法扩展，冗余成本很高。 它花费了新的服务器场。
我们希望能够解决这个问题，并把它看作是一个改善服务器生态系统的机会，并在这个过程中拯救一些濒临灭绝的玉米田，让一些玉米粒有机会在7月4日达到膝盖高点，让玉米更好的生长。 （这段话的意思就是，希望通过节约服务器机房成本而保护环境。）
这就是2014年的SLO，是的，的确，我在打沙袋，在团队中我是新手，这对我来说是个新过程，我不想过分承诺。(这张PPT展示了2014年的GC能力)
此外，有关其他语言的GC延迟的演讲简直令人恐惧。
最初的计划是执行无读屏障的并发复制GC。 那是长期计划。 读屏障的开销存在很多不确定性，因此Go希望避免这些屏障。
但是在2014年短期，我们必须采取行动。我们必须将所有运行时和编译器都转换为Go。它们当时是用C编写的。没有更多的C语言了，因为C语言程序员不了解GC，但是对如何复制字符串有了一个很酷的想法，因此不再有很多错误。我们需要专注与GC延迟领域的技术方案或任何东西，但是这些东西带来的性能损失必须小于编译器提供的加速。因此我们受到了限制。基本上，我们花费一年在编译器性能上的改进，可以被GC并发协程消耗完。就是这样。 我们不能放慢Go程序的速度。 这在2014年将是站不住脚的。（艰苦的2014年）</description></item></channel></rss>