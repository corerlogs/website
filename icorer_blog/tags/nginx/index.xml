<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nginx on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/nginx/</link><description>Recent content in Nginx on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 24 Jun 2018 20:42:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/nginx/index.xml" rel="self" type="application/rss+xml"/><item><title>Nginx FAST-CGI缓存优化</title><link>https://icorer.com/icorer_blog/posts/nginx-fast-cgi-cache-optimization/</link><pubDate>Sun, 24 Jun 2018 20:42:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/nginx-fast-cgi-cache-optimization/</guid><description>背景描述传统的LNMP架构中，PHP-FPM对于PHP脚本进行解析工作，Nginx反向代理的时候，会把PHP请求转达给PHP-FPM。对于一个PHP站点，PHP-FPM的工作压力很巨大，所以，如果我们在Nginx层面上做一个FAST-CGI缓存，则会大大缓解解析器的压力，达到更好的响应效果。
NGINX 缓存配置1. HTTP层配置 1fastcgi_cache_path /tmp/cache/fastcgi_cache levels=1:2 keys_zone=fastcgi-cache:10m inactive=2d max_size=512m; 2 3fastcgi_cache_key $scheme$request_method$host$request_uri;; 4proxy_buffering on; 5proxy_cache_valid any 10m; 6proxy_temp_path /tmp/cache/tmp; 7proxy_buffer_size 4k; 8proxy_buffers 100 8k; 9fastcgi_cache_lock on; 10fastcgi_cache_use_stale error timeout invalid_header updating http_500; 11fastcgi_ignore_headers Cache-Control Expires Set-Cookie; 这里的key_zone = fastcgi-cache, 就是在server层需要用到的代理zone
2. Server层配置 1location ~ [^/]\.php(/|$) 2{ 3 try_files $uri =404; 4 fastcgi_pass unix:/tmp/php-cgi.sock; 5 fastcgi_index index.php; 6 include fastcgi.conf; 7 add_header PHP-Cache $upstream_cache_status; //添加响应头部 8 fastcgi_cache fastcgi-cache; //设置缓存zone 9 fastcgi_cache_valid 200 60m; 10} 测试总结经过测试，对于实时性要求不是很高的系统，启用了缓存机制后，能够大大提高系统的访问速度，下图是本博客的全国测试结果。</description></item></channel></rss>