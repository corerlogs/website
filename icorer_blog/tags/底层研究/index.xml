<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>底层研究 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/</link><description>Recent content in 底层研究 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 22 Feb 2019 13:40:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>Curl-VS-Guzzle 性能测试</title><link>https://icorer.com/icorer_blog/posts/curl-vs-guzzle-performance-test/</link><pubDate>Fri, 22 Feb 2019 13:40:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/curl-vs-guzzle-performance-test/</guid><description>Curl-VS-Guzzle 性能测试这里项目围绕Curl 和 Guzzle这两个HTTP请求组件进行一些压力测试,看一下性能差距.我们围绕两个组件的连接复用情况来测试.(文章中会强调opcache的作用)
一. 测试阐述 测试curl和guzzle在连接复用情况下的性能差别 (guzzle不开启opcache) 测试curl和guzzle在连接复用情况下的性能差别 (guzzle开启opcache) 二. 性能测试过程2.1 测试条件 在相同的Nginx,PHP,LibCurl库环境 测试脚本包含curl对象的复用,每次测试请求执行10次外部http请求 2.2 Guzzle测试代码 1//GuzzleClient.php 2use \GuzzleHttp\Client; 3class GuzzleClient 4{ 5 protected static $guzzleClientConnection = null; 6 7 public static function getGuzzleClient($baseUrl, $persistent = true) 8 { 9 if (!$persistent || !self::$guzzleClientConnection) { 10 self::$guzzleClientConnection = new Client([&amp;#39;base_uri&amp;#39; =&amp;gt; $baseUrl]); 11 } 12 13 return self::$guzzleClientConnection; 14 } 15 16} 17 18//get_loop_simple.php 内部循环调用多次 19for ($i=0;$i&amp;lt;10;$i++){ 20 try { 21 //获取Client静态变量,复用curl单体 22 $client = GuzzleClient::getGuzzleClient(&amp;#34;http://127.</description></item><item><title>IO读取缓冲器-BufReader</title><link>https://icorer.com/icorer_blog/posts/io-read-buffer-bufreader/</link><pubDate>Thu, 03 Jan 2019 16:59:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/io-read-buffer-bufreader/</guid><description>一. IO问题思考IO读取缓冲器,顾名思义就是针对系统的IO读取操作添加一层缓冲层,有这层缓冲层到底有啥好处呢?针对这个问题,我先问大家以下几个问题.
对于IO读取操作,无论针对的是对象,还是针对网络,每次IO操作均需要陷入内核调用,频繁内核调用会严重影响性能,请问有没有什么办法优化这部分? 针对网络IO读取过程,网络时好时坏,如何让网络IO能够发挥最大的性能潜力,在网络好的时候抓紧多读,在网络差的时候适当少读? 对于文件读取,和网络短连接读取,我们可以很快的根据EOF来结束io连接,但是对于网络长连接,我们无法即使获取到IO的EOF事件,我们该如何避免数据包读取过程的最终状态判断造成的延时问题? 如何提高文件读取,网络读取的内存使用率? 针对上面三个问题,我们均可以使用IO读取缓冲器来解决.
二. 无IO缓冲器IO无用户态缓冲器下,[数据源]和[数据接收端]这两方之间通过程序语言提供的IO API进行数据通信,这种通信模式图如下:
从上图可以看到
三. 缓冲器作用缓冲器建立在传统IO对象上,在传统的IO操作基础上,我们不立刻把读取到的数据传达给调用层代码,而是放进内存缓冲区,并启动针对缓冲区的两个指针(写入指针,读取指针).
相关的模型图如下:</description></item></channel></rss>