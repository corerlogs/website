<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>底层研究 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/</link><description>Recent content in 底层研究 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 22 Feb 2019 13:40:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>Curl-VS-Guzzle 性能测试</title><link>https://icorer.com/icorer_blog/posts/curl-vs-guzzle-performance-test/</link><pubDate>Fri, 22 Feb 2019 13:40:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/curl-vs-guzzle-performance-test/</guid><description>Curl-VS-Guzzle 性能测试这里项目围绕Curl 和 Guzzle这两个HTTP请求组件进行一些压力测试,看一下性能差距.我们围绕两个组件的连接复用情况来测试.(文章中会强调opcache的作用)
一. 测试阐述 测试curl和guzzle在连接复用情况下的性能差别 (guzzle不开启opcache) 测试curl和guzzle在连接复用情况下的性能差别 (guzzle开启opcache) 二. 性能测试过程2.1 测试条件 在相同的Nginx,PHP,LibCurl库环境 测试脚本包含curl对象的复用,每次测试请求执行10次外部http请求 2.2 Guzzle测试代码 1//GuzzleClient.php 2use \GuzzleHttp\Client; 3class GuzzleClient 4{ 5 protected static $guzzleClientConnection = null; 6 7 public static function getGuzzleClient($baseUrl, $persistent = true) 8 { 9 if (!$persistent || !self::$guzzleClientConnection) { 10 self::$guzzleClientConnection = new Client([&amp;#39;base_uri&amp;#39; =&amp;gt; $baseUrl]); 11 } 12 13 return self::$guzzleClientConnection; 14 } 15 16} 17 18//get_loop_simple.php 内部循环调用多次 19for ($i=0;$i&amp;lt;10;$i++){ 20 try { 21 //获取Client静态变量,复用curl单体 22 $client = GuzzleClient::getGuzzleClient(&amp;#34;http://127.</description></item><item><title>IO读取缓冲器-BufReader</title><link>https://icorer.com/icorer_blog/posts/io-read-buffer-bufreader/</link><pubDate>Thu, 03 Jan 2019 16:59:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/io-read-buffer-bufreader/</guid><description>一. IO问题思考IO读取缓冲器,顾名思义就是针对系统的IO读取操作添加一层缓冲层,有这层缓冲层到底有啥好处呢?针对这个问题,我先问大家以下几个问题.
对于IO读取操作,无论针对的是对象,还是针对网络,每次IO操作均需要陷入内核调用,频繁内核调用会严重影响性能,请问有没有什么办法优化这部分? 针对网络IO读取过程,网络时好时坏,如何让网络IO能够发挥最大的性能潜力,在网络好的时候抓紧多读,在网络差的时候适当少读? 对于文件读取,和网络短连接读取,我们可以很快的根据EOF来结束io连接,但是对于网络长连接,我们无法即使获取到IO的EOF事件,我们该如何避免数据包读取过程的最终状态判断造成的延时问题? 如何提高文件读取,网络读取的内存使用率? 针对上面三个问题,我们均可以使用IO读取缓冲器来解决.
二. 无IO缓冲器IO无用户态缓冲器下,[数据源]和[数据接收端]这两方之间通过程序语言提供的IO API进行数据通信,这种通信模式图如下:
从上图可以看到
三. 缓冲器作用缓冲器建立在传统IO对象上,在传统的IO操作基础上,我们不立刻把读取到的数据传达给调用层代码,而是放进内存缓冲区,并启动针对缓冲区的两个指针(写入指针,读取指针).
相关的模型图如下:</description></item><item><title>源码阅读：YAF框架系列文章(3) - (yaf_application.c)</title><link>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-3-yaf_application.c/</link><pubDate>Thu, 22 Nov 2018 15:33:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-3-yaf_application.c/</guid><description>这个文件主要围绕Yaf_Application类的注册，这里，按照倒叙的方式来进行讲解。
一、注册yaf_application类
1YAF_STARTUP_FUNCTION(application) { 2//定义一个zend_class_entry实例变量 3 zend_class_entry ce; 4 5/* 初始化一个CLASS ENTRY 6#define YAF_INIT_CLASS_ENTRY(ce, name, name_ns, methods) \ 7 if(YAF_G(use_namespace)) { \ 8 INIT_CLASS_ENTRY(ce, name_ns, methods); \ 9 } else { \ 10 INIT_CLASS_ENTRY(ce, name, methods); \ 11 } 12*/ 13 YAF_INIT_CLASS_ENTRY(ce, &amp;#34;Yaf_Application&amp;#34;, &amp;#34;Yaf\\Application&amp;#34;, yaf_application_methods); 14 15 // https://src.icorer.com/xref/php-src/Zend/zend_API.c#2752 16 //注册一个类到内核类表中 17 yaf_application_ce = zend_register_internal_class_ex(&amp;amp;ce, NULL); 18 //修改类属性为终极类 19 yaf_application_ce-&amp;gt;ce_flags |= ZEND_ACC_FINAL; 20 21 //声明一个属性定义，为Protected类型 22 zend_declare_property_null(yaf_application_ce, 23 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_CONFIG), ZEND_ACC_PROTECTED); 24 zend_declare_property_null(yaf_application_ce, 25 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_DISPATCHER), ZEND_ACC_PROTECTED); 26 27 //声明一个NULL元素，为static protected类型 28 zend_declare_property_null(yaf_application_ce, 29 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_APP), ZEND_ACC_STATIC | ZEND_ACC_PROTECTED); 30 zend_declare_property_null(yaf_application_ce, 31 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_MODULES), ZEND_ACC_PROTECTED); 32 //声明一个布尔类型的元素，为protected类型 33 zend_declare_property_bool(yaf_application_ce, 34 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_RUN), 0, ZEND_ACC_PROTECTED); 35 //声明一个字符串类型的元素 ， 为protected类型 36 zend_declare_property_string(yaf_application_ce, 37 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_ENV), YAF_G(environ_name), ZEND_ACC_PROTECTED); 38 //声明一个长整数类型的元素，为protected类型 39 zend_declare_property_long(yaf_application_ce, 40 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_ERRNO), 0, ZEND_ACC_PROTECTED); 41 zend_declare_property_string(yaf_application_ce, 42 ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_ERRMSG), &amp;#34;&amp;#34;, ZEND_ACC_PROTECTED); 43 44 return SUCCESS; 45} 二、添加类方法 上面讲解了创建一个类的过程，但是类中还有很多方法，通过yaf_application_methods方法集进行管理，具体对于函数的添加代码如下。</description></item><item><title>高级编程：PHP扩展的 INI 配置文件操作</title><link>https://icorer.com/icorer_blog/posts/ini-configuration-file-manipulation-for-php-extensions/</link><pubDate>Thu, 22 Nov 2018 10:24:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/ini-configuration-file-manipulation-for-php-extensions/</guid><description>Extension INI Entries (扩展INI配置项)Defining php.ini directives (i.e., INI entries) in an extension is easy. Most of the work involves setting up the global struct explained earlier in Section 14.10.3 Each entry in the INI structure is a global variable in the extension and thus has an entry in the global struct and is accessed using FOO_G(my_ini_setting). For the most part you can simply comment out the indicated sections in the skeleton created by ext_skel to get a working INI directive, but we will walk through it here anyway.</description></item><item><title>源码阅读：YAF框架系列文章(2) - (yaf.c)</title><link>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-2-yaf.c/</link><pubDate>Thu, 22 Nov 2018 10:04:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-2-yaf.c/</guid><description>这个文件是yaf框架的整体组成框架文件，因为yaf的设计思路是模块化的，因此在这个文件中进行了总体整合。整合的思路分为以下几个部分。
INI配置文件的解析 注册系统使用的常量 注册各个模块 对扩展模块的各个生命期做拦截监控 注册扩展模块 一、INI配置文件解析功能
在php_yaf.h文件中对于全局变量进行了定义工作，随后在yaf.c中进行了声明工作，声明操作 ZEND_DECLARE_MODULE_GLOBALS(yaf); ，声明操作之后，并在PHP_GINIT_FUNCTION钩子函数期进行了全局变量的初始化工作，框架进行了配置文件的加载过程，配置文件的操作定义如下：
1/** {{{ PHP_INI_MH(OnUpdateSeparator) 2 */ 3PHP_INI_MH(OnUpdateSeparator) { 4 YAF_G(name_separator) = ZSTR_VAL(new_value); 5 YAF_G(name_separator_len) = ZSTR_LEN(new_value); 6 return SUCCESS; 7} 8/* }}} */ 9 10/** {{{ PHP_INI 11 */ 12PHP_INI_BEGIN() 13 STD_PHP_INI_ENTRY(&amp;#34;yaf.library&amp;#34;, &amp;#34;&amp;#34;, PHP_INI_ALL, OnUpdateString, global_library, zend_yaf_globals, yaf_globals) 14 STD_PHP_INI_BOOLEAN(&amp;#34;yaf.action_prefer&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, action_prefer, zend_yaf_globals, yaf_globals) 15 STD_PHP_INI_BOOLEAN(&amp;#34;yaf.lowcase_path&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, lowcase_path, zend_yaf_globals, yaf_globals) 16 STD_PHP_INI_BOOLEAN(&amp;#34;yaf.use_spl_autoload&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, use_spl_autoload, zend_yaf_globals, yaf_globals) 17 STD_PHP_INI_ENTRY(&amp;#34;yaf.</description></item><item><title>源码阅读：YAF框架系列文章(1) - (php_yaf.h)</title><link>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-1-php_yaf.h/</link><pubDate>Wed, 21 Nov 2018 14:30:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-1-php_yaf.h/</guid><description>这个文件的核心使命是构建yaf基础定义，这部分定义主要包括
对于内核函数的宏定义 对于框架变量类型的宏定义 对于框架所使用的全局变量进行定义 一、对于内核函数进行宏定义
1#define YAF_STARTUP_FUNCTION(module) ZEND_MINIT_FUNCTION(yaf_##module) 2#define YAF_RINIT_FUNCTION(module) ZEND_RINIT_FUNCTION(yaf_##module) 3#define YAF_STARTUP(module) ZEND_MODULE_STARTUP_N(yaf_##module)(INIT_FUNC_ARGS_PASSTHRU) 4#define YAF_SHUTDOWN_FUNCTION(module) ZEND_MSHUTDOWN_FUNCTION(yaf_##module) 5#define YAF_SHUTDOWN(module) ZEND_MODULE_SHUTDOWN_N(yaf_##module)(INIT_FUNC_ARGS_PASSTHRU) 这个部分表现了yaf框架的模块化设计，yaf通过宏定义对于模块相关ZEND函数进行了封装，每个模块都将有自己的模块加载、关闭函数。例如YAF_STARTUP_FUNCTION(module) 的宏定义展开形式就是 zm_startup_yaf_module(int type, int module_number)
二、对于框架自定义变量类型进行定义
1#define yaf_application_t zval 2#define yaf_view_t zval 3#define yaf_controller_t zval 4#define yaf_request_t zval 5#define yaf_router_t zval 6#define yaf_route_t zval 7#define yaf_dispatcher_t zval 8#define yaf_action_t zval 9#define yaf_loader_t zval 10#define yaf_response_t zval 11#define yaf_config_t zval 12#define yaf_registry_t zval 13#define yaf_plugin_t zval 14#define yaf_session_t zval 15#define yaf_exception_t zval 三、对内核中将用到的函数做声明</description></item><item><title>设计文档：PulseFlow_IPC_Backend</title><link>https://icorer.com/icorer_blog/posts/design-document-pulseflow_ipc_backend/</link><pubDate>Wed, 22 Aug 2018 21:54:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/design-document-pulseflow_ipc_backend/</guid><description>PulseFLow还有一部分功能是集中在信息后端的，当PHP引擎发送信息给后端程序后，后端程序再把信息进行组装，发给下一级程序。
一 . 组成部分后端程序，分为以下几个部分：
配置中心：（配置文件 + 配置解析器）（采用ini文件配置格式）。
进程管理器：维持进程池，保持进程池的存活量。
信息发送： 信息组装 + 信息发送（UDP发送）
二. 工作流程2.1 总体流程图 2.2 系统模型（进程池模型） 后端组件采用进程池模型，主程序启动时，首先读取配置文件中关于进程池大小的配置选项，然后启动相关数量的子工作进程。
随后主进程进入稳定性极高的进程池监控流程，如果拦截到子进程有挂掉的情况发生，读取挂掉的状态并在相应的进程池位置开辟新的工作子进程。
通过进程池可以大大提高进程读取内核消息队列的效率，通过进程池管理程序可以大大提高整体后端程序的稳定性。
2.3 功能分配1. 主进程负责【管理进程池】，负责【创建可用的内核消息队列】。2. 工作子进程负责 【监控内核消息队列】&amp;mdash;&amp;gt;【读取消息】&amp;mdash;&amp;gt;【组装信息】&amp;mdash;&amp;gt;【UDP发送下游】</description></item><item><title>设计文档: PulseFLow PHP性能监控插件</title><link>https://icorer.com/icorer_blog/posts/design-documentation-pulseflow-php-performance-monitoring-plugin/</link><pubDate>Fri, 17 Aug 2018 13:18:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/design-documentation-pulseflow-php-performance-monitoring-plugin/</guid><description>一. 背景描述随着公司PHP项目体的不断增大，随着不同工程师的功能迭代，如何有效获取PHP项目的执行性能，对于系统整体模块显得异常重要，PulseFlow是一个公司团队内部自研地性能跟踪扩展，它可以在程序员无感知的情况下有效跟踪每一个函数的执行效率，主要分析CPU时间消耗、内存大小消耗，执行次数这三个指标，下面我们将从 PHP生命期 到 组件设计 到 性能优化这三个方面来进行阐述组件。
二 . 插件和 PHP生命期PHP生命周期通常包括 MI（模块初始化）、RI（请求初始化）、RS（请求终止）、MS（模块终止） 这四个步骤，这四个部分使我们能够进行功能渗透的生命期子过程。在MI阶段会包含INI配置文件的解析，在RI阶段会针对每一个CGI请求进行请求初始化操作，在RS阶段会针对每一个请求的关闭进行相关功能拦截。并不是每一次执行PHP均要经历这四个阶段，在CLI模式下，会完整经历这四个阶段，在PHP-FPM这种类CGI模式下，为了提高请求性能，并不会经历过全部阶段，它会着重经历RI、RS阶段。
了解了PHP的生命期轮廓后，我们绘制了下图阐述大概执行流程所属的生命期阶段。
三. 插件和ZEND引擎在上述的PHP生命周期阶段内，我们可以在不同的阶段分块插件的功能，其次，我们还需要和ZEND引擎打交道，因为ZEND引擎是真正的执行者，我们目前需要托管他们的 zend_execute_ex 内核函数，这个内核函数就是C语言的函数指针，这个内核函数顾名思义就是PHP的内核执行函数。
为了阐述方便，我们使用一个执行流程图，来看一下插件该如何拦截ZEND引擎的执行流程。 三. 开始造轮子3.1 插件流程分析首先，我们需要构建插件的执行流程，及各个部分的信息传送关系，我们目前把插件分为两部分，一部分是PHP扩展，用于在PHP生命周期内来进行性能拦截，这部分信息通常存储于 系统进程堆区 或者 系统进程静态区域，第二部分是后台数据转发程序，它负责从信息通道里读取PHP扩展写入的信息，并转发给相应的下一级程序，相关流程图如下。 3.2 环境选择（系统组件选择）这一步我们选择相应的环境，或者称之为系统组件选择，我们在选择相应组件时根据插件各个执行周期来进行选择。
3.2.1 PHP引擎环境 （PHP7+）首先PHP引擎我们选择7.0以上，因为 PHP7 与 PHP5 的内核数据结构差距甚大，目前针对PHP7，后面会移植代码覆盖PHP5版本。
3.2.2 插件语言 （C）虽然现在编写PHP扩展可以使用Go语言、zephir语言、但是为了和原PHP内核及Linux操作系统进行最好性能交互，我们选择C语言进行研发。
3.2.3 信息队列（System V 消息队列）在3.1中，我们提及了一个很重要的组件，并用红色进行了标记，PHP扩展和后台信息转发程序 如何 沟通？哪一条路最快？
为了选择这条信息通路，我们做了大量实验，覆盖面积包括TCP、unix domain socket、zeromq、nanomsg、共享内存、posix 内核消息队列、system V 内核消息队列，目前最快的是共享内存，其次是system V 和 posix 内核队列。
共享内存虽然是最快的，但是我们目前针对的模型是 多写、多读，为了不对PHP-FPM 内存 和 对系统内存能够更好更有力管理，在第一版中我们将采用system V内核队列，但是我们也已经开放了 共享内存版本的分支 和 给予epoll模型的 posix 内核队列 代码分支，这两个代码分值中均写好模型代码，在后面阶段将会一步步融入主线版本。
为什么选择 system V 队列？ 首先system V内核队列在 Linux Kernel 2.</description></item><item><title>检测并分析PHP扩展的内存泄露</title><link>https://icorer.com/icorer_blog/posts/detect-and-analyze-memory-leaks-in-php-extensions/</link><pubDate>Tue, 31 Jul 2018 09:11:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/detect-and-analyze-memory-leaks-in-php-extensions/</guid><description>1. 背景描述基于C/C++开发的程序，内存管理是很大程度上的工作，我们在这篇文章里来给大家讲解一下如何监控程序体可能存在的内存泄露。
工欲善其事必先利其器，这里选择使用 Valgrind 工作来进行内存监控。http://valgrind.org/
2. Valgrind工具安装1 git clone git://sourceware.org/git/valgrind.git 2 ./autogen.sh 3 ./configure --prefix=/usr/local/valgrind 4 make 5 make install 3. 测试命令样例1valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes php PulseFlow.php 4. 一次针对PHP扩展的内存泄露检测过程针对已经开源的 PulseFLow 插件，今天我们将进行相关的内存泄露检测，由于我们是对PHP扩展进行泄露检查，所以：
第一步，需要给PHP打开debug 编译参数，相关的编译参数如 ./configure --enable-debug 。
第二步，我们需要关闭zend 内存管理 ，添加相关的环境变量 export USE_ZEND_ALLOC=0 export ZEND_DONT_UNLOAD_MODULES=1 第三步，我们执行相关命令
1ZEND_DONT_UNLOAD_MODULES=1 USE_ZEND_ALLOC=0 valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes php PulseFlow.php 第四步，查看报告，获得总体报告如下
1==20296== LEAK SUMMARY: 2==20296== definitely lost: 0 bytes in 0 blocks 3==20296== indirectly lost: 0 bytes in 0 blocks 4==20296== possibly lost: 0 bytes in 0 blocks 5==20296== still reachable: 75,936 bytes in 29 blocks 6==20296== suppressed: 0 bytes in 0 blocks 5.</description></item><item><title>开源项目：PulseFLow 性能跟踪扩展</title><link>https://icorer.com/icorer_blog/posts/open-source-project-pulseflow-performance-tracking-extension/</link><pubDate>Wed, 25 Jul 2018 13:48:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/open-source-project-pulseflow-performance-tracking-extension/</guid><description>背景描述随着公司PHP项目体的不断增大，随着不同工程师的功能迭代，如何有效获取PHP项目的执行性能，对于系统整体模块显得异常重要，PulseFlow是一个性能跟踪扩展，它可以在程序员无感知的情况下有效跟踪每一个函数的执行效率，主要分析CPU时间消耗、内存大小消耗，这个组件除了能够快速记录每个函数体的性能信息，还具备一系列的发送机制，主要包括共享内存队列（System V 和 Posix）、UDP、Unix Domain Socket 等模式。
编译安装此为PHP扩展，按照正常的扩展安装，我们需要执行以下几步操作：
git clone https://github.com/gitsrc/PulseFlow.git 进入源码目录 phpize ./configure &amp;ndash;with-php-config= （ php-config文件路径） CFLAGS=&amp;rsquo;-g -lrt&amp;rsquo; CXXFLAGS=&amp;rsquo;-lrt' make make install 编译特别注意由于在扩展中使用了 posix 共享内存队列，所以我们编译时需要引入lrt库，上面在configure过程中附加的 CFLAGS 和 CXXFLAGS 参数用来给Makefile中的相应字段添加 -lrt，最终构造完后的Makefile对应配置应该为：
1CFLAGS = -g -lrt -O0 2 3CXXFLAGS = -lrt -g -O0 设计点1：PHP INI 配置选项PulseFlow由于是一个基于C语言的PHP扩展，为了保持程序体的扩展性，配置选项一律从php.ini文件中读取，本节将描述所有与扩展程序有关系的配置信息。
1.1 扩展功能开关参数 （PulseFlow.enabled）1.1.1 参数介绍这个参数是插件的功能开关，属于布尔类型，有效参数如下，默认 false：
true：开启 false：关闭 1.2 日志功能开关参数 （PulseFlow.debug）1.2.1 参数介绍这个参数是控制插件是否向页面输出调试信息，有效参数如下，默认 false：
true：开启 false：关闭 1.3 禁止跟踪函数列表 （PulseFlow.disable_trace_functions）1.3.1 参数介绍这个参数是一个逗号分隔的字符串，代表一系列函数列表，这个函数列表内的函数不进行性能跟踪，默认空字符串。
配置样例：PulseFlow.disable_trace_functions = &amp;ldquo;getLoader,findFile,loadClassLoader,getInitializer,findFileWithExtension,&amp;rdquo;
1.4 禁止跟踪类列表 （PulseFlow.disable_trace_class）1.4.1 参数介绍这个参数是一个逗号分隔的字符串，代表一系列类列表，这个类列表内的类不进行性能跟踪，默认空字符串。</description></item><item><title>编程笔记：C动态连接库编程</title><link>https://icorer.com/icorer_blog/posts/programming-notes-c-dynamic-link-library-programming/</link><pubDate>Tue, 24 Jul 2018 09:15:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/programming-notes-c-dynamic-link-library-programming/</guid><description>动态链接库，可以方便程序体扩展功能、更新组件，相对于编译时连接，具有更大的灵活性，下面我们从三个方面来讲解一个案例。
库函数定义在这里，我们首先定义一个简单的加法函数。
1#include &amp;lt;stdio.h&amp;gt; 2 3int add(int a,int b){ 4 return a+b; 5} 动态链接库编译我们通过编译命令对于源码文件进行编译，在linux系统中编译为so文件。
1gcc -shared -fPIC ./io.c -o add.so 编译参数解析 -shared该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接，相当于一个可执行文件。
-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。
测试动态链接库是否可用编写测试代码
1#include &amp;lt;stdio.h&amp;gt; 2#include &amp;lt;dlfcn.h&amp;gt; 3 4int main() { 5 void *handle = dlopen(&amp;#34;./add.so&amp;#34;, RTLD_LAZY); //打开动态链接库文件 6 char *dlerr = dlerror(); //跟踪动态链接库错误 7 8 if (handle == NULL || dlerr != NULL) { 9 printf(&amp;#34;%s\n&amp;#34;, dlerr); 10 return -1; 11 } 12 13 int (*add)(int, int) = dlsym(handle, &amp;#34;add&amp;#34;); //加载动态链接库函数 转换为函数指针 14 printf(&amp;#34;%d\n&amp;#34;, add(1, 2)); //根据函数指针调用动态链接库函数 15 return 0; 16} 编译测试代码时，需要链接dl库 ，编译命令如下：</description></item></channel></rss>