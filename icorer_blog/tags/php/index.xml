<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PHP on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/php/</link><description>Recent content in PHP on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 06 Mar 2020 12:41:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/php/index.xml" rel="self" type="application/rss+xml"/><item><title>PHP-rdkafka 内核扩展相关源码分析</title><link>https://icorer.com/icorer_blog/posts/php-rdkafka-kernel-extension-related-source-code-analysis/</link><pubDate>Fri, 06 Mar 2020 12:41:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/php-rdkafka-kernel-extension-related-source-code-analysis/</guid><description>这篇文章主要针对PHP生态的的kafka组件 php-rdkafka 进行相关的内核源码分析，方便大家把握组件的相关使用，目前文章主要针对kafka生产者部分。
一. 样例PHP代码 1public function __construct($config) 2 { 3 $conf = new \RdKafka\Conf(); 4 $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, $config[&amp;#39;brokerList&amp;#39;]); 5 $conf-&amp;gt;set(&amp;#39;message.max.bytes&amp;#39;, $config[&amp;#39;messageMaxBytes&amp;#39;]); 6 $conf-&amp;gt;set(&amp;#39;metadata.request.timeout.ms&amp;#39;, $config[&amp;#39;requestTimeout&amp;#39;]); 7 $conf-&amp;gt;set(&amp;#39;session.timeout.ms&amp;#39;, $config[&amp;#39;sessionTimeout&amp;#39;]); 8 $this-&amp;gt;producer = new \RdKafka\Producer($conf); 9 $this-&amp;gt;producer-&amp;gt;addBrokers($config[&amp;#39;brokerList&amp;#39;]); 10 } 11 12 public function sendMessage($data){ 13 $result = 1; 14 $topic = $this-&amp;gt;producer-&amp;gt;newTopic($data[0][&amp;#39;topic&amp;#39;]); 15 $topic-&amp;gt;produce(RD_KAFKA_PARTITION_UA, 0, $data[0][&amp;#39;value&amp;#39;]); 16 $this-&amp;gt;producer-&amp;gt;poll(0); 17 for ($flushRetries = 0; $flushRetries &amp;lt; 10; $flushRetries++) { 18 $result = $this-&amp;gt;producer-&amp;gt;flush(10000); 19 if (RD_KAFKA_RESP_ERR_NO_ERROR === $result) { 20 break; 21 } 22 } 23 if (RD_KAFKA_RESP_ERR_NO_ERROR !</description></item><item><title>Curl-VS-Guzzle 性能测试</title><link>https://icorer.com/icorer_blog/posts/curl-vs-guzzle-performance-test/</link><pubDate>Fri, 22 Feb 2019 13:40:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/curl-vs-guzzle-performance-test/</guid><description>Curl-VS-Guzzle 性能测试这里项目围绕Curl 和 Guzzle这两个HTTP请求组件进行一些压力测试,看一下性能差距.我们围绕两个组件的连接复用情况来测试.(文章中会强调opcache的作用)
一. 测试阐述 测试curl和guzzle在连接复用情况下的性能差别 (guzzle不开启opcache) 测试curl和guzzle在连接复用情况下的性能差别 (guzzle开启opcache) 二. 性能测试过程2.1 测试条件 在相同的Nginx,PHP,LibCurl库环境 测试脚本包含curl对象的复用,每次测试请求执行10次外部http请求 2.2 Guzzle测试代码 1//GuzzleClient.php 2use \GuzzleHttp\Client; 3class GuzzleClient 4{ 5 protected static $guzzleClientConnection = null; 6 7 public static function getGuzzleClient($baseUrl, $persistent = true) 8 { 9 if (!$persistent || !self::$guzzleClientConnection) { 10 self::$guzzleClientConnection = new Client([&amp;#39;base_uri&amp;#39; =&amp;gt; $baseUrl]); 11 } 12 13 return self::$guzzleClientConnection; 14 } 15 16} 17 18//get_loop_simple.php 内部循环调用多次 19for ($i=0;$i&amp;lt;10;$i++){ 20 try { 21 //获取Client静态变量,复用curl单体 22 $client = GuzzleClient::getGuzzleClient(&amp;#34;http://127.</description></item><item><title>PHP-CURL-Guzzle-HTTP-连接复用内核原理</title><link>https://icorer.com/icorer_blog/posts/php-curl-guzzle-http-connection-reuse-kernel-principle/</link><pubDate>Fri, 22 Feb 2019 13:16:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/php-curl-guzzle-http-connection-reuse-kernel-principle/</guid><description>PHP-CURL连接复用内核原理0.写在前面PHP是一个时代的产物,它的底层支持是C语言,因此它在CPU密集型计算或者系统内核调用上有天生的优势,Zend引擎把PHP执行生命期分成了五个阶段1,这五个阶段并不是全部都能常驻进程,这种模式下,对于很多使用场景会造成不好的影响,比如网络IO.
对于网络IO中的HTTP请求 , 很多工程师使用 php-curl 系列函数 . 所以这篇文章将从内核角度讲解php如何支持curl请求的连接复用(这里的连接复用也是指在一个RINIT2&amp;ndash;&amp;gt;RSHUTDOWN3周期内复用).
1. PHP引擎借力CURL库函数PHP需要使用curl组件进行HTTP系列通信,因此它在底层需要curl有相关的支撑,所以curl首先需要在系统环境中被部署或者被编译,并对外部提供动态链接库文件,PHP通过调用curl相关的动态链接库函数来进行自己内核函数的实现过程.
多说一句,PHP并不一定需要curl才能完成http请求,因为php引擎中已经包含了socket完善的函数库,所以有些php扩展包支持curl和原生stream_socket(tcp)两种模式,例如:guzzle
2. PHP-CURL基础数据结构(php_curl结构体) 1147 typedef struct { 2148 php_curl_write *write; 3149 php_curl_write *write_header; 4150 php_curl_read *read; 5151 zval std_err; 6152 php_curl_progress *progress; 7153 #if LIBCURL_VERSION_NUM &amp;gt;= 0x071500 /* Available since 7.21.0 */ 8154 php_curl_fnmatch *fnmatch; 9155 #endif 10156 } php_curl_handlers; 11 12173 typedef struct { 13174 CURL *cp; //curl库 实体结构体 14175 php_curl_handlers *handlers; //header 头部 15176 zend_resource *res; //引擎资源指针 16177 struct _php_curl_free *to_free; 17178 struct _php_curl_send_headers header; 18179 struct _php_curl_error err; //错误码 19180 zend_bool in_callback; 20181 uint32_t* clone; 21182 } php_curl; 3.</description></item><item><title>PHP内核函数: microtime</title><link>https://icorer.com/icorer_blog/posts/php-kernel-function-analysis-microtime/</link><pubDate>Fri, 22 Feb 2019 13:04:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/php-kernel-function-analysis-microtime/</guid><description>microtime Description ¶
microtime ([ bool $get_as_float = FALSE ] ) : mixed
microtime() returns the current Unix timestamp with microseconds. This function is only available on operating systems that support the gettimeofday() system call.
source file:** /php-src/ext/standard/microtime.c**
Part-1 : 内核抛出定义1.1 源码185 /* {{{ proto mixed microtime([bool get_as_float]) 286 Returns either a string or a float containing the current time in seconds and microseconds */ 387 PHP_FUNCTION(microtime) 488 { 589 _php_gettimeofday(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0); 690 } 791 /* }}} */ Part-2 : 源码分析2.</description></item></channel></rss>