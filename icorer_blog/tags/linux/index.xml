<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/linux/</link><description>Recent content in linux on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 08 Mar 2020 11:45:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux内核-内存管理: Out Of Memory Management 源码分析</title><link>https://icorer.com/icorer_blog/posts/linux-kernel-memory-management-out-of-memory-management-source-code-analysis/</link><pubDate>Sun, 08 Mar 2020 11:45:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/linux-kernel-memory-management-out-of-memory-management-source-code-analysis/</guid><description>我们这篇文章中描述了Linux内核对于 Out Of Memory Management 场景下的相关策略，接下来我们将进行Linux 5.0内核的OOM内核源码分析。
一. 关键数据结构针对源码部分，我们首先需要阐述oom_kill部分的核心数据结构。
文件路径：/linux/include/linux/oom.h
1.1 oom_control 结构体首先，我们给出具体的内核定义：
1/* 2 * Details of the page allocation that triggered the oom killer that are used to 3 * determine what should be killed. 4 */ 5struct oom_control { 6 /* Used to determine cpuset */ 7 struct zonelist *zonelist; 8 9 /* Used to determine mempolicy */ 10 nodemask_t *nodemask; 11 12 /* Memory cgroup in which oom is invoked, or NULL for global oom */ 13 struct mem_cgroup *memcg; 14 15 /* Used to determine cpuset and node locality requirement */ 16 const gfp_t gfp_mask; 17 18 /* 19 * order == -1 means the oom kill is required by sysrq, otherwise only 20 * for display purposes.</description></item></channel></rss>