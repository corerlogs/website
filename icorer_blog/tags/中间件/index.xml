<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>中间件 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/</link><description>Recent content in 中间件 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 19 Feb 2020 11:43:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>MKV-高性能分布式内存KV-开篇</title><link>https://icorer.com/icorer_blog/posts/mkv-high-performance-distributed-memory-kv-opening/</link><pubDate>Wed, 19 Feb 2020 11:43:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/mkv-high-performance-distributed-memory-kv-opening/</guid><description>一. 背景描述目前缓存环境中，使用较多的是Redis缓存，但是Redis单线程机制，在特高并发场景中还是能达到吞吐瓶颈，又由于很多大数据应用场景需要单次GET 1000或者更多的key，所以直接打到Redis服务器上，很容易让Redis主线程出现阻塞情况，产生吞吐大大下降的情况。
在这样的情况下，我们就设想架构设计一个分布式内存的缓存系统（MKV），主要设计目标包括一下：
多线程机制保障多核使用，提高云服务器的CPU使用率。 实现高性能、并发安全、存储具备数据完整性的内存缓存存储，支撑单次1000以上的key获取操作。 支持Redis-RESP应用层协议，由于大部分业务方使用redis缓存，尽量避免缓存切换带来的系统调整成本。 服务可用性达到99.99% 支持分布式场景不是和使用。 等等。。。 二. 模型试验由于团队一直在研究Redis内核及其通信协议，因此我们首先需要对多线程版本的缓存MKV 进行模型实验，证明猜想的有效性。
于是，我们分别针对官方Redis内核 和 我们目前的多线程版本缓存KV组件 - MKV进行性能测试对比。
2.1 测试环境我们的测试在下面的环境中进行：
Linux 5.0.0 Kernel Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz [4核] 16GB内存 单次请求 ：1000 个key 使用Redis官方 redis-benchmark 工具进行压测 2.2 Redis 官方版本压测【SET: 85w/s GET: 105w/s 】1redis-benchmark -p 6379 -t get -n 5000000 -P 1000 -c 10 压测结果如下：
1====== SET ====== 2 10000000 requests completed in 11.75 seconds 3 10 parallel clients 4 3 bytes payload 5 keep alive: 1 6 70.</description></item></channel></rss>