<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>内核研究 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6/</link><description>Recent content in 内核研究 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 14 Feb 2020 13:35:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>LibCurl连接复用原理</title><link>https://icorer.com/icorer_blog/posts/libcurl-connection-multiplexing-principle/</link><pubDate>Fri, 14 Feb 2020 13:35:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/libcurl-connection-multiplexing-principle/</guid><description>一. 背景描述Curl是计算机中使用最多的网络请求工具，很多开源项目在内核中对于HTTP、FTP的操作是通过libcurl库获得的技术支持。这篇文章主要调研libcurl库中的TCP连接复用部分。
二. 连接池Libcurl针对tcp连接采用了连接池管理，一次传输完成后，它将在“连接池”（有时也称为连接缓存）中保持N个连接处于活动状态，以便恰好能够重用现有连接之一的后续传输可以使用它而不是创建一个新连接。
重用一个连接而不是创建一个新的连接在速度和所需资源方面提供了显著的好处。
当libcurl准备建立一个新的连接来进行传输时，它首先会检查池中是否有可以重用的现有连接。**连接重用检查是在使用任何DNS或其他名称解析机制之前完成的，因此它完全基于主机名。**如果已经存在到正确主机名的实时连接，则还将检查许多其他属性（端口号，协议等），以确保可以使用它。
三. 连接池场景Libcurl 几乎在所有的实现场景中都自动加入了连接池支持，主要的场景包括以下三种：
Easy API pool Multi API pool Sharing the &amp;ldquo;connection cache&amp;rdquo; 3.1 Easy API pool当您使用easy API，或更具体地说，使用curl_easy_perform()时，libcurl将使该池与特定的easy句柄关联。 然后重用同一简单句柄将确保它可以重用其连接。
3.2 Multi API pool当您使用multi API时，连接池将与multi句柄相关联。这允许您自由地清理和重新创建easy句柄，而不会有丢失连接池的风险，并且允许一个easy句柄使用的连接在以后的传输中被另一个简单句柄重用。只需重用multi句柄。
3.3 Sharing the &amp;ldquo;connection cache&amp;rdquo;从libcurl 7.57.0开始，应用程序可以使用 share interface，以使其他独立的传输共享同一连接池。
四. Curl-TCP长连接和DNS解析的关系libcurl具有自己的内部DNS缓存，默认情况下它将在其中缓存解析的地址60秒（此选项可以更改） 。因此具有相同名称的后续解析将使用该时间范围内的缓存结果。
curl的连接缓存完全基于URL中使用的主机名，因此，如果缓存中已有与“ example.com”的可用连接，则该连接将用于对同一主机名的后续请求。 curl既不知道也不关心该名称的IP地址是什么，或者自连接启动以来它是否更改。 重用连接时，它将跳过整个dns解析阶段。
传输完成且连接仍然处于活动状态时，将把连接放回连接缓存中(或者，如果由于达到了限制而认为缓存已满，则关闭连接)。
由于连接重用是基于名称完成的，因此使用另一个名称解析为现有连接的相同IP不会使curl重复使用该连接。 它将解析名称并为此创建一个新的连接。
一个连接可以无限期地保留在连接缓存中，除非它被杀死以腾出空间或被重用。 如果它“死了”（由于它从另一端关闭），则当它被注意到时，它将最终从缓存中删除。
HTTP/2
可以通过HTTP/2发送的PING帧不会在连接缓存中处理(atm)连接，这将导致它们很快被服务器杀死。(libcurl 7.62.0添加了一个新的API，允许应用程序保持这样的连接，参见curl_easy_upkeep)
DoH
随着curl 7.62.0引入了DoH (dn -over- https)支持，DNS缓存将缓存TTL秒数的名称，而不仅仅是使用默认的60秒。
四. 重点总结 Libcurl连接重用检查是在使用任何DNS或其他名称解析机制之前完成的，因此它完全基于主机名。当libcurl的池中已经有了到主机名的活动连接时，它会跳过名称解析，而是直接进行重用。 libcurl长连接 和 dns请求没有相关关系，因此原生的libcurl库并不能对于dns解析变化有很好的的感知过程。 五. LibCurl 和 DNS解析的结合方案由于从上面的内容可以看出，LibCurl和DNS解析之间没有动态感应的过程，所以如果需要增加DNS动态感应过程不能从LibCurl下手，而应该通过LibCurl的调用方增加一定的策略来下手，主要的策略包括以下三种:
DNS TTL方案： 针对LibCurl库调用包装一层，增加一层域名的DNS TTL读取功能，根据TTL进行DNS请求定时器的设计，从而感应DNS的变化过程。但是需要注意的是TTL数据在标准的POSIX DNS解析 API中不可用，可以使用非dns完成名称解析。 Libcurl Handle 增强控制方案：Libcurl库对外统一暴露了handle内存区，为了感应到dns变化，我们就必须要让handle强制进入到dns解析阶段，因此可以针对Libcurl handle内存区的存活时长 和 内存区域使用次数下手，当时间超过了最大存活时长 或者 handle使用次数超过了最大复用次数，则强行进行Libcurl-handle内存区域释放，从而促使Libcurl进入dns解析过程。 参考资料：</description></item><item><title>LibCurl-DNS超时参数解析</title><link>https://icorer.com/icorer_blog/posts/libcurl-dns-timeout-parameter-analysis/</link><pubDate>Fri, 14 Feb 2020 12:07:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/libcurl-dns-timeout-parameter-analysis/</guid><description>一. 名称CURLOPT_DNS_CACHE_TIMEOUT - 设置DNS缓存条目的生存时间
二. 摘要1#include &amp;lt;curl/curl.h&amp;gt; 2 3CURLcode curl_easy_setopt(CURL *handle, CURLOPT_DNS_CACHE_TIMEOUT, long age); 三. 描述传递一个long类型参数，这会设置超时时间(以秒为单位)。名称解析将保存在内存中，并使用此秒数。设置为0将完全禁用缓存，或设置为-1使缓存的条目永远保持不变。默认情况下，libcurl缓存该信息60秒。
除非明确告知（例如，通过调用res_init（3）），否则各种libc实现的名称解析功能都不会重新读取名称服务器信息。这可能会导致libcurl继续使用旧的服务器，即使DHCP已经更新了服务器信息，对于一般的libcurl-app用户来说，这可能是一个DNS缓存问题。
请注意，DNS条目具有“ TTL”属性，但libcurl不使用该属性。 DNS缓存超时完全是推测性的，一个名称将在未来的一小段时间内解析为相同的地址。
默认值60
协议ALL
样例 1CURL *curl = curl_easy_init(); 2if(curl) { 3 curl_easy_setopt(curl, CURLOPT_URL, &amp;#34;http://example.com/foo.bin&amp;#34;); 4 5 /* only reuse addresses for a very short time */ 6 curl_easy_setopt(curl, CURLOPT_DNS_CACHE_TIMEOUT, 2L); 7 8 ret = curl_easy_perform(curl); 9 10 /* in this second request, the cache will not be used if more than 11 two seconds have passed since the previous name resolve */ 12 ret = curl_easy_perform(curl); 13 14 curl_easy_cleanup(curl); 15} 可用性Always</description></item><item><title>PHP-CURL-Guzzle-HTTP-连接复用内核原理</title><link>https://icorer.com/icorer_blog/posts/php-curl-guzzle-http-connection-reuse-kernel-principle/</link><pubDate>Fri, 22 Feb 2019 13:16:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/php-curl-guzzle-http-connection-reuse-kernel-principle/</guid><description>PHP-CURL连接复用内核原理0.写在前面PHP是一个时代的产物,它的底层支持是C语言,因此它在CPU密集型计算或者系统内核调用上有天生的优势,Zend引擎把PHP执行生命期分成了五个阶段1,这五个阶段并不是全部都能常驻进程,这种模式下,对于很多使用场景会造成不好的影响,比如网络IO.
对于网络IO中的HTTP请求 , 很多工程师使用 php-curl 系列函数 . 所以这篇文章将从内核角度讲解php如何支持curl请求的连接复用(这里的连接复用也是指在一个RINIT2&amp;ndash;&amp;gt;RSHUTDOWN3周期内复用).
1. PHP引擎借力CURL库函数PHP需要使用curl组件进行HTTP系列通信,因此它在底层需要curl有相关的支撑,所以curl首先需要在系统环境中被部署或者被编译,并对外部提供动态链接库文件,PHP通过调用curl相关的动态链接库函数来进行自己内核函数的实现过程.
多说一句,PHP并不一定需要curl才能完成http请求,因为php引擎中已经包含了socket完善的函数库,所以有些php扩展包支持curl和原生stream_socket(tcp)两种模式,例如:guzzle
2. PHP-CURL基础数据结构(php_curl结构体) 1147 typedef struct { 2148 php_curl_write *write; 3149 php_curl_write *write_header; 4150 php_curl_read *read; 5151 zval std_err; 6152 php_curl_progress *progress; 7153 #if LIBCURL_VERSION_NUM &amp;gt;= 0x071500 /* Available since 7.21.0 */ 8154 php_curl_fnmatch *fnmatch; 9155 #endif 10156 } php_curl_handlers; 11 12173 typedef struct { 13174 CURL *cp; //curl库 实体结构体 14175 php_curl_handlers *handlers; //header 头部 15176 zend_resource *res; //引擎资源指针 16177 struct _php_curl_free *to_free; 17178 struct _php_curl_send_headers header; 18179 struct _php_curl_error err; //错误码 19180 zend_bool in_callback; 20181 uint32_t* clone; 21182 } php_curl; 3.</description></item></channel></rss>