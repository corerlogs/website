<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>新架构 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/%E6%96%B0%E6%9E%B6%E6%9E%84/</link><description>Recent content in 新架构 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 12 Dec 2022 11:55:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/%E6%96%B0%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>Self-Sovereign Identity：什么是自我主权身份？</title><link>https://icorer.com/icorer_blog/posts/web3/what-is-self-sovereign-identity/</link><pubDate>Mon, 12 Dec 2022 11:55:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/web3/what-is-self-sovereign-identity/</guid><description>如今，我们日常生活的许多方面都依赖数字服务，从在线购物到所谓的 Web 2.0 中的金融服务。我们使用多个（如果不是数百个）帐户与不同的集中式网络平台（例如社交媒体或电子邮件服务）进行交互。问题是，当我们无法访问我们的帐户时，我们就会失去我们的数字身份，因为网站无法再识别我们是谁。这意味着我们实际上并不拥有我们的身份和数据。这有问题。我们需要收回数据和数字身份的所有权，而自主身份可以实现这一点，为我们进入 Web 3.0 铺平道路。
自我主权身份是指一种让个人控制其数字身份的方法。自我主权身份 (SSI) 是一项运动，它声称数字身份应该与一个人的人类身份一样合法和微妙，同时所有人都可以访问、保护隐私并且不依赖于单一的政府或公司。
那么究竟什么是自我主权身份呢？自我主权身份是指一种让个人控制其数字身份的方法。为了更好地理解这个概念，让我们看一下两个模型：
Web 2.0 - 集中式模型我们的电子邮件帐户、网站帐户和社交媒体帐户目前允许数字服务在线识别我们。我们要么为每个平台创建一个帐户，要么使用 Facebook 或 Google 等服务提供商提供的单点登录。无论我们使用哪种方法，我们的数据都由帐户提供商集中存储。这种模式产生了一些严重的问题：
管理困难：我们努力管理众多帐户以访问不同的数字平台。此外，这些平台可以单方面决定关闭我们的帐户，或代表我们管理它。
安全和依赖风险：由于我们的大多数帐户都与我们的电子邮件地址相关联，如果我们的电子邮件访问受到威胁，黑客可以通过“忘记我的密码”方法更改密码来轻松接管使用该电子邮件的其他帐户。例如，黑客可以伪装成数字化的你，并在 Facebook 上欺骗你的家人和朋友。
隐私的脆弱性：如果我们使用的服务被黑客入侵，我们的数据很可能会被泄露，因为它是集中存储的。根据身份盗窃研究中心的数据，到 2021 年 10 月，将近 2.815 亿人受到某种数据泄露的影响。
缺乏数据自主权：我们无法控制我们的数据如何被使用或与其他平台共享。更糟糕的是，这些数据是代表我们货币化的。
Web 3.0 - 去中心化模型为了克服中心化身份模型的上述所有问题，我们需要引入去中心化身份模型，从而实现自我主权身份。个人与对应方（例如个人、组织或物联网）之间的关系是点对点的。它不再依赖中心化的实体，而是利用去中心化的网络，即区块链技术。这种方法的一些好处：
弹性网络：区块链网络永远不会宕机，而集中式网络由公司运营，就像 Facebook 几个月前所做的那样，人们无法登录网站或其任何产品。 可验证凭证：数据和信息由身份所有者选择的受信任方（例如政府和银行）作为凭证发布。如果授予访问权限，其他节点可以验证链上的凭证。 建立信任：不变性是区块链的本质，它确保了可验证凭证的真实性。例如，同行可以通过链上证明来验证文凭是否由大学颁发。 控制数据：自主身份的所有者可以决定何时共享凭据，以及共享哪些凭据。 自我主权身份是一种以用户为中心的数字身份，我们作为用户可以完全控制我们的在线身份，但它不仅适用于个人，也适用于组织甚至事物 (IoT) 或程序。我们相信在不久的将来，我们都将使用自主身份在数字世界中进行点对点交互，而不是依赖于其他方基于账户的数字身份。
身份类型 真实身份人类身份是一个复杂的话题——几个世纪以来哲学家们一直在争论这个问题，而我所说的任何话都无法解决这些争论。所以我在这里提出一个我用来解释我认为人类身份如何运作的心智模型。我将人的身份简化为两部分，这两部分对于一个人成为社会上有生产力的成员来说都是必不可少的。
内在同一性：这就是我们照镜子时所看到的。这是我们的性别认同、政治认同或文化认同。在我们与最亲密的知己的关系中，这就是我们的身份。它是我们固有的，是身份的最真实形式。
外在身份：这是其他人（通常是机构）识别我们的方式。驾照是最普遍的例子。虽然旨在证明您有资格在公共道路上行驶，但它也是金融机构、机场和酒吧识别您的方式。它之所以有效，是因为机构信任 DMV，并且有了驾照，您始终可以得到 DMV 的担保。而且它不仅限于政府、教育、专业和会员凭证都以同样的方式工作。
数字身份一些最大的社交媒体、博客和其他互联网平台的存在基本上是为了帮助人们表达他们内在的身份。但是（值得注意的是）仍然没有很好的方法来数字化管理我们的外在身份。我们仍然使用纸质文件和塑料卡来访问我们生活中一些最重要的服务，使我们身份的一些最敏感和最重要的方面受到欺诈。令人恐惧的是，在日益数字化的世界中，我们有时必须扫描、通过电子邮件发送或发送这些文件的照片才能完成一些基本的事情，例如获得购房资格或开设银行账户。
自我主权身份自我主权身份是真实身份与数字世界的结合，最终将使人们的生活更美好。它仍处于起步阶段，要真正使数字身份像现实世界一样合法和微妙，还有很长的路要走身份。但最近有几项非常有前途的技术进步代表了巨大的突破，其中最重要的是数字钱包的出现和可验证凭证的标准化，这些共同创造了一条首次将我们的外在身份在线化的途径。
技术组成 数字钱包数字钱包顾名思义：一个安全的数字环境，您可以在其中保存重要的卡片（例如驾照、员工身份证）或货币。就像在现实世界中一样，这个钱包有一些重要的属性：
钱包中的卡是由受信任的实体（即 DMV 颁发的驾驶执照）提供给您的。
您可以随心所欲地使用这些卡片来证明您的身份或其他特征。
卡片是你的；没有人能把它们带走。但是，为您提供该卡的组织可能会撤销它或让它过期。
未经您的许可，任何人甚至无法查看您钱包中的内容，即使是钱包提供商。
您可以随意切换钱包。如果你找到另一个钱包，你可以相对轻松地将你的卡换到新的。
钱包，无论是实体钱包还是数字钱包，都只是一个容器。它需要有价值的内容，数字钱包持有的“卡片”被称为“可验证凭证”。
可验证凭证可验证凭证是在线表示外部身份的标准方式。作为 SSI 钱包中的主要内容，它们通常是您通常保存在实体钱包中的卡片的数字化、防篡改、不可转让、可验证版本。您可以在保护隐私的同时共享来自这些凭据的经过验证的信息（例如在不透露您的地址的情况下共享您的选民选区或在不透露您的 SSN 的情况下共享您的信用评分）。由于凭据是您的，因此您不需要用户名和密码即可访问它们。在未来的状态下，服务的访问可能基于这些凭据。
可验证凭证有很多实现，目前我所关注的是DID+CA模型的方案。</description></item><item><title>Drand去中心化可验证随机数</title><link>https://icorer.com/icorer_blog/posts/web3/verifiable-random-number-drand-program-experiment/</link><pubDate>Thu, 08 Dec 2022 11:55:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/web3/verifiable-random-number-drand-program-experiment/</guid><description>Drand最初来自DEDIS实验室，由于使用基于配对的密码学，drand 能够以非常简单和有效的方式生成随机性，并以可靠的方式将其交付给客户端。Drand 旨在成为一种分布式服务，以与应用程序无关、安全且高效的方式提供公共随机性。随着 drand 的成熟，越来越多的组织（包括 NIST、Cloudflare、Kudelski Security、智利大学和协议实验室）开始感兴趣，并决定共同努力建立一个跨越这些组织的 drand 网络。
Drand 旨在成为一种互联网基础设施级服务，为应用程序提供随机性，类似于 NTP 提供计时信息和证书透明服务器提供证书吊销信息的方式，Drand去中心化随机数方案可以提供 去中心化随机性与可验证性两大核心功能。
为什么去中心化随机性很重要多年来，一代公共随机性(通常称为common coins)吸引了密码学研究社区的持续兴趣。许多分布式系统，包括各种共识机制、Tor等匿名网络或区块链系统，都假定可以访问这种公共随机性。例如，在最近的权益证明区块链中，矿工在每个时期都是通过一个共同的随机源随机选出的。然而，拥有一个不可偏置的、分布式的、可扩展的公共随机资源仍然是一个主要的缺失部分。目前存在一些集中式解决方案，尽管它们确实提供了一个统一的随机性来源，但这些信标既不可验证也不分散。可验证性是必要的。对于权益证明系统中的示例，可验证性是必要的，在该系统中，区块生产者需要证明他已被选为给定时期的矿工。
实验代码 1 2package main 3 4import ( 5 &amp;#34;context&amp;#34; 6 &amp;#34;encoding/hex&amp;#34; 7 &amp;#34;log&amp;#34; 8 &amp;#34;time&amp;#34; 9 10 &amp;#34;github.com/drand/drand/client&amp;#34; 11 &amp;#34;github.com/drand/drand/client/http&amp;#34; 12) 13 14var urls = []string{ 15 &amp;#34;https://api.drand.sh&amp;#34;, 16 &amp;#34;https://drand.cloudflare.com&amp;#34;, 17} 18 19var chainHash, _ = hex.DecodeString(&amp;#34;8990e7a9aaed2ffed73dbd7092123d6f289930540d7651336225dc172e51b2ce&amp;#34;) 20 21func main() { 22 c, err := client.New( 23 client.From(http.ForURLs(urls, chainHash)...), 24 client.WithChainHash(chainHash), 25 ) 26 27 if err !</description></item><item><title>Gorilla：一个快速、可伸缩的内存时间序列数据库</title><link>https://icorer.com/icorer_blog/posts/gorilladb/</link><pubDate>Fri, 01 Apr 2022 17:26:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/gorilladb/</guid><description>摘要大规模互联网服务旨在出现意外故障时保持高可用性和高响应性。提供这种服务通常需要在大量系统上每秒钟监测和分析数千万次测量，一个特别有效的解决方案是在时间序列数据库(TSDB)中存储和查询这种测量。TSDB设计中的一个关键挑战是如何在效率、可伸缩性和可靠性之间取得平衡。在本文中，我们介绍Gorilla系统，脸书的内存TSDB。我们的见解是，监控系统的用户不太重视单个数据点，而是更重视综合分析，对于快速检测和诊断持续问题的根本原因而言，最新数据点比旧数据点更有价值。Gorilla优化了写入和读取的高可用性，即使在出现故障时也是如此，代价是可能会在写入路径上丢弃少量数据。为了提高查询效率，我们积极利用压缩技术，如增量时间戳和异或浮点值，将Gorilla的存储空间减少了10倍。这使我们能够将Gorilla的数据存储在内存中，与传统数据库(HBase)支持的时间序列数据相比，查询延迟减少了73倍，查询吞吐量提高了14倍。这种性能改进带来了新的监控和调试工具，比如时序关联搜索和更密集的可视化工具。Gorilla还可以优雅地处理从单个节点到整个区域的故障，几乎没有运营开销。
一、介绍大规模互联网服务即使在出现意外故障的情况下也能保持高可用性和对用户的响应。随着这些服务发展到支持全球客户，它们已经从运行在数百台机器上的几个系统扩展到服务数以千计的个人用户系统运行在数千台机器上，通常跨越多个地理复制的数据中心。
运行这些大规模服务的一个重要要求是准确监控底层系统的健康和性能，并在出现问题时快速识别和诊断问题。脸书使用时间序列数据库(TSDB)存储系统测量数据点，并在顶部提供快速查询功能。接下来，我们将指定监控和操作脸书需要满足的一些约束，然后描述Gorilla，这是我们新的内存TSDB，可以存储数千万个数据点(例如，CPU 负载、错误率、延迟等)。)并在几毫秒内响应对此数据的查询。
写占主导地位。我们对 TSDB 的主要要求是它应该始终可用于写入。由于我们有数百个公开数据项的系统，写入速率可能很容易超过每秒数千万个数据点。相比之下，读取速率通常要低几个数量级，因为它主要来自于观察“重要”时间序列数据的自动化系统、可视化系统或为希望诊断观察到问题的人类操作员提供仪表板。
状态转换。我们希望识别新软件发布中出现的问题、配置更改的意外副作用、网络中断以及导致重大状态转换的其他问题。因此，我们希望我们的TSDB支持短时间窗口内的细粒度聚合。在几十秒钟内显示状态转换的能力特别有价值，因为它允许自动化在问题变得广泛传播之前快速修复问题。
高可用性。即使网络分区或其他故障导致不同数据中心之间的连接断开，在任何给定数据中心内运行的系统都应该能够将数据写入本地TSDB机器，并且能够按需检索这些数据。
容错。我们希望将所有写入复制到多个区域，这样我们就可以在任何给定的数据中心或地理区域因灾难而丢失时幸存下来。
Gorilla是脸书的新TSDB，满足了这些限制。Gorilla用作进入监控系统的最新数据的直写缓存。我们的目标是确保大多数查询在几十毫秒内运行。Gorilla 的设计理念是，监控系统的用户不太重视单个数据点，而是更重视综合分析。此外，这些系统不存储任何用户数据，因此传统的 ACID保证不是TSDB的核心要求。 但是，高比例的写入必须始终成功，即使面临可能导致整个数据中心无法访问的灾难。此外，最近的数据点比旧的数据点具有更高的价值，因为直觉上，对于运营工程师来说，知道特定系统或服务现在是否被破坏比知道它是否在一个小时前被破坏更有价值，Gorilla 进行了优化，即使在出现故障的情况下也能保持高度的读写可用性，代价是可能会丢失少量数据写入路径。
高数据插入率、总数据量、实时聚合和可靠性要求带来了挑战。我们依次解决了这些问题。为了解决第一个要求，我们分析了 TSDB 操作数据存储(ODS),这是一个在脸书广泛使用的老的监控系统。我们注意到，对ODS的所有查询中，至少有85%是针对过去26小时内收集的数据。进一步的分析使我们能够确定，如果我们能够用内存中的数据库替换基于磁盘的数据库，我们可能能够为我们的用户提供最好的服务。此外，通过将这个内存中的数据库视为持久的基于磁盘的存储的缓存，我们可以实现具有基于磁盘的数据库的持久性的内存中系统的插入速度。
截至2015年春天，脸书的监控系统生成了超过20亿个独特的时间序列计数器，每秒钟增加约1200万个数据点。这代表每天超过1万亿个点。在每点16字节的情况下，产生的16TBRAM对于实际部署来说太耗费资源了。我们通过重新利用现有的基于XOR的浮点压缩方案来解决这一问题，使其以流的方式工作，从而允许我们将时间序列压缩到平均每点1.37字节，大小减少了12倍。
我们通过在不同的数据中心区域运行多个Gorilla实例并向每个实例传输数据流来满足可靠性要求，而不试图保证一致性。读取查询指向最近的可用Gorilla实例。请注意，这种设计利用了我们的观察，即在不影响数据聚合的情况下，单个数据点可能会丢失，除非Gorilla实例之间存在显著差异。Gorilla目前正在脸书的生产中运行，工程师们每天将其用于实时灭火和调试，并与Hive[27]和Scuba[3]等其他监控和分析系统结合使用，以检测和诊断问题。
二、背景和要求2.1 操作数据存储脸书的大型基础设施由分布在多个数据中心的数百个系统组成，如果没有能够跟踪其运行状况和性能的监控系统，运营和管理这些基础设施将会非常困难。业务数据储存库是脸书监测系统的一个重要部分。ODS由一个时间序列数据库(TSDB)、一个查询服务以及一个探测和警报系统组成。ODS的TSDB 构建在 HBase存储系统之上，如[26]中所述。图1显示了ODS组织方式的高级视图。来自运行在脸书主机上的服务的时间序列数据由ODS写入服务收集并写入 HBase。
ODS时间序列数据有两个消费者。第一个消费者是依赖制图系统的工程师，该系统从ODS生成图形和其他时间序列数据的直观表示，用于交互式分析。第二个消费者是我们的自动警报系统，该系统从 ODS读取计数器，将它们与健康、性能和诊断指标的预设阈值进行比较，并向oncall工程师和自动补救系统发出警报。
2.1.1 监控系统读取性能问题2013 年初，脸书的监控团队意识到其HBase时序存储系统无法扩展处理未来的读取负载。虽然交互式图表的平均读取延迟是可以接受的，但是P90的查询时间增加到了几秒钟，阻碍了我们的自动化。此外，用户正在自我审查他们的用户年龄，因为即使是几千个时间序列的中等规模查询的交互式分析也需要几十秒钟才能执行。在稀疏数据集上执行的较大查询会超时，因为HBase数据存储被调整为优先写入。虽然我们基于HBase的TSDB效率低下，但我们很快就对存储系统进行了大规模更换，因为 ODS的HBase存储拥有大约2PB 的数据[5]。脸书的数据仓库解决方案Hive也不合适，因为它的查询延迟比ODS 高几个数量级，而查询延迟和效率是我们主要关心的问题[27]。
接下来，我们将注意力转向内存缓存。ODS已经使用了一个简单的通读缓存，但它主要是针对多个仪表板共享相同时间序列的图表系统。一个特别困难的场景是当仪表板查询最近的数据点，在缓存中错过，然后发出请求直接发送到 HBase 数据存储。我们还考虑了基于独立Memcache[20]的直写缓存，但拒绝了它，因为向现有时间序列添加新数据需要一个读/写周期，从而导致Memcache服务器的流量非常高。我们需要更有效的解决方案。
2.2 Gorilla要求考虑到这些因素，我们确定了新服务的以下要求:
由一个字符串键标识的20亿个唯一的时间序列。 每分钟增加7亿个数据点(时间戳和值)。 存储数据26小时。 峰值时每秒超过40,000次查询。 读取在不到一毫秒的时间内成功。 支持15秒粒度的时间序列(每个时间序列每分钟 4 个点)。 两个内存中、不在同一位置的副本(用于灾难恢复容量)。 即使单个服务器崩溃，也始终提供读取服务。 能够快速扫描所有内存中的数据。 支持每年至少2倍的增长。 在第3节与其他 TSDB 系统进行简单比较后，我们在第4节详细介绍Gorilla的实现，首先在第4.1 节讨论其新的时间戳和数据值压缩方案。然后，我们将在第 4.4 节中描述Gorilla如何在单节点故障和区域性灾难的情况下保持高可用性。我们将在第5节描述Gorilla如何启用新工具。最后，我们在第6节描述了我们开发和部署Gorilla的经验。
三、与 TSDB 系统的比较有许多出版物详细介绍了数据挖掘技术，以有效地搜索、分类和聚类大量的时间序列数据[8,23,24]。这些系统展示了检查时间序列数据的许多用途，从聚类和分类[8,23]到异常检测[10,16] 到索引时间序列[9,12,24]。然而，很少有例子详细说明能够实时收集和存储大量时间序列数据的系统。Gorilla的设计侧重于对生产系统进行可靠的实时监控，与其他TSDB相比非常突出。Gorilla占据了一个有趣的设计空间，在面对优先于任何旧数据可用性的故障时，可用于读取和写入。
由于 Gorilla 从一开始就被设计为将所有数据存储在内存中，因此它的内存结构也不同于现有TSDB。但是，如果将Gorilla视为另一个磁盘上TSDB之前的时间序列数据内存存储的中间存储，那么Gorilla 可以用作任何 TSDB 的直写缓存(相对简单的修改)。Gorilla对摄取速度和水平扩展的关注与现有解决方案相似。
3.1 OpenTSDBOpenTSDB基于HBase[28]，非常接近我们用于长期数据的ODS HBase存储层。这两个系统依赖于相似的表结构，并且在优化和水平可伸缩性方面得出了相似的结论[26,28]。然而，我们发现支持构建高级监控工具所需的查询量需要比基于磁盘的存储所能支持的更快的查询。
与OpenTSDB不同，ODS HBase层确实为较旧的数据进行时间累积聚合以节省空间。这导致较旧的存档数据与ODS中较新的数据相比具有较低的时间粒度，而OpenTSDB将永远保留全分辨率数据。我们发现，更便宜的长时间查询和空间节省是值得的精度损失。</description></item></channel></rss>