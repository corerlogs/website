<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>服务治理 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</link><description>Recent content in 服务治理 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 07 Sep 2020 14:42:13 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>微服务治理：APM-SkyWalking-PHP内核扩展源码分析</title><link>https://icorer.com/icorer_blog/posts/microservice_skywalking_php_kernel_source_analyze/</link><pubDate>Mon, 07 Sep 2020 14:42:13 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/microservice_skywalking_php_kernel_source_analyze/</guid><description>SkyWalking APM作为服务遥测的关键技术点，为了能够更好地运用这项技术，我们需要拥有把握这项技术的底层能力。目前公司在PHP领域存活不少业务系统，针对PHP领域的APM技术，我们首先从分析这款PHP内核扩展程序下手。
一. 总体架构PHP内核在php-fpm运行模式下是短生命周期，短生命周期的脚本运行如果直接连接SkyWalking的oap-server会造成大量的性能损耗，而且php也不擅长grpc通信，因此借助mesh架构思想为PHP-FPM进程池增加一个数据SideCar，主要的结构如下图所示： 从上图可以看出，PHP内核扩展程序拦截内核运行数据（主要是关键的外部IO调用）、数据被发送给SideCar，SideCar流转数据到SkyWalking-Server，数据流还可以被SkyWalking进行分析、从而通过WebHook流转报警时间到相关后续平台里。
二. PHP内核扩展源码分析针对目前开源社区的SkyWalking-PHP内核源码进行分析，源码的分析主要包括以下几部分：
工程结构分析 关键生命周期分析 关键运行函数Hook分析 2.1 工程结构分析SkyWalking PHP内核组件工程结构比较简单，主要是站在PHP内核基础上进行扩展设计与实现，主要包含的扩展文件有：
b64.h：base64编码函数的头文件、主要包含内存分配、base64字符表、b64_encode及b64_decode、b64_decode_ex的函数声明。 decode.c：base64序列化的函数具体实现。 encode.c：base64反序列化的函数具体实现。 components.h：针对skywalking协议中的component部分进行宏定义、这部分是apm协议的一部分，例如：tomcat、httpclient、dubbo、okhttp、grpc、jedis、更多查看附录1。 php_skywalking.h：关键的内核扩展声明部分，主要包括：APM协议宏定义、Redis指令类别、memcache指令类别、ContextCarrier上下文结构体、apm拦截所需的关键函数定义（具体见附录二），apm关键函数hook定义（具体见附录三），全局变量定义（具体见附录四）。 skywalking.c：具体内核扩展实现文件，里面包含了MI-MS、RI-RS、关键函数Hook等处理逻辑。 2.2 关键生命周期分析这块将针对内核扩展关键生命周期进行分析。
2.2.1 关键生命期函数Hook定义1static void (*ori_execute_ex)(zend_execute_data *execute_data); //PHP内核原始PHP层执行流程函数指针 2static void (*ori_execute_internal)(zend_execute_data *execute_data, zval *return_value);//PHP原始内核执行函数指针 3ZEND_API void sky_execute_ex(zend_execute_data *execute_data);//skywalking针对PHP层执行函数的替换指针 4ZEND_API void sky_execute_internal(zend_execute_data *execute_data, zval *return_value);//skywalking针对原始内核执行函数的替换指针 2.2.2 php.ini配置解析周期 1PHP_INI_BEGIN() 2#if SKY_DEBUG 3 STD_PHP_INI_BOOLEAN(&amp;#34;skywalking.enable&amp;#34;, &amp;#34;1&amp;#34;, PHP_INI_ALL, OnUpdateBool, enable, zend_skywalking_globals, skywalking_globals) //读取skywalking.enable配置项 4#else 5 STD_PHP_INI_BOOLEAN(&amp;#34;skywalking.enable&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, enable, zend_skywalking_globals, skywalking_globals) //读取skywalking.enable配置项 6#endif 7 STD_PHP_INI_ENTRY(&amp;#34;skywalking.</description></item><item><title>微服务：请求熔断原理</title><link>https://icorer.com/icorer_blog/posts/microservices-principles-of-request-fusing/</link><pubDate>Wed, 06 Jun 2018 13:27:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/microservices-principles-of-request-fusing/</guid><description>伴随微服务，出现了很多新鲜的名词，其实剥去外衣并没有那么高大上。
今天要谈到的，叫做”熔断”，一个典型的开源实现是Hystrix（JAVA实现）。
背景一个分布式系统中，服务间互相调用错综复杂，假设某个基础服务宕机，那么就会导致若干上游调用方出现访问超时，进而引起上游重试，导致宕机的基础服务遭受到数倍的流量放大，更加无法恢复服务。
这种恶劣的情况并不会就此结束，上游因为调用基础服务超时而变慢，导致上游的上游超时…异常向上蔓延，最终导致整个分布式系统”雪崩”。
“熔断”就是为了避免”雪崩”而生的，它的思路是在调用方增加一种”避让”机制，当下游出现异常时能够停止（熔断）对下游的继续请求，当等待一段时间后缓慢放行部分的调用流量，并当这部分流量依旧正常的情况下，彻底解除”熔断”状态。
听起来，流程不算复杂吧？整个流程图如下，看不懂没关系，继续往下阅读吧。
#健康统计
判断下游正常的前提是统计最近一段时间内，下游的调用成功率，因此需要一个健康统计模块，记录最近N秒内的总请求数，成功请求数，失败请求数，是由业务调用后将结果打点到健康统计模块中。
下游健康的标志，是最近N秒的成功率大于某个阀值，那么代表下游健康。
因为时间不停的前进，要统计最近N秒内的成功率，显然仅仅维护3个数字是不足以表达的，因此这里一般会使用”时间窗口”来实现。
如最上面的图片所示，整个时间窗口由10个槽位（bucket）构成，每个槽位代表1秒钟，整个时间窗口表达了最近10秒的健康统计，最右侧的bucket记录了最近1秒的成功/失败请求数量，仅此而已。
随着时间每过去1秒，整个窗口会向右滑动1格，最左侧的1个槽位被淘汰，最右侧加入当前1秒的新槽位，这就是时间窗口的实现原理。
当然，我们在实现的时候不会写一个定时器每秒去更新时间窗口，而是当打点接口被调用的时候进行计算和窗口滑动。为了更清晰的帮助你理解，我写了一个简短的PHP实现：
1&amp;lt;?php 2 3// 时间窗口10个桶 4define(&amp;#34;BUCKET_NUM&amp;#34;, 10); 5// 成功率大于该值为健康 6define(&amp;#34;HEALTHY_RATE&amp;#34;, 0.8); 7 8// 健康统计 9class HealthStats { 10 private $service = &amp;#39;&amp;#39;; 11 private $buckets = []; 12 private $curTime = 0; 13 14 public function __construct($service) 15 { 16 $this-&amp;gt;service = $service; 17 $this-&amp;gt;buckets = array_fill(0, BUCKET_NUM, [&amp;#39;success&amp;#39; =&amp;gt; 0, &amp;#39;fail&amp;#39; =&amp;gt; 0,]); 18 } 19 20 private function shiftBuckets() 21 { 22 $now = time(); 23 24 $timeDiff = $now - $this-&amp;gt;curTime; 25 if (!</description></item></channel></rss>