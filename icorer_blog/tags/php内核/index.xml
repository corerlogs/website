<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PHP内核 on 笔迹-工匠之芯</title><link>https://icorer.com/icorer_blog/tags/php%E5%86%85%E6%A0%B8/</link><description>Recent content in PHP内核 on 笔迹-工匠之芯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 22 Feb 2019 13:16:18 +0800</lastBuildDate><atom:link href="https://icorer.com/icorer_blog/tags/php%E5%86%85%E6%A0%B8/index.xml" rel="self" type="application/rss+xml"/><item><title>PHP-CURL-Guzzle-HTTP-连接复用内核原理</title><link>https://icorer.com/icorer_blog/posts/php-curl-guzzle-http-connection-reuse-kernel-principle/</link><pubDate>Fri, 22 Feb 2019 13:16:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/php-curl-guzzle-http-connection-reuse-kernel-principle/</guid><description>PHP-CURL连接复用内核原理0.写在前面PHP是一个时代的产物,它的底层支持是C语言,因此它在CPU密集型计算或者系统内核调用上有天生的优势,Zend引擎把PHP执行生命期分成了五个阶段1,这五个阶段并不是全部都能常驻进程,这种模式下,对于很多使用场景会造成不好的影响,比如网络IO.
对于网络IO中的HTTP请求 , 很多工程师使用 php-curl 系列函数 . 所以这篇文章将从内核角度讲解php如何支持curl请求的连接复用(这里的连接复用也是指在一个RINIT2&amp;ndash;&amp;gt;RSHUTDOWN3周期内复用).
1. PHP引擎借力CURL库函数PHP需要使用curl组件进行HTTP系列通信,因此它在底层需要curl有相关的支撑,所以curl首先需要在系统环境中被部署或者被编译,并对外部提供动态链接库文件,PHP通过调用curl相关的动态链接库函数来进行自己内核函数的实现过程.
多说一句,PHP并不一定需要curl才能完成http请求,因为php引擎中已经包含了socket完善的函数库,所以有些php扩展包支持curl和原生stream_socket(tcp)两种模式,例如:guzzle
2. PHP-CURL基础数据结构(php_curl结构体) 1147 typedef struct { 2148 php_curl_write *write; 3149 php_curl_write *write_header; 4150 php_curl_read *read; 5151 zval std_err; 6152 php_curl_progress *progress; 7153 #if LIBCURL_VERSION_NUM &amp;gt;= 0x071500 /* Available since 7.21.0 */ 8154 php_curl_fnmatch *fnmatch; 9155 #endif 10156 } php_curl_handlers; 11 12173 typedef struct { 13174 CURL *cp; //curl库 实体结构体 14175 php_curl_handlers *handlers; //header 头部 15176 zend_resource *res; //引擎资源指针 16177 struct _php_curl_free *to_free; 17178 struct _php_curl_send_headers header; 18179 struct _php_curl_error err; //错误码 19180 zend_bool in_callback; 20181 uint32_t* clone; 21182 } php_curl; 3.</description></item><item><title>PHP内核函数: microtime</title><link>https://icorer.com/icorer_blog/posts/php-kernel-function-analysis-microtime/</link><pubDate>Fri, 22 Feb 2019 13:04:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/php-kernel-function-analysis-microtime/</guid><description>microtime Description ¶
microtime ([ bool $get_as_float = FALSE ] ) : mixed
microtime() returns the current Unix timestamp with microseconds. This function is only available on operating systems that support the gettimeofday() system call.
source file:** /php-src/ext/standard/microtime.c**
Part-1 : 内核抛出定义1.1 源码185 /* {{{ proto mixed microtime([bool get_as_float]) 286 Returns either a string or a float containing the current time in seconds and microseconds */ 387 PHP_FUNCTION(microtime) 488 { 589 _php_gettimeofday(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0); 690 } 791 /* }}} */ Part-2 : 源码分析2.</description></item><item><title>源码阅读：YAF框架系列文章(3) - (yaf_application.c)</title><link>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-3---yaf_application.c/</link><pubDate>Thu, 22 Nov 2018 15:33:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-3---yaf_application.c/</guid><description>这个文件主要围绕Yaf_Application类的注册，这里，按照倒叙的方式来进行讲解。
一、注册yaf_application类
1YAF_STARTUP_FUNCTION(application) { 2//定义一个zend_class_entry实例变量 3	zend_class_entry ce; 4 5/* 初始化一个CLASS ENTRY 6#define YAF_INIT_CLASS_ENTRY(ce, name, name_ns, methods) \ 7	if(YAF_G(use_namespace)) { \ 8	INIT_CLASS_ENTRY(ce, name_ns, methods); \ 9	} else { \ 10	INIT_CLASS_ENTRY(ce, name, methods); \ 11	} 12*/ 13	YAF_INIT_CLASS_ENTRY(ce, &amp;#34;Yaf_Application&amp;#34;, &amp;#34;Yaf\\Application&amp;#34;, yaf_application_methods); 14 15	// https://src.icorer.com/xref/php-src/Zend/zend_API.c#2752 16	//注册一个类到内核类表中 17	yaf_application_ce = zend_register_internal_class_ex(&amp;amp;ce, NULL); 18	//修改类属性为终极类 19	yaf_application_ce-&amp;gt;ce_flags |= ZEND_ACC_FINAL; 20 21	//声明一个属性定义，为Protected类型 22	zend_declare_property_null(yaf_application_ce, 23	ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_CONFIG), ZEND_ACC_PROTECTED); 24	zend_declare_property_null(yaf_application_ce, 25	ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_DISPATCHER), ZEND_ACC_PROTECTED); 26	27	//声明一个NULL元素，为static protected类型 28	zend_declare_property_null(yaf_application_ce, 29	ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_APP), ZEND_ACC_STATIC | ZEND_ACC_PROTECTED); 30	zend_declare_property_null(yaf_application_ce, 31	ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_MODULES), ZEND_ACC_PROTECTED); 32	//声明一个布尔类型的元素，为protected类型 33	zend_declare_property_bool(yaf_application_ce, 34	ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_RUN), 0, ZEND_ACC_PROTECTED); 35	//声明一个字符串类型的元素 ， 为protected类型 36	zend_declare_property_string(yaf_application_ce, 37	ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_ENV), YAF_G(environ_name), ZEND_ACC_PROTECTED); 38	//声明一个长整数类型的元素，为protected类型 39	zend_declare_property_long(yaf_application_ce, 40	ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_ERRNO), 0, ZEND_ACC_PROTECTED); 41	zend_declare_property_string(yaf_application_ce, 42	ZEND_STRL(YAF_APPLICATION_PROPERTY_NAME_ERRMSG), &amp;#34;&amp;#34;, ZEND_ACC_PROTECTED); 43 44	return SUCCESS; 45} 二、添加类方法 上面讲解了创建一个类的过程，但是类中还有很多方法，通过yaf_application_methods方法集进行管理，具体对于函数的添加代码如下。</description></item><item><title>高级编程：PHP扩展的 INI 配置文件操作</title><link>https://icorer.com/icorer_blog/posts/ini-configuration-file-manipulation-for-php-extensions/</link><pubDate>Thu, 22 Nov 2018 10:24:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/ini-configuration-file-manipulation-for-php-extensions/</guid><description>Extension INI Entries (扩展INI配置项)Defining php.ini directives (i.e., INI entries) in an extension is easy. Most of the work involves setting up the global struct explained earlier in Section 14.10.3 Each entry in the INI structure is a global variable in the extension and thus has an entry in the global struct and is accessed using FOO_G(my_ini_setting). For the most part you can simply comment out the indicated sections in the skeleton created by ext_skel to get a working INI directive, but we will walk through it here anyway.</description></item><item><title>源码阅读：YAF框架系列文章(2) - (yaf.c)</title><link>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-2---yaf.c/</link><pubDate>Thu, 22 Nov 2018 10:04:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-2---yaf.c/</guid><description>这个文件是yaf框架的整体组成框架文件，因为yaf的设计思路是模块化的，因此在这个文件中进行了总体整合。整合的思路分为以下几个部分。
INI配置文件的解析 注册系统使用的常量 注册各个模块 对扩展模块的各个生命期做拦截监控 注册扩展模块 一、INI配置文件解析功能
在php_yaf.h文件中对于全局变量进行了定义工作，随后在yaf.c中进行了声明工作，声明操作 ZEND_DECLARE_MODULE_GLOBALS(yaf); ，声明操作之后，并在PHP_GINIT_FUNCTION钩子函数期进行了全局变量的初始化工作，框架进行了配置文件的加载过程，配置文件的操作定义如下：
1/** {{{ PHP_INI_MH(OnUpdateSeparator) 2 */ 3PHP_INI_MH(OnUpdateSeparator) { 4	YAF_G(name_separator) = ZSTR_VAL(new_value); 5	YAF_G(name_separator_len) = ZSTR_LEN(new_value); 6	return SUCCESS; 7} 8/* }}} */ 9 10/** {{{ PHP_INI 11 */ 12PHP_INI_BEGIN() 13	STD_PHP_INI_ENTRY(&amp;#34;yaf.library&amp;#34;, &amp;#34;&amp;#34;, PHP_INI_ALL, OnUpdateString, global_library, zend_yaf_globals, yaf_globals) 14	STD_PHP_INI_BOOLEAN(&amp;#34;yaf.action_prefer&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, action_prefer, zend_yaf_globals, yaf_globals) 15	STD_PHP_INI_BOOLEAN(&amp;#34;yaf.lowcase_path&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, lowcase_path, zend_yaf_globals, yaf_globals) 16	STD_PHP_INI_BOOLEAN(&amp;#34;yaf.use_spl_autoload&amp;#34;, &amp;#34;0&amp;#34;, PHP_INI_ALL, OnUpdateBool, use_spl_autoload, zend_yaf_globals, yaf_globals) 17	STD_PHP_INI_ENTRY(&amp;#34;yaf.</description></item><item><title>源码阅读：YAF框架系列文章(1) - (php_yaf.h)</title><link>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-1---php_yaf.h/</link><pubDate>Wed, 21 Nov 2018 14:30:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/source-code-reading-yaf-framework-series-articles-1---php_yaf.h/</guid><description>这个文件的核心使命是构建yaf基础定义，这部分定义主要包括
对于内核函数的宏定义 对于框架变量类型的宏定义 对于框架所使用的全局变量进行定义 一、对于内核函数进行宏定义
1#define YAF_STARTUP_FUNCTION(module) ZEND_MINIT_FUNCTION(yaf_##module) 2#define YAF_RINIT_FUNCTION(module)	ZEND_RINIT_FUNCTION(yaf_##module) 3#define YAF_STARTUP(module)	ZEND_MODULE_STARTUP_N(yaf_##module)(INIT_FUNC_ARGS_PASSTHRU) 4#define YAF_SHUTDOWN_FUNCTION(module) ZEND_MSHUTDOWN_FUNCTION(yaf_##module) 5#define YAF_SHUTDOWN(module)	ZEND_MODULE_SHUTDOWN_N(yaf_##module)(INIT_FUNC_ARGS_PASSTHRU) 这个部分表现了yaf框架的模块化设计，yaf通过宏定义对于模块相关ZEND函数进行了封装，每个模块都将有自己的模块加载、关闭函数。例如YAF_STARTUP_FUNCTION(module) 的宏定义展开形式就是 zm_startup_yaf_module(int type, int module_number)
二、对于框架自定义变量类型进行定义
1#define yaf_application_t	zval 2#define yaf_view_t zval 3#define yaf_controller_t	zval 4#define yaf_request_t	zval 5#define yaf_router_t	zval 6#define yaf_route_t	zval 7#define yaf_dispatcher_t	zval 8#define yaf_action_t	zval 9#define yaf_loader_t	zval 10#define yaf_response_t	zval 11#define yaf_config_t	zval 12#define yaf_registry_t	zval 13#define yaf_plugin_t	zval 14#define yaf_session_t	zval 15#define yaf_exception_t	zval 三、对内核中将用到的函数做声明</description></item><item><title>设计文档：PulseFlow_IPC_Backend</title><link>https://icorer.com/icorer_blog/posts/design-document-pulseflow_ipc_backend/</link><pubDate>Wed, 22 Aug 2018 21:54:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/design-document-pulseflow_ipc_backend/</guid><description>PulseFLow还有一部分功能是集中在信息后端的，当PHP引擎发送信息给后端程序后，后端程序再把信息进行组装，发给下一级程序。
一 . 组成部分后端程序，分为以下几个部分：
配置中心：（配置文件 + 配置解析器）（采用ini文件配置格式）。
进程管理器：维持进程池，保持进程池的存活量。
信息发送： 信息组装 + 信息发送（UDP发送）
二. 工作流程2.1 总体流程图 2.2 系统模型（进程池模型） 后端组件采用进程池模型，主程序启动时，首先读取配置文件中关于进程池大小的配置选项，然后启动相关数量的子工作进程。
随后主进程进入稳定性极高的进程池监控流程，如果拦截到子进程有挂掉的情况发生，读取挂掉的状态并在相应的进程池位置开辟新的工作子进程。
通过进程池可以大大提高进程读取内核消息队列的效率，通过进程池管理程序可以大大提高整体后端程序的稳定性。
2.3 功能分配1. 主进程负责【管理进程池】，负责【创建可用的内核消息队列】。2. 工作子进程负责 【监控内核消息队列】&amp;mdash;&amp;gt;【读取消息】&amp;mdash;&amp;gt;【组装信息】&amp;mdash;&amp;gt;【UDP发送下游】</description></item><item><title>设计文档: PulseFLow PHP性能监控插件</title><link>https://icorer.com/icorer_blog/posts/design-documentation-pulseflow-php-performance-monitoring-plugin/</link><pubDate>Fri, 17 Aug 2018 13:18:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/design-documentation-pulseflow-php-performance-monitoring-plugin/</guid><description>一. 背景描述随着公司PHP项目体的不断增大，随着不同工程师的功能迭代，如何有效获取PHP项目的执行性能，对于系统整体模块显得异常重要，PulseFlow是一个公司团队内部自研地性能跟踪扩展，它可以在程序员无感知的情况下有效跟踪每一个函数的执行效率，主要分析CPU时间消耗、内存大小消耗，执行次数这三个指标，下面我们将从 PHP生命期 到 组件设计 到 性能优化这三个方面来进行阐述组件。
二 . 插件和 PHP生命期PHP生命周期通常包括 MI（模块初始化）、RI（请求初始化）、RS（请求终止）、MS（模块终止） 这四个步骤，这四个部分使我们能够进行功能渗透的生命期子过程。在MI阶段会包含INI配置文件的解析，在RI阶段会针对每一个CGI请求进行请求初始化操作，在RS阶段会针对每一个请求的关闭进行相关功能拦截。并不是每一次执行PHP均要经历这四个阶段，在CLI模式下，会完整经历这四个阶段，在PHP-FPM这种类CGI模式下，为了提高请求性能，并不会经历过全部阶段，它会着重经历RI、RS阶段。
了解了PHP的生命期轮廓后，我们绘制了下图阐述大概执行流程所属的生命期阶段。
三. 插件和ZEND引擎在上述的PHP生命周期阶段内，我们可以在不同的阶段分块插件的功能，其次，我们还需要和ZEND引擎打交道，因为ZEND引擎是真正的执行者，我们目前需要托管他们的 zend_execute_ex 内核函数，这个内核函数就是C语言的函数指针，这个内核函数顾名思义就是PHP的内核执行函数。
为了阐述方便，我们使用一个执行流程图，来看一下插件该如何拦截ZEND引擎的执行流程。 三. 开始造轮子3.1 插件流程分析首先，我们需要构建插件的执行流程，及各个部分的信息传送关系，我们目前把插件分为两部分，一部分是PHP扩展，用于在PHP生命周期内来进行性能拦截，这部分信息通常存储于 系统进程堆区 或者 系统进程静态区域，第二部分是后台数据转发程序，它负责从信息通道里读取PHP扩展写入的信息，并转发给相应的下一级程序，相关流程图如下。 3.2 环境选择（系统组件选择）这一步我们选择相应的环境，或者称之为系统组件选择，我们在选择相应组件时根据插件各个执行周期来进行选择。
3.2.1 PHP引擎环境 （PHP7+）首先PHP引擎我们选择7.0以上，因为 PHP7 与 PHP5 的内核数据结构差距甚大，目前针对PHP7，后面会移植代码覆盖PHP5版本。
3.2.2 插件语言 （C）虽然现在编写PHP扩展可以使用Go语言、zephir语言、但是为了和原PHP内核及Linux操作系统进行最好性能交互，我们选择C语言进行研发。
3.2.3 信息队列（System V 消息队列）在3.1中，我们提及了一个很重要的组件，并用红色进行了标记，PHP扩展和后台信息转发程序 如何 沟通？哪一条路最快？
为了选择这条信息通路，我们做了大量实验，覆盖面积包括TCP、unix domain socket、zeromq、nanomsg、共享内存、posix 内核消息队列、system V 内核消息队列，目前最快的是共享内存，其次是system V 和 posix 内核队列。
共享内存虽然是最快的，但是我们目前针对的模型是 多写、多读，为了不对PHP-FPM 内存 和 对系统内存能够更好更有力管理，在第一版中我们将采用system V内核队列，但是我们也已经开放了 共享内存版本的分支 和 给予epoll模型的 posix 内核队列 代码分支，这两个代码分值中均写好模型代码，在后面阶段将会一步步融入主线版本。
为什么选择 system V 队列？ 首先system V内核队列在 Linux Kernel 2.</description></item><item><title>开源项目：PulseFLow 性能跟踪扩展</title><link>https://icorer.com/icorer_blog/posts/open-source-project-pulseflow-performance-tracking-extension/</link><pubDate>Wed, 25 Jul 2018 13:48:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/open-source-project-pulseflow-performance-tracking-extension/</guid><description>背景描述随着公司PHP项目体的不断增大，随着不同工程师的功能迭代，如何有效获取PHP项目的执行性能，对于系统整体模块显得异常重要，PulseFlow是一个性能跟踪扩展，它可以在程序员无感知的情况下有效跟踪每一个函数的执行效率，主要分析CPU时间消耗、内存大小消耗，这个组件除了能够快速记录每个函数体的性能信息，还具备一系列的发送机制，主要包括共享内存队列（System V 和 Posix）、UDP、Unix Domain Socket 等模式。
编译安装此为PHP扩展，按照正常的扩展安装，我们需要执行以下几步操作：
git clone https://github.com/gitsrc/PulseFlow.git 进入源码目录 phpize ./configure &amp;ndash;with-php-config= （ php-config文件路径） CFLAGS=&amp;rsquo;-g -lrt&amp;rsquo; CXXFLAGS=&amp;rsquo;-lrt' make make install 编译特别注意由于在扩展中使用了 posix 共享内存队列，所以我们编译时需要引入lrt库，上面在configure过程中附加的 CFLAGS 和 CXXFLAGS 参数用来给Makefile中的相应字段添加 -lrt，最终构造完后的Makefile对应配置应该为：
1CFLAGS = -g -lrt -O0 2 3CXXFLAGS = -lrt -g -O0 设计点1：PHP INI 配置选项PulseFlow由于是一个基于C语言的PHP扩展，为了保持程序体的扩展性，配置选项一律从php.ini文件中读取，本节将描述所有与扩展程序有关系的配置信息。
1.1 扩展功能开关参数 （PulseFlow.enabled）1.1.1 参数介绍这个参数是插件的功能开关，属于布尔类型，有效参数如下，默认 false：
true：开启 false：关闭 1.2 日志功能开关参数 （PulseFlow.debug）1.2.1 参数介绍这个参数是控制插件是否向页面输出调试信息，有效参数如下，默认 false：
true：开启 false：关闭 1.3 禁止跟踪函数列表 （PulseFlow.disable_trace_functions）1.3.1 参数介绍这个参数是一个逗号分隔的字符串，代表一系列函数列表，这个函数列表内的函数不进行性能跟踪，默认空字符串。
配置样例：PulseFlow.disable_trace_functions = &amp;ldquo;getLoader,findFile,loadClassLoader,getInitializer,findFileWithExtension,&amp;rdquo;
1.4 禁止跟踪类列表 （PulseFlow.disable_trace_class）1.4.1 参数介绍这个参数是一个逗号分隔的字符串，代表一系列类列表，这个类列表内的类不进行性能跟踪，默认空字符串。</description></item><item><title>环境搭建：CLion 搭建 PHP 扩展开发环境</title><link>https://icorer.com/icorer_blog/posts/clion-builds-a-php-extension-development-environment/</link><pubDate>Tue, 10 Jul 2018 10:06:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/clion-builds-a-php-extension-development-environment/</guid><description>#1. PHP扩展代码框架搭建 此处，可以参考本博客原来的文章进行框架代码搭建。 【PHP扩展开发1：代码框架搭建】
2. 从源文件导入CLion工程 点击clion菜单栏File -&amp;gt; Import Project 选择扩展目录 -&amp;gt; 选择项目所要的文件 -&amp;gt; 点击确认 因为clion是由CMakeList.txt文件进行，所以当导入后clion会自动生成基本的配置文件。
#3. 修改CMakeList.txt 加入库文件索引等，样例配置如下。
1cmake_minimum_required(VERSION 3.10) 2project(PulseFlow C) 3 4set(CMAKE_C_STANDARD 11) 5 6set(SOURCE_FILES 7 php_PulseFlow.h 8 PulseFlow.c) 9 10add_executable(PulseFlow ${SOURCE_FILES}) 11 12add_custom_target(makefile COMMAND make &amp;amp;&amp;amp; sudo make install WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}) 13 14 15include_directories(.) 16set(PHP_SOURCE /usr/local/php/include/php) 17 18include_directories(${PHP_SOURCE}/main) 19include_directories(${PHP_SOURCE}/Zend) 20include_directories(${PHP_SOURCE}/sapi) 21include_directories(${PHP_SOURCE}/pear) 22include_directories(${PHP_SOURCE}) #4. 调试代码
4.1 在CMakeList.txt文件中添加编译命令1add_custom_target(makefile COMMAND make &amp;amp;&amp;amp; sudo make install WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}) 4.2 添加运行配置 (很重要 一定要选择 makefile编译)</description></item><item><title>源码阅读：PHP TSRM 线程安全管理器</title><link>https://icorer.com/icorer_blog/posts/source-code-reading-php-tsrm-thread-safety-manager/</link><pubDate>Sun, 08 Jul 2018 23:49:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/source-code-reading-php-tsrm-thread-safety-manager/</guid><description>TSRM 简介在查看php源代码或开发php扩展的时候，会出现大量 TSRMLS_ 宏字样在函数参数的位置，这些宏就是Zend为线程安全机制所提供的（Zend Thread Safety，简称ZTS）用于保证线程的安全 , 是防止多线程环境下以模块的形式加载并执行PHP解释器，导致内部一些公共资源读取错误，而提供的一种解决方法。
什么时候需要用 TSRM只要服务器是多线程环境并且PHP以模块的形式提供，那么就需要TSRM启用，例如apache下的 worker 模式(多进程多线程)环境，这种情况就必须要使用线程安全版本的PHP，也就是要启用TSRM , 在Linux下是编译PHP的时候指定是否开启TSRM、windows下是提供线程安全版本和非线程安全版本的PHP。
PHP 如何实现 TSRM正常多线程环境下操作公共的资源都是加上互斥锁，而PHP没有选择加锁，因为加锁可能多少会有些性能损耗，PHP的解决方法是为每一个线程都copy一份当前PHP内核所有的公共资源过来，每个线程指向自己的公共资源区，互不影响，各操作各的公共资源。
公共资源是什么就是各种各样的 struct 结构体 定义。
#TSRM数据结构
tsrm_tls_entry结构体tsrm_tls_entry 线程结构体、每个线程都有一份该结构体。
1typedef struct _tsrm_tls_entry tsrm_tls_entry; 2struct _tsrm_tls_entry { 3 void **storage; 4 int count; 5 THREAD_T thread_id; 6 tsrm_tls_entry *next; 7} 8static tsrm_tls_entry **tsrm_tls_table = NULL //线程指针表头指针 9static int tsrm_tls_table_size; //当前线程结构体数量 ###字段说明
void **storage ：资源指针、就是指向自己的公共资源内存区 int count : 资源数、就是 PHP内核 + 扩展模块 共注册了多少公共资源 THREAD_T thread_id ： 线程id tsrm_tls_entry *next：指向下一个线程指针，因为当前每一个线程指针都存在一个线程指针表里（类似于hash表），这个next可以理解成是hash冲突链式解决法.</description></item><item><title>PHP扩展开发2.2：线程安全</title><link>https://icorer.com/icorer_blog/posts/php-extension-development-2.2-thread-safety/</link><pubDate>Fri, 06 Jul 2018 17:26:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/php-extension-development-2.2-thread-safety/</guid><description>背景介绍 线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
一般来说，线程安全的函数应该为每个调用它的线程分配专门的空间，来储存需要单独保存的状态（如果需要的话），不依赖于“线程惯性”，把多个线程共享的变量正确对待（如，通知编译器该变量为“易失（volatile）”型，阻止其进行一些不恰当的优化），而且，线程安全的函数一般不应该修改全局对象。
很多C库代码（比如某些strtok的实现，它将“多次调用中需要保持不变的状态”储存在静态变量中，导致不恰当的共享）不是线程安全的，在多线程环境中调用这些函数时，要进行特别的预防措施，或者寻找别的替代方案。 更多线程安全信息请浏览维基百科：链接地址
在PHP初期，是作为单进程的CGI来运行的，所以并没有考虑线程安全问题。我们可以随意的在全局作用域中设置变量并在程序中对他进行修改、访问，内核申请的资源如果没有正确的释放，也会在CGI进程结束后自动地被清理干净。
后来，php被作为apache多进程模式下的一个模块运行，但是这仍然把php局限在一个进程里，我们设置的全局变量，只要在每个请求之前将其正确的初始化，并在每个请求之后正确的清理干净，便不会带来什么麻烦。由于对于一个进程来说，同一个时间只能处理一个请求，所以这是内核中加入了针对每个请求的内存管理功能，来防止服务器资源利用出现错误。
随着使用在多线程模式的软件系统越来越多，php内核中亟需一种新的资源管理方式，并最终在php内核中形成了一个新的抽象层：TSRM(Thread Safe Resource Management)。
线程安全与非线程安全在一个没有线程的程序中，我们往往倾向于把全局变量声明在源文件的顶部，编译器会自动的为它分配资源供我们在声明语句之下的程序逻辑中使用。（即使通过fork()出一个子进程，它也会重新申请一段内存，父子进程中的变量从此没有了任何联系）
但是在一个多线程的程序中，如果我们需要每个线程都拥有自己独立的资源的话，便需要为每个线程独立开辟出一个区域来存放它们各自的资源，在使用资源的时候，每个线程便会只在自己的那一亩三分地里找，而不会拔了别人的庄稼。
线程安全资源池（Thread-SafeDataPools）在扩展的ModuleInit里，扩展可以调用ts_allocate_id()函数来告诉 TRSM 自己需要多少资源。TRSM 接收后更新系统使用的资源，并得到一个指向刚分配的那份资源的id。
1typedef struct { 2	int sampleint; 3	char *samplestring; 4} php_sample_globals; 5int sample_globals_id; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 ts_allocate_id(&amp;amp;sample_globals_id, 10 sizeof(php_sample_globals), 11 (ts_allocate_ctor) php_sample_globals_ctor, 12 (ts_allocate_dtor) php_sample_globals_dtor); 13 return SUCCESS; 14} 当一个请求需要访问数据段的时候，扩展从TSRM层请求当前线程的资源池，以ts_allocate_id()返回的资源ID来获取偏移量。换句话说，在代码流中，你可能会在前面所说的MINIT语句中碰到SAMPLE_G(sampleint)=5;这样的语句。在线程安全的构建下，这个语句通过一些宏扩展如下：
1(((php_sample_globals*)(*((void ***)tsrm_ls))[sample_globals_id-1])-&amp;gt;sampleint = 5; 如果你看不懂上面的转换也不用沮丧，它已经很好的封装在PHPAPI中了，以至于许多开发者都不需要知道它怎样工作的。
当不在线程环境时因为在PHP的线程安全构建中访问全局资源涉及到在线程数据池查找对应的偏移量，这是一些额外的负载，结果就是它比对应的非线程方式（直接从编译期已经计算好的真实的全局变量地址中取出数据）慢一些。 考虑上面的例子，这一次在非线程构建下：
1typedef struct { 2 int sampleint; 3 char *samplestring; 4} php_sample_globals; 5php_sample_globals sample_globals; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 php_sample_globals_ctor(&amp;amp;sample_globals TSRMLS_CC); 10 return SUCCESS; 11} 首先注意到的是这里并没有定义一个int型的标识去引用全局的结构定义， 只是简单的在进程的全局空间定义了一个结构体。 也就是说SAMPLE_G(sampleint) = 5;展开后就是sample_globals.</description></item><item><title>PHP扩展开发2.1：PHP生命周期</title><link>https://icorer.com/icorer_blog/posts/php-extension-development-2.1-php-lifecycle/</link><pubDate>Fri, 06 Jul 2018 16:14:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/php-extension-development-2.1-php-lifecycle/</guid><description>#1. PHP SAPI 无论是Web模式、FastCgi模式、CLI模式，PHP的工作原理都是一样的，都是作为一种SAPI在运行（Server Application Programming Interface : the API sed by PHP to interface with Web Servers）。当我们在终端敲入php这个命令时候，它使用的是&amp;quot;”command lines api！它就像一个mini的web服务器一样来支持php完成这个请求，请求完成后再重新把控制权交给终端。简单来说,SAPI就是PHP和外部环境的代理器。它把外部环境抽象后,为内部的PHP提供一套固定的,统一的接口,使得PHP自身实现能够不受错综复杂的外部环境影响，保持一定的独立性
#2. PHP的启动与终止 PHP的启动和终止有两层含义，第一层是基于宿主进程、第二层是基于用户请求，前者被称为模块、后者成为请求。
在最初的初始化时候，就是PHP随着Apache的启动而诞生在内存里的时候，它会把自己所有已加载扩展的MINIT方法(全称Module Initialization，是由每个模块自己定义的函数。)都执行一遍。在这个时间里，扩展可以定义一些自己的常量、类、资源等所有会被用户端的PHP脚本用到的东西。但你要记住，这里定义的元素都会随着Apache常驻内存，可以被所有请求使用，直到Apache卸载掉PHP模块！
内核中预置了PHP_MINIT_FUNCTION()宏函数，来帮助我们实现这个功能：
1int minit_startTime = 0 ; 2PHP_MINT_FUNCTION(extension_name){ 3 minit_startTime = time(NULL); 4	php_printf(&amp;#34;%d\n&amp;#34;,minit_startTime); 5	return SUCCESS; 6} 当一个页面请求到来时候，PHP会迅速的开辟一个新的环境，并重新扫描自己的各个扩展，遍历执行它们各自的RINIT方法(俗称Request Initialization)，这时候一个扩展可能会初始化在本次请求中会使用到的变量等，还会初始化等会儿用户端（即PHP脚本）中的变量之类的，内核预置了PHP_RINIT_FUNCTION()这个宏函数来帮我们实现这个功能：
1int rinit_startTime = 0 ; 2PHP_RINIT_FUNCTION(extension_name){ 3 rinit_startTime = time(NULL); 4 php_printf(&amp;#34;%d\n&amp;#34;,rinit_startTime); 5 return SUCCESS; 6} 好了，现在这个页面请求执行的差不多了，可能是顺利的走到了自己文件的最后，也可能是出师未捷，半道被用户给die或者exit了，这时候PHP便会启动回收程序，收拾这个请求留下的烂摊子。它这次会执行所有已加载扩展的RSHUTDOWN（俗称RequestShutdown）方法，这时候扩展可以抓紧利用内核中的变量表之类的做一些事情，因为一旦PHP把所有扩展的RSHUTDOWN方法执行完，便会释放掉这次请求使用过的所有东西，包括变量表的所有变量、所有在这次请求中申请的内存等等。
内核预置了PHP_RSHUTDOWN_FUNCTION宏函数来帮助我们实现这个功能
1PHP_RSHUTDOWN_FUNCTION(extension_name){ 2 FILE*fp=fopen(&amp;#34;time_rshutdown.txt&amp;#34;,&amp;#34;a+&amp;#34;); 3 fprintf(fp,&amp;#34;%ld\n&amp;#34;,time(NULL)); 4 fclose(fp); 5 return SUCCESS; 6} 前面该启动的也启动了，该结束的也结束了，现在该Apache老人家歇歇的时候，当Apache通知PHP自己要Stop的时候，PHP便进入MSHUTDOWN（俗称ModuleShutdown）阶段。这时候PHP便会给所有扩展下最后通牒，如果哪个扩展还有未了的心愿，就放在自MSHUTDOWN方法里，这可是最后的机会了，一旦PHP把扩展的MSHUTDOWN执行完，便会进入自毁程序，这里一定要把自己擅自申请的内存给释放掉，否则就杯具了。</description></item><item><title>Pecl_Http 与 unix domain socket 客户端封装</title><link>https://icorer.com/icorer_blog/posts/pecl_http-and-unix-domain-socket-client-package/</link><pubDate>Tue, 05 Jun 2018 09:44:18 +0800</pubDate><guid>https://icorer.com/icorer_blog/posts/pecl_http-and-unix-domain-socket-client-package/</guid><description>1. 背景描述Pecl/HTTP是一个PHP扩展，历史非常悠久了，从2005年至2018年不断完善其功能，它主要帮助PHP对于HTTP请求的相关操作。不同于CURL，其具有更丰富的扩展接口，既包括平常的请求，也包括对于HTTP数据的封包或拆包操作。
对于PHP和HTTP，大部分程序员关心的如何完成一个请求。但是更深一步，我们会发现HTTP数据包的文件格式也很重要，比如传统的HTTP请求性能很弱，对于请求密集型业务，传统的HTTP并不能达到很好的RPS，就算是开启了Keep-Alive，性能还是很弱。对于这种情况，我们失望的是HTTP请求，而不是HTTP的数据包格式，所以我们可以在数据封包拆包上继续使用HTTP协议，但是对于数据传输这层，我们可以采用性能更高的一些通路，比如Unix domain socket。
2. 研究难点HTTP的通信协议数据包格式总体来说并不复杂，但是为了便于系统研发及维护，一般都站在巨人的肩膀上进行研发，目前针对PHP进行数据拆包与封包的库很少。一方面我们可以从网上比较火的一些Http Client库中抽取相关的调用层，另一方面我们可以从pecl中找寻一些扩展库，基于pecl的扩展库都是基于C语言进行的研发，性能更强，而且安装也很方便。
在本文中，我们主要围绕Pecl/HTTP库进行相关阐述，在接下来的文章中，我们也会专门围绕Guzzle或者更合适的PHP库来讲解数据包的装包和拆包。
3. HTTP数据包：封包-拆包3.1	扩展类设计思路本文主要讲解HTTP数据包的封包和拆包操作，我们首先封装一个HTTP数据包相关接口，接口主要包括对于Get、Post的封包；对于数据包的解包操作。
1&amp;lt;?php 2interface HttpPack{ 3 public function encodeGetPack($url,$header); 4 public function encodePostPack($url,$header,$body); 5 public function decodePack($packStr); 6} 7?&amp;gt; 随后，我们定义了一个SimpleTun类来实现这个接口，具体函数实现在各节详细描述，此处为框架代码。 1&amp;lt;?php 2class SimpleTun implements HttpPack 3{ 4 public function encodeGetPack($url, $header) 5 { 6 // TODO: Implement encodeGetPack() method. 7 8 } 9 10 public function encodePostPack($url, $header, $body) 11 { 12 // TODO: Implement encodePostPack() method. 13 } 14 15 public function decodePack($packStr) 16 { 17 // TODO: Implement decodePack() method.</description></item></channel></rss>