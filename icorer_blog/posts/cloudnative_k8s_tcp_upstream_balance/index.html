<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:image" content="https://res.cloudinary.com/malloc/image/upload/v1669271757/icorer.com/34047788_pepere.jpg"><title>TCP长连接在K8S环境下的负载均衡分析 | 笔迹-工匠之芯</title><meta name=author content="LB"><meta name=description content="K8S不支持长连接的负载均衡，所以负载可能不是很均衡。如果你在使用HTTP/2，gRPC, RSockets, AMQP 或者任何长连接场景，你需要考虑客户端负载均衡。
TL;DR: Kubernetes doesn&rsquo;t load balance long-lived connections, and some Pods might receive more requests than others. If you&rsquo;re using HTTP/2, gRPC, RSockets, AMQP or any other long-lived connection such as a database connection, you might want to consider client-side load balancing.
Kubernetes提供了两种方便的抽象来部署应用程序：Services 和 Deployments。 Deployments描述了在任何给定时间应运行哪种类型以及多少个应用程序副本的方法。每个应用程序都部署为Pod，并为其分配了IP地址；另一方面，Services类似于负载平衡器。它们旨在将流量分配给一组Pod。
将Services视为IP地址的集合通常很有用。每次您对Services提出请求时，都会从该列表中选择一个IP地址并将其用作目的地。 如果您有两个应用程序（例如前端和后端），则可以为每个应用程序使用Deployment和Service，然后将它们部署在集群中。 当前端应用发出请求时，不需要知道有多少Pod连接到后端服务；前端应用程序也不知道后端应用程序的各个IP地址。当它想要发出请求时，该请求将发送到IP地址不变的后端服务。 但是该服务的负载平衡策略是什么？
Kubernetes Services中的负载平衡Kubernetes Services不存在，没有进程监听服务的IP地址和端口。
您可以通过访问Kubernetes集群中的任何节点并执行netstat -ntlp来检查是否存在这种情况。
甚至在任何地方都找不到IP地址,Services的IP地址由控制器管理器中的控制平面分配，并存储在数据库etcd中。然后，另一个组件将使用相同的IP地址：kube-proxy。
Kube-proxy读取所有Services的IP地址列表，并在每个节点中写入一组iptables规则。这些规则的意思是：“如果看到此Services IP地址，则改写请求并选择Pod之一作为目的地”。Services IP地址仅用作占位符-这就是为什么没有进程监听IP地址或端口的原因。 iptables是否使用轮询？不，iptables主要用于防火墙，并且其目的不是进行负载平衡。但是，您可以制定一套聪明的规则，使iptables像负载均衡器一样工作。而这正是Kubernetes中发生的事情。
如果您有三个Pod，则kube-proxy编写以下规则：
选择Pod 1作为目的地，可能性为33％。 否则，移至下一条规则 选择Pod 2作为目的地，可能性为50％。 否则，请移至以下规则 选择Pod 3作为目的地（没有可能性） 复合概率是Pod 1，Pod 2和Pod 3都有三分之一的机会被选中（33％）。"><meta name=keywords content="blog,博客,工匠之芯,笔迹-工匠之芯"><meta name=twitter:card content="summary"><meta name=twitter:title content="TCP长连接在K8S环境下的负载均衡分析"><meta name=twitter:description content="K8S不支持长连接的负载均衡，所以负载可能不是很均衡。如果你在使用HTTP/2，gRPC, RSockets, AMQP 或者任何长连接场景，你需要考虑客户端负载均衡。
TL;DR: Kubernetes doesn&rsquo;t load balance long-lived connections, and some Pods might receive more requests than others. If you&rsquo;re using HTTP/2, gRPC, RSockets, AMQP or any other long-lived connection such as a database connection, you might want to consider client-side load balancing.
Kubernetes提供了两种方便的抽象来部署应用程序：Services 和 Deployments。 Deployments描述了在任何给定时间应运行哪种类型以及多少个应用程序副本的方法。每个应用程序都部署为Pod，并为其分配了IP地址；另一方面，Services类似于负载平衡器。它们旨在将流量分配给一组Pod。
将Services视为IP地址的集合通常很有用。每次您对Services提出请求时，都会从该列表中选择一个IP地址并将其用作目的地。 如果您有两个应用程序（例如前端和后端），则可以为每个应用程序使用Deployment和Service，然后将它们部署在集群中。 当前端应用发出请求时，不需要知道有多少Pod连接到后端服务；前端应用程序也不知道后端应用程序的各个IP地址。当它想要发出请求时，该请求将发送到IP地址不变的后端服务。 但是该服务的负载平衡策略是什么？
Kubernetes Services中的负载平衡Kubernetes Services不存在，没有进程监听服务的IP地址和端口。
您可以通过访问Kubernetes集群中的任何节点并执行netstat -ntlp来检查是否存在这种情况。
甚至在任何地方都找不到IP地址,Services的IP地址由控制器管理器中的控制平面分配，并存储在数据库etcd中。然后，另一个组件将使用相同的IP地址：kube-proxy。
Kube-proxy读取所有Services的IP地址列表，并在每个节点中写入一组iptables规则。这些规则的意思是：“如果看到此Services IP地址，则改写请求并选择Pod之一作为目的地”。Services IP地址仅用作占位符-这就是为什么没有进程监听IP地址或端口的原因。 iptables是否使用轮询？不，iptables主要用于防火墙，并且其目的不是进行负载平衡。但是，您可以制定一套聪明的规则，使iptables像负载均衡器一样工作。而这正是Kubernetes中发生的事情。
如果您有三个Pod，则kube-proxy编写以下规则：
选择Pod 1作为目的地，可能性为33％。 否则，移至下一条规则 选择Pod 2作为目的地，可能性为50％。 否则，请移至以下规则 选择Pod 3作为目的地（没有可能性） 复合概率是Pod 1，Pod 2和Pod 3都有三分之一的机会被选中（33％）。"><meta property="og:title" content="TCP长连接在K8S环境下的负载均衡分析"><meta property="og:description" content="K8S不支持长连接的负载均衡，所以负载可能不是很均衡。如果你在使用HTTP/2，gRPC, RSockets, AMQP 或者任何长连接场景，你需要考虑客户端负载均衡。
TL;DR: Kubernetes doesn&rsquo;t load balance long-lived connections, and some Pods might receive more requests than others. If you&rsquo;re using HTTP/2, gRPC, RSockets, AMQP or any other long-lived connection such as a database connection, you might want to consider client-side load balancing.
Kubernetes提供了两种方便的抽象来部署应用程序：Services 和 Deployments。 Deployments描述了在任何给定时间应运行哪种类型以及多少个应用程序副本的方法。每个应用程序都部署为Pod，并为其分配了IP地址；另一方面，Services类似于负载平衡器。它们旨在将流量分配给一组Pod。
将Services视为IP地址的集合通常很有用。每次您对Services提出请求时，都会从该列表中选择一个IP地址并将其用作目的地。 如果您有两个应用程序（例如前端和后端），则可以为每个应用程序使用Deployment和Service，然后将它们部署在集群中。 当前端应用发出请求时，不需要知道有多少Pod连接到后端服务；前端应用程序也不知道后端应用程序的各个IP地址。当它想要发出请求时，该请求将发送到IP地址不变的后端服务。 但是该服务的负载平衡策略是什么？
Kubernetes Services中的负载平衡Kubernetes Services不存在，没有进程监听服务的IP地址和端口。
您可以通过访问Kubernetes集群中的任何节点并执行netstat -ntlp来检查是否存在这种情况。
甚至在任何地方都找不到IP地址,Services的IP地址由控制器管理器中的控制平面分配，并存储在数据库etcd中。然后，另一个组件将使用相同的IP地址：kube-proxy。
Kube-proxy读取所有Services的IP地址列表，并在每个节点中写入一组iptables规则。这些规则的意思是：“如果看到此Services IP地址，则改写请求并选择Pod之一作为目的地”。Services IP地址仅用作占位符-这就是为什么没有进程监听IP地址或端口的原因。 iptables是否使用轮询？不，iptables主要用于防火墙，并且其目的不是进行负载平衡。但是，您可以制定一套聪明的规则，使iptables像负载均衡器一样工作。而这正是Kubernetes中发生的事情。
如果您有三个Pod，则kube-proxy编写以下规则：
选择Pod 1作为目的地，可能性为33％。 否则，移至下一条规则 选择Pod 2作为目的地，可能性为50％。 否则，请移至以下规则 选择Pod 3作为目的地（没有可能性） 复合概率是Pod 1，Pod 2和Pod 3都有三分之一的机会被选中（33％）。"><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_blog/posts/cloudnative_k8s_tcp_upstream_balance/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-25T11:28:12+08:00"><meta property="article:modified_time" content="2020-12-25T11:28:12+08:00"><link rel=stylesheet href=/icorer_blog/css/bootstrap.min.css crossorigin=anonymous><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/icorer_blog/sass/main.css><link rel=stylesheet href=/icorer_blog/zoomjs/zoom.min.css><script src=/icorer_blog/js/lazysizes.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/icorer_blog/apple-touch-icon.png><link rel=icon type=image/ico sizes=16x16 href=/icorer_blog/img/favicon.ico><link rel=manifest href=/icorer_blog/site.webmanifest></head><body><nav class="navbar navbar-default navbar-custom navbar-fixed-top invert"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://icorer.com/icorer_blog/>笔迹-工匠之芯</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=https://icorer.com title=工匠之芯>工匠之芯</a></li><li><a href=https://icorer.com/icorer_about title=关于我>关于我</a></li><li><a href=https://github.com/gitsrc title=开源仓库>开源仓库</a></li><li class=search-icon><a href=javascript:void(0)><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse"),__HuxNav__={close:function(){$navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)},open:function(){$collapse.style.height="auto",$navbar.className+=" in"}};$toggle.addEventListener("click",function(){$navbar.className.indexOf("in")>0?__HuxNav__.close():__HuxNav__.open()}),document.addEventListener("click",function(e){if(e.target==$toggle)return;if(e.target.className=="icon-bar")return;__HuxNav__.close()})</script><div class=search-page><div class=search-icon-close-container><span class=search-icon-close><i class="fa fa-chevron-down"></i></span></div><div class="search-main container"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><form></form><input type=text id=search-input placeholder="$ grep..."></form><div id=search-results class=mini-post-list></div></div></div></div></div><style type=text/css>header.intro-header{position:relative;background-image:url('')}</style><header class="intro-header style-text"><div class=header-mask></div><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/icorer_blog/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/ title=云原生>云原生</a>
<a class=tag href=/icorer_blog/tags/cloudnative/ title=cloudnative>cloudnative</a>
<a class=tag href=/icorer_blog/tags/k8s/ title=k8s>k8s</a>
<a class=tag href=/icorer_blog/tags/hackathon/ title=Hackathon>Hackathon</a></div><h1>TCP长连接在K8S环境下的负载均衡分析</h1><h2 class=subheading></h2><span class=meta>Posted by LB
on Fri, Dec 25, 2020</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>K8S不支持长连接的负载均衡，所以负载可能不是很均衡。如果你在使用HTTP/2，gRPC, RSockets, AMQP 或者任何长连接场景，你需要考虑客户端负载均衡。</p><blockquote><p>TL;DR: Kubernetes doesn&rsquo;t load balance long-lived connections, and some Pods might receive more requests than others. If you&rsquo;re using HTTP/2, gRPC, RSockets, AMQP or any other long-lived connection such as a database connection, you might want to consider client-side load balancing.</p></blockquote><p>Kubernetes提供了两种方便的抽象来部署应用程序：Services 和 Deployments。
Deployments描述了在任何给定时间应运行哪种类型以及多少个应用程序副本的方法。每个应用程序都部署为Pod，并为其分配了IP地址；另一方面，Services类似于负载平衡器。它们旨在将流量分配给一组Pod。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/230071232.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/4219488447.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/3052109751.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/3999765248.png data-action=zoom alt class=lazyload></a></figure></p><p>将Services视为IP地址的集合通常很有用。每次您对Services提出请求时，都会从该列表中选择一个IP地址并将其用作目的地。<figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/3446241040.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/1348368853.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/3141194402.png data-action=zoom alt class=lazyload></a></figure></p><p>如果您有两个应用程序（例如前端和后端），则可以为每个应用程序使用Deployment和Service，然后将它们部署在集群中。
当前端应用发出请求时，不需要知道有多少Pod连接到后端服务；前端应用程序也不知道后端应用程序的各个IP地址。当它想要发出请求时，该请求将发送到IP地址不变的后端服务。<figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2125808684.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/828752503.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2476883743.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/4094225296.png data-action=zoom alt class=lazyload></a></figure>但是该服务的负载平衡策略是什么？</p><h2 id=kubernetes-services中的负载平衡>Kubernetes Services中的负载平衡<a class=anchorjs-link href=#kubernetes-services%e4%b8%ad%e7%9a%84%e8%b4%9f%e8%bd%bd%e5%b9%b3%e8%a1%a1></a></h2><p>Kubernetes Services不存在，没有进程监听服务的IP地址和端口。</p><blockquote><p>您可以通过访问Kubernetes集群中的任何节点并执行netstat -ntlp来检查是否存在这种情况。</p></blockquote><p>甚至在任何地方都找不到IP地址,Services的IP地址由控制器管理器中的控制平面分配，并存储在数据库etcd中。然后，另一个组件将使用相同的IP地址：kube-proxy。</p><p>Kube-proxy读取所有Services的IP地址列表，并在每个节点中写入一组iptables规则。这些规则的意思是：“如果看到此Services IP地址，则改写请求并选择Pod之一作为目的地”。Services IP地址仅用作占位符-这就是为什么没有进程监听IP地址或端口的原因。<figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2179961981.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/913524904.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/1431548930.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/374410545.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2680085761.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/1078395886.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/1985148704.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/1670696113.png data-action=zoom alt class=lazyload></a></figure></p><p>iptables是否使用轮询？不，iptables主要用于防火墙，并且其目的不是进行负载平衡。但是，<a href=https://scalingo.com/blog/iptables#load-balancing title=您可以制定一套聪明的规则，使iptables像负载均衡器一样工作 target=_blank>您可以制定一套聪明的规则，使iptables像负载均衡器一样工作</a>。而这正是Kubernetes中发生的事情。</p><p>如果您有三个Pod，则kube-proxy编写以下规则：</p><ol><li>选择Pod 1作为目的地，可能性为33％。 否则，移至下一条规则</li><li>选择Pod 2作为目的地，可能性为50％。 否则，请移至以下规则</li><li>选择Pod 3作为目的地（没有可能性）</li></ol><p>复合概率是Pod 1，Pod 2和Pod 3都有三分之一的机会被选中（33％）。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2994783072.png data-action=zoom alt class=lazyload></a></figure>同样，不能保证在Pod 1之后选择Pod 2作为目的地。</p><blockquote><p>Iptables使用随机模式的<a href=http://ipset.netfilter.org/iptables-extensions.man.html#lbCD title=statistic模块 target=_blank>statistic模块</a>。所以负载均衡算法是随机的。</p></blockquote><h2 id=长期连接不会在kubernetes中扩展scale>长期连接不会在Kubernetes中扩展(scale)<a class=anchorjs-link href=#%e9%95%bf%e6%9c%9f%e8%bf%9e%e6%8e%a5%e4%b8%8d%e4%bc%9a%e5%9c%a8kubernetes%e4%b8%ad%e6%89%a9%e5%b1%95scale></a></h2><p>从前端到后端启动每个HTTP请求时，都会打开和关闭一个新的TCP连接。</p><p>如果前端每秒向后端发出100个HTTP请求，则在该秒内将打开和关闭100个不同的TCP连接。</p><p>如果打开TCP连接并将其重新用于任何后续HTTP请求，则可以改善延迟并节省资源。</p><p>HTTP协议具有称为HTTP保持活动或HTTP连接重用的功能，该功能使用单个TCP连接发送和接收多个HTTP请求和响应。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2613633300.gif data-action=zoom alt class=lazyload></a></figure></p><p>它不是现成的;您的服务器和客户端应该配置为使用它，这种改变本身很简单，而且在大多数语言和框架中都可以使用。</p><p>当您在Kubernetes服务中使用keep-alive时会发生什么?</p><p>让我们假设前端和后端都支持keep-alive，您有一个前端实例和三个后端副本，前端向后端发出第一个请求并打开TCP连接，请求到达服务，其中一个Pod被选择为目的地，后端Pod响应，前端接收响应。但是，它没有关闭TCP连接，而是为后续的HTTP请求保持打开状态。</p><p>当前端发出更多请求时会发生什么?
他们被送到同一个Pod。</p><p>难道iptables不应该分配流量吗?
事实上、它打开了一个TCP连接，第一次调用了iptables规则，三个Pod中的一个被选为目的地，由于所有后续请求都通过同一个TCP连接进行传输，因此iptables不再被调用。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/4002728109.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2553319285.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/1143083368.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/3335055683.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/3347929904.gif data-action=zoom alt class=lazyload></a></figure>因此，您现在获得了更好的延迟和吞吐量，但失去了扩展后端的能力，即使有两个后端Pod可以接收来自前端Pod的请求，也只有一个被积极使用。</p><p>它可以修复吗？
由于Kubernetes不知道如何对持久性连接进行负载平衡，因此您可以自己介入并对其进行修复。服务是IP地址和端口的集合，通常称为端点。您的应用程序可以从服务中检索端点列表，并决定如何分发请求。</p><p>首次尝试时，您可以打开与每个Pod的持久连接，并对它们进行轮询请求。或者，您可以实施<a href=https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/daperture-load-balancer.html title=更复杂的负载平衡算法 target=_blank>更复杂的负载平衡算法</a>。</p><p>执行负载平衡的客户端代码应该遵循以下逻辑:</p><ol><li><p>从服务中检索端点列表</p></li><li><p>对于它们中的每一个，打开一个连接并保持其打开状态</p></li><li><p>当您需要发出请求时，选择一个打开的连接</p></li><li><p>定期刷新端点列表，并删除或添加新连接</p></li></ol><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2729460275.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2591632677.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/1751495897.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2647559816.gif data-action=zoom alt class=lazyload></a></figure>这个问题只适用于HTTP keep-alive吗?</p><h2 id=客户端负载均衡>客户端负载均衡<a class=anchorjs-link href=#%e5%ae%a2%e6%88%b7%e7%ab%af%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1></a></h2><p>HTTP不是唯一可以受益于长期TCP连接的协议。如果您的应用程序使用数据库，则每次您要检索记录或文档时都不会打开和关闭连接。相反，TCP连接仅建立一次并保持打开状态。</p><p>如果使用服务将数据库部署在Kubernetes中，则可能会遇到与上一个示例相同的问题。数据库中有一个副本的利用率高于其他副本。Kube-proxy和Kubernetes不利于平衡持久连接。相反，您应该注意负载均衡对数据库的请求。</p><p>根据用于连接数据库的库，您可能有不同的选择。</p><p>您可以想象，还有其他几个协议可以在长期存在的TCP连接上工作。这里你可以读到一些例子:</p><ol><li>Websockets和安全Websockets</li><li>HTTP / 2</li><li>gRPC</li><li>RSockets</li><li>AMQP</li></ol><p>您可能会认识到上面的大多数协议。因此，如果这些协议非常流行，为什么没有标准的负载均衡解决方案呢？
为什么必须将逻辑移入客户端？
Kubernetes中是否有本机解决方案？</p><p>Kube-proxy和iptables旨在涵盖Kubernetes集群中最流行的部署用例，但是它们大多是为了方便。</p><p>如果您使用的是公开REST API的Web服务，那么您很幸运-该用例通常不会重用TCP连接，并且可以使用任何Kubernetes服务。但是，一旦开始使用持久的TCP连接，就应该研究如何将负载平均分配到后端。</p><p>Kubernetes没有开箱即用地涵盖该特定用例，但是有些东西可能会有所帮助。</p><h2 id=负载平衡kubernetes中的长连接>负载平衡Kubernetes中的长连接<a class=anchorjs-link href=#%e8%b4%9f%e8%bd%bd%e5%b9%b3%e8%a1%a1kubernetes%e4%b8%ad%e7%9a%84%e9%95%bf%e8%bf%9e%e6%8e%a5></a></h2><p>Kubernetes有四种不同的服务:</p><ol><li>ClusterIP</li><li>NodePort</li><li>loadbalance</li><li>Headless</li></ol><p>前三个服务都有一个虚拟IP地址，kube-proxy使用该地址创建iptables规则。但Headless服务是所有服务的基本组成部分。
headless服务没有分配的IP地址，只是一种收集Pod IP地址和端口(也称为端点)列表的机制。其他所有服务都建立在Headless服务之上。</p><p>ClusterIP服务是一项Headless 服务，具有一些附加功能：</p><ol><li>控制平面为其分配IP地址</li><li>kube-proxy遍历所有IP地址并创建iptables规则</li></ol><p>因此，您可以完全忽略kube-proxy，并始终使用Headless服务收集的端点列表来负载平衡客户端请求。</p><p>但是你能想象将这种逻辑添加到集群中部署的所有应用程序中吗?</p><p>如果您有现有的应用程序群，这听起来像是不可能完成的任务，但是还有另一种选择。</p><h2 id=服务网格来拯救>服务网格来拯救<a class=anchorjs-link href=#%e6%9c%8d%e5%8a%a1%e7%bd%91%e6%a0%bc%e6%9d%a5%e6%8b%af%e6%95%91></a></h2><p>您可能已经注意到，客户端负载平衡策略是非常标准的。
当应用程序启动时，它应该这么做：</p><ol><li>从服务中检索IP地址列表</li><li>打开并维护一个连接池</li><li>通过添加和删除端点来定期刷新池</li></ol><p>一旦它希望提出一次请求，它应使用预先定义的逻辑(如循环)选择一个可用的连接。</p><p>上面的步骤对WebSockets连接以及gRPC和AMQP有效。
您可以将该逻辑提取到一个单独的库中，并与所有应用共享。
你可以使用Istio或Linkerd这样的服务网格，而不是从头开始编写一个库。
服务网格用一个新进程来增强你的应用程序:</p><ol><li>自动发现IP地址服务</li><li>检查连接，如WebSockets和gRPC</li><li>使用正确的协议来负载平衡请求</li></ol><p>服务网格可以帮助您管理集群内部的流量，但是它们并不是完全轻量级的。</p><p>其他选项包括使用诸如Netflix Ribbon之类的库，诸如Envoy之类的可编程代理，或者只是忽略它。</p><p>如果你忽略它会发生什么?</p><p>您可以忽略负载平衡，并且仍然不会注意到任何更改，您应该考虑几种情况：</p><ol><li>如果您的客户端数量多于服务器数量，那么问题应该是有限的。</li><li>假设您有五个客户端打开了到两个服务器的持久连接。</li></ol><p>即使没有负载平衡，两个服务器也可能被利用。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/195086259.gif data-action=zoom alt class=lazyload></a></figure></p><p>连接可能分布不均（也许最终有四个连接到同一台服务器），但是总体而言，很有可能同时使用了这两个服务器。</p><p>如果客户端更少，服务器更多，则可能有一些未充分利用的资源和潜在的瓶颈。</p><p>想象一下，有两个客户端和五个服务器，最多只能打开到两个服务器的两个持久连接，其余的服务器根本不使用。<figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/12/2079715700.gif data-action=zoom alt class=lazyload></a></figure></p><p>如果两个服务器不能处理客户端产生的流量，水平扩展将不会有帮助。</p><h2 id=总结>总结<a class=anchorjs-link href=#%e6%80%bb%e7%bb%93></a></h2><p>Kubernetes Services旨在涵盖Web应用程序的最常见用途。</p><p>但是，一旦您开始使用使用持久性TCP连接的应用程序协议（例如数据库，gRPC或WebSockets），它们就会崩溃。</p><p>Kubernetes不提供任何内置机制来平衡长期存在的TCP连接的负载</p><p>原文路径：https://learnk8s.io/kubernetes-long-lived-connections</p><hr style=visibility:hidden><ul class=pager><li class=previous><a href=/icorer_blog/posts/microservice_skywalking_php_kernel_source_analyze/ data-toggle=tooltip data-placement=top title=微服务治理：APM-SkyWalking-PHP内核扩展源码分析>Previous<br><span>微服务治理：APM-SkyWalking-PHP内核扩展源码分析</span></a></li><li class=next><a href=/icorer_blog/posts/blockchain_fpga_redis_nosql/ data-toggle=tooltip data-placement=top title="⽤于区块链可扩展性的⾼效能 FPGA-Redis 混合 NoSQL 缓存系统">Next<br><span>⽤于区块链可扩展性的⾼效能 FPGA-Redis 混合 NoSQL 缓存系统</span></a></li></ul><hr style=visibility:hidden></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5>FEATURED TAGS</h5><div class=tags><a href=/icorer_blog/tags/blockchain/>blockchain</a>
<a href=/icorer_blog/tags/clang/>CLang</a>
<a href=/icorer_blog/tags/cloudnative/>cloudnative</a>
<a href=/icorer_blog/tags/cmake/>Cmake</a>
<a href=/icorer_blog/tags/epoll/>epoll</a>
<a href=/icorer_blog/tags/fpga/>FPGA</a>
<a href=/icorer_blog/tags/gc/>GC</a>
<a href=/icorer_blog/tags/golang/>GoLang</a>
<a href=/icorer_blog/tags/hackathon/>Hackathon</a>
<a href=/icorer_blog/tags/http2/>HTTP2</a>
<a href=/icorer_blog/tags/http3/>HTTP3</a>
<a href=/icorer_blog/tags/icefiredb/>IceFireDB</a>
<a href=/icorer_blog/tags/k8s/>k8s</a>
<a href=/icorer_blog/tags/kafka/>kafka</a>
<a href=/icorer_blog/tags/linux/>linux</a>
<a href=/icorer_blog/tags/nginx/>Nginx</a>
<a href=/icorer_blog/tags/nosql/>NoSQL</a>
<a href=/icorer_blog/tags/php/>PHP</a>
<a href=/icorer_blog/tags/php-kernel/>php kernel</a>
<a href=/icorer_blog/tags/php%E5%86%85%E6%A0%B8/>PHP内核</a>
<a href=/icorer_blog/tags/quic/>QUIC</a>
<a href=/icorer_blog/tags/redis/>redis</a>
<a href=/icorer_blog/tags/serverless/>serverless</a>
<a href=/icorer_blog/tags/unikernel/>unikernel</a>
<a href=/icorer_blog/tags/wanxiang/>Wanxiang</a>
<a href=/icorer_blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件</a>
<a href=/icorer_blog/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a>
<a href=/icorer_blog/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/>信息安全</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/>内存数据库</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/>内存泄漏</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/>内核源码</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6/>内核研究</a>
<a href=/icorer_blog/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/>区块链</a>
<a href=/icorer_blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>垃圾回收</a>
<a href=/icorer_blog/tags/%E5%AD%98%E5%82%A8/>存储</a>
<a href=/icorer_blog/tags/%E5%AE%B9%E5%99%A8/>容器</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/>底层开发</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/>底层研究</a>
<a href=/icorer_blog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/>开源项目</a>
<a href=/icorer_blog/tags/%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97/>异构计算</a>
<a href=/icorer_blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a>
<a href=/icorer_blog/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/>性能测试</a>
<a href=/icorer_blog/tags/%E6%8A%80%E6%9C%AF%E7%A7%91%E6%99%AE/>技术科普</a>
<a href=/icorer_blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/>数据库技术</a>
<a href=/icorer_blog/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/>文章翻译</a>
<a href=/icorer_blog/tags/%E6%96%B0%E6%9E%B6%E6%9E%84/>新架构</a>
<a href=/icorer_blog/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/>时序数据库</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/>服务治理</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/>服务网格</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E9%81%A5%E6%B5%8B/>服务遥测</a>
<a href=/icorer_blog/tags/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/>测试报告</a>
<a href=/icorer_blog/tags/%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/>研究报告</a>
<a href=/icorer_blog/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/>缓存技术</a>
<a href=/icorer_blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a>
<a href=/icorer_blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/>虚拟机</a>
<a href=/icorer_blog/tags/%E8%AE%BA%E6%96%87/>论文</a>
<a href=/icorer_blog/tags/%E9%9B%B6%E4%BF%A1%E4%BB%BB/>零信任</a>
<a href=/icorer_blog/tags/%E9%AB%98%E6%80%A7%E8%83%BD/>高性能</a></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=/icorer_blog/index.xml><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/corerman1><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/gitsrc><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 笔迹-工匠之芯 2022</p></div></div></div></footer><script src=/icorer_blog/js/jquery.min.js></script>
<script src=/icorer_blog/js/bootstrap.min.js crossorigin=anonymous></script>
<script src=/icorer_blog/js/hux-blog.min.c4ea77041cd3edbfc8b2622cd887a9a5d8760a4162d14489e36d2a3fa4c90172.js></script>
<script src=/icorer_blog/js/simple-jekyll-search.min.js></script>
<script src=/icorer_blog/js/search.min.7d1445cf07369bca2715d9f63738c16c73a7a2273a95d6729bee561f7e84c6c8.js></script>
<script src=/icorer_blog/zoomjs/zoom.min.js></script></body></html>