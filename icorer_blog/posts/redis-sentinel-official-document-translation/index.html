<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=icon type=image/ico sizes=16x16 href=/icorer_blog/img/favicon.ico><meta property="og:image" content="https://res.cloudinary.com/malloc/image/upload/v1669271757/icorer.com/34047788_pepere.jpg"><title>Redis哨兵-官方文档翻译 | 笔迹-工匠之芯</title><meta name=author content="LB"><meta name=description content="Sentinel概述Redis Sentinel为Redis提供高可用性。实际上，这意味着使用&#34;哨兵&#34;可以创建一个不需要人工干预就能抵抗某些类型失败的Redis部署。
Redis Sentinel还提供其他附属任务，如监控、通知和为客户提供配置。
这是宏观上（即全局）Sentinel功能的完整列表：
监视：Sentinel会不断检查你的主实例和副本实例是否按预期工作。 通知：Sentinel可以通过API通知系统管理员或其他计算机程序，其中一个被监控的Redis实例出了问题。 自动故障转移：如果一个主服务器没有按照预期工作，Sentinel可以启动一个故障转移过程，其中一个副本被提升到主服务器，其他附加的副本被重新配置以使用新的主服务器，使用Redis服务器的应用程序在连接时被告知要使用的新地址。 组态设定提供者：Sentinel充当客户端服务发现的授权来源：客户端连接到Sentinels，以询问负责给定服务的当前Redis主服务器的地址。 如果发生故障转移，Sentinels将报告新地址。 Sentinel的分布式性质Redis Sentinel是一个分布式系统：
哨兵本身被设计成在一个有多个协作的哨兵进程的配置中运行。有多个哨兵进程协作的好处如下:
当多个哨兵一致认为某个主节点不再可用时，就会执行故障检测。这降低了误报的概率。 即使不是所有的哨兵进程都在工作，哨兵也能工作，这使得系统对故障具有健壮性。毕竟，拥有一个本身就是单点故障的故障转移系统是毫无乐趣的。 哨兵、Redis实例(主实例和副本实例)和连接到哨兵和Redis的客户机的所有组成部分是一个更大的具有特定属性的分布式系统。在本文档中，将逐步介绍概念，从为了理解Sentinel的基本属性所需的基本信息，到为了理解哨兵的工作原理的更复杂的信息（可选）。
快速入门获得哨兵当前版本的Sentinel称为Sentinel 2。它是对最初的哨兵实现的重写，使用了更强大、更简单的预测算法(在本文档中有解释)。
自Redis 2.8起已发布稳定版本的Redis Sentinel。
在不稳定分支中进行了新的开发，并且有时新功能一旦被认为是稳定的，便会立即移植回最新的稳定分支。
Redis Sentinel版本1(随Redis 2.6一起发布)是不推荐使用的。
运行哨兵如果您正在使用redis-sentinel可执行文件(或者如果您有一个与redis-server可执行文件同名的符号链接)，您可以使用以下命令行运行Sentinel：
1redis-sentinel /path/to/sentinel.conf 否则，您可以直接使用redis-server可执行文件以Sentinel模式启动它：
1redis-server /path/to/sentinel.conf --sentinel 这两种方法的工作方式相同。
但是，在运行Sentinel时必须使用一个配置文件，因为系统会使用这个文件来保存在重新启动时要重新载入的当前状态。如果没有配置文件，或者配置文件路径不可写，Sentinel将拒绝启动。
哨兵默认情况下会监听TCP端口26379的连接，因此，为了使哨兵正常工作，必须打开服务器的端口26379，以接收来自其他哨兵实例的IP地址的连接。 否则，哨兵无法讨论也不能就该做什么达成共识，因此将永远不会执行故障转移。
部署哨兵前需要了解的基本内容 一个健壮的部署至少需要三个Sentinel实例。 应将三个哨兵实例放置到被认为以独立方式发生故障的计算机或虚拟机中。例如在不同的可用区域上执行的不同物理服务器或虚拟机。 Sentinel + Redis分布式系统不保证在故障期间保留已确认的写入，因为Redis使用异步复制。但是，有一些部署Sentinel的方法使窗口丢失写入仅限于某些时刻，而还有其他一些不太安全的方法来部署它。 您的客户需要Sentinel支持。 流行的客户端库具有Sentinel支持，但不是全部。 如果您不经常在开发环境中进行测试，那么就没有HA设置是安全的，如果您可以在生产环境中进行测试，如果它们能够工作，那就更好了。你可能有一个错误的配置，只有当它变得太晚(凌晨3点当master停止工作)才会变得明显。 Sentinel，Docker或其他形式的网络地址转换或端口映射应该小心混合：Docker执行端口重新映射，破坏了其他Sentinel进程的Sentinel自动发现以及主数据库的副本列表。有关更多信息，请参阅本文档后面有关Sentinel和Docker的部分。 配置哨兵edis源发行版包含一个名为Sentinel .conf的文件，它是一个自文档化的示例配置文件，您可以使用它来配置Sentinel，但是典型的最小配置文件，如下所示：
1sentinel monitor mymaster 127.0.0.1 6379 2 2sentinel down-after-milliseconds mymaster 60000 3sentinel failover-timeout mymaster 180000 4sentinel parallel-syncs mymaster 1 5 6sentinel monitor resque 192."><meta name=keywords content="blog,博客,工匠之芯,笔迹-工匠之芯"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis哨兵-官方文档翻译"><meta name=twitter:description content="Sentinel概述Redis Sentinel为Redis提供高可用性。实际上，这意味着使用&#34;哨兵&#34;可以创建一个不需要人工干预就能抵抗某些类型失败的Redis部署。
Redis Sentinel还提供其他附属任务，如监控、通知和为客户提供配置。
这是宏观上（即全局）Sentinel功能的完整列表：
监视：Sentinel会不断检查你的主实例和副本实例是否按预期工作。 通知：Sentinel可以通过API通知系统管理员或其他计算机程序，其中一个被监控的Redis实例出了问题。 自动故障转移：如果一个主服务器没有按照预期工作，Sentinel可以启动一个故障转移过程，其中一个副本被提升到主服务器，其他附加的副本被重新配置以使用新的主服务器，使用Redis服务器的应用程序在连接时被告知要使用的新地址。 组态设定提供者：Sentinel充当客户端服务发现的授权来源：客户端连接到Sentinels，以询问负责给定服务的当前Redis主服务器的地址。 如果发生故障转移，Sentinels将报告新地址。 Sentinel的分布式性质Redis Sentinel是一个分布式系统：
哨兵本身被设计成在一个有多个协作的哨兵进程的配置中运行。有多个哨兵进程协作的好处如下:
当多个哨兵一致认为某个主节点不再可用时，就会执行故障检测。这降低了误报的概率。 即使不是所有的哨兵进程都在工作，哨兵也能工作，这使得系统对故障具有健壮性。毕竟，拥有一个本身就是单点故障的故障转移系统是毫无乐趣的。 哨兵、Redis实例(主实例和副本实例)和连接到哨兵和Redis的客户机的所有组成部分是一个更大的具有特定属性的分布式系统。在本文档中，将逐步介绍概念，从为了理解Sentinel的基本属性所需的基本信息，到为了理解哨兵的工作原理的更复杂的信息（可选）。
快速入门获得哨兵当前版本的Sentinel称为Sentinel 2。它是对最初的哨兵实现的重写，使用了更强大、更简单的预测算法(在本文档中有解释)。
自Redis 2.8起已发布稳定版本的Redis Sentinel。
在不稳定分支中进行了新的开发，并且有时新功能一旦被认为是稳定的，便会立即移植回最新的稳定分支。
Redis Sentinel版本1(随Redis 2.6一起发布)是不推荐使用的。
运行哨兵如果您正在使用redis-sentinel可执行文件(或者如果您有一个与redis-server可执行文件同名的符号链接)，您可以使用以下命令行运行Sentinel：
1redis-sentinel /path/to/sentinel.conf 否则，您可以直接使用redis-server可执行文件以Sentinel模式启动它：
1redis-server /path/to/sentinel.conf --sentinel 这两种方法的工作方式相同。
但是，在运行Sentinel时必须使用一个配置文件，因为系统会使用这个文件来保存在重新启动时要重新载入的当前状态。如果没有配置文件，或者配置文件路径不可写，Sentinel将拒绝启动。
哨兵默认情况下会监听TCP端口26379的连接，因此，为了使哨兵正常工作，必须打开服务器的端口26379，以接收来自其他哨兵实例的IP地址的连接。 否则，哨兵无法讨论也不能就该做什么达成共识，因此将永远不会执行故障转移。
部署哨兵前需要了解的基本内容 一个健壮的部署至少需要三个Sentinel实例。 应将三个哨兵实例放置到被认为以独立方式发生故障的计算机或虚拟机中。例如在不同的可用区域上执行的不同物理服务器或虚拟机。 Sentinel + Redis分布式系统不保证在故障期间保留已确认的写入，因为Redis使用异步复制。但是，有一些部署Sentinel的方法使窗口丢失写入仅限于某些时刻，而还有其他一些不太安全的方法来部署它。 您的客户需要Sentinel支持。 流行的客户端库具有Sentinel支持，但不是全部。 如果您不经常在开发环境中进行测试，那么就没有HA设置是安全的，如果您可以在生产环境中进行测试，如果它们能够工作，那就更好了。你可能有一个错误的配置，只有当它变得太晚(凌晨3点当master停止工作)才会变得明显。 Sentinel，Docker或其他形式的网络地址转换或端口映射应该小心混合：Docker执行端口重新映射，破坏了其他Sentinel进程的Sentinel自动发现以及主数据库的副本列表。有关更多信息，请参阅本文档后面有关Sentinel和Docker的部分。 配置哨兵edis源发行版包含一个名为Sentinel .conf的文件，它是一个自文档化的示例配置文件，您可以使用它来配置Sentinel，但是典型的最小配置文件，如下所示：
1sentinel monitor mymaster 127.0.0.1 6379 2 2sentinel down-after-milliseconds mymaster 60000 3sentinel failover-timeout mymaster 180000 4sentinel parallel-syncs mymaster 1 5 6sentinel monitor resque 192."><meta property="og:title" content="Redis哨兵-官方文档翻译"><meta property="og:description" content="Sentinel概述Redis Sentinel为Redis提供高可用性。实际上，这意味着使用&#34;哨兵&#34;可以创建一个不需要人工干预就能抵抗某些类型失败的Redis部署。
Redis Sentinel还提供其他附属任务，如监控、通知和为客户提供配置。
这是宏观上（即全局）Sentinel功能的完整列表：
监视：Sentinel会不断检查你的主实例和副本实例是否按预期工作。 通知：Sentinel可以通过API通知系统管理员或其他计算机程序，其中一个被监控的Redis实例出了问题。 自动故障转移：如果一个主服务器没有按照预期工作，Sentinel可以启动一个故障转移过程，其中一个副本被提升到主服务器，其他附加的副本被重新配置以使用新的主服务器，使用Redis服务器的应用程序在连接时被告知要使用的新地址。 组态设定提供者：Sentinel充当客户端服务发现的授权来源：客户端连接到Sentinels，以询问负责给定服务的当前Redis主服务器的地址。 如果发生故障转移，Sentinels将报告新地址。 Sentinel的分布式性质Redis Sentinel是一个分布式系统：
哨兵本身被设计成在一个有多个协作的哨兵进程的配置中运行。有多个哨兵进程协作的好处如下:
当多个哨兵一致认为某个主节点不再可用时，就会执行故障检测。这降低了误报的概率。 即使不是所有的哨兵进程都在工作，哨兵也能工作，这使得系统对故障具有健壮性。毕竟，拥有一个本身就是单点故障的故障转移系统是毫无乐趣的。 哨兵、Redis实例(主实例和副本实例)和连接到哨兵和Redis的客户机的所有组成部分是一个更大的具有特定属性的分布式系统。在本文档中，将逐步介绍概念，从为了理解Sentinel的基本属性所需的基本信息，到为了理解哨兵的工作原理的更复杂的信息（可选）。
快速入门获得哨兵当前版本的Sentinel称为Sentinel 2。它是对最初的哨兵实现的重写，使用了更强大、更简单的预测算法(在本文档中有解释)。
自Redis 2.8起已发布稳定版本的Redis Sentinel。
在不稳定分支中进行了新的开发，并且有时新功能一旦被认为是稳定的，便会立即移植回最新的稳定分支。
Redis Sentinel版本1(随Redis 2.6一起发布)是不推荐使用的。
运行哨兵如果您正在使用redis-sentinel可执行文件(或者如果您有一个与redis-server可执行文件同名的符号链接)，您可以使用以下命令行运行Sentinel：
1redis-sentinel /path/to/sentinel.conf 否则，您可以直接使用redis-server可执行文件以Sentinel模式启动它：
1redis-server /path/to/sentinel.conf --sentinel 这两种方法的工作方式相同。
但是，在运行Sentinel时必须使用一个配置文件，因为系统会使用这个文件来保存在重新启动时要重新载入的当前状态。如果没有配置文件，或者配置文件路径不可写，Sentinel将拒绝启动。
哨兵默认情况下会监听TCP端口26379的连接，因此，为了使哨兵正常工作，必须打开服务器的端口26379，以接收来自其他哨兵实例的IP地址的连接。 否则，哨兵无法讨论也不能就该做什么达成共识，因此将永远不会执行故障转移。
部署哨兵前需要了解的基本内容 一个健壮的部署至少需要三个Sentinel实例。 应将三个哨兵实例放置到被认为以独立方式发生故障的计算机或虚拟机中。例如在不同的可用区域上执行的不同物理服务器或虚拟机。 Sentinel + Redis分布式系统不保证在故障期间保留已确认的写入，因为Redis使用异步复制。但是，有一些部署Sentinel的方法使窗口丢失写入仅限于某些时刻，而还有其他一些不太安全的方法来部署它。 您的客户需要Sentinel支持。 流行的客户端库具有Sentinel支持，但不是全部。 如果您不经常在开发环境中进行测试，那么就没有HA设置是安全的，如果您可以在生产环境中进行测试，如果它们能够工作，那就更好了。你可能有一个错误的配置，只有当它变得太晚(凌晨3点当master停止工作)才会变得明显。 Sentinel，Docker或其他形式的网络地址转换或端口映射应该小心混合：Docker执行端口重新映射，破坏了其他Sentinel进程的Sentinel自动发现以及主数据库的副本列表。有关更多信息，请参阅本文档后面有关Sentinel和Docker的部分。 配置哨兵edis源发行版包含一个名为Sentinel .conf的文件，它是一个自文档化的示例配置文件，您可以使用它来配置Sentinel，但是典型的最小配置文件，如下所示：
1sentinel monitor mymaster 127.0.0.1 6379 2 2sentinel down-after-milliseconds mymaster 60000 3sentinel failover-timeout mymaster 180000 4sentinel parallel-syncs mymaster 1 5 6sentinel monitor resque 192."><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_blog/posts/redis-sentinel-official-document-translation/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-24T22:36:18+08:00"><meta property="article:modified_time" content="2020-02-24T22:36:18+08:00"><link rel=stylesheet href=/icorer_blog/css/bootstrap.min.css crossorigin=anonymous><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/icorer_blog/sass/main.css><link rel=stylesheet href=/icorer_blog/zoomjs/zoom.min.css><script src=/icorer_blog/js/lazysizes.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/icorer_blog/apple-touch-icon.png><link rel=manifest href=/icorer_blog/site.webmanifest></head><body><nav class="navbar navbar-default navbar-custom navbar-fixed-top invert"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://icorer.com/icorer_blog/>笔迹-工匠之芯</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=https://icorer.com title=工匠之芯>工匠之芯</a></li><li><a href=https://icorer.com/icorer_about title=关于我>关于我</a></li><li><a href=https://github.com/gitsrc title=开源仓库>开源仓库</a></li><li class=search-icon><a href=javascript:void(0)><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse"),__HuxNav__={close:function(){$navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)},open:function(){$collapse.style.height="auto",$navbar.className+=" in"}};$toggle.addEventListener("click",function(){$navbar.className.indexOf("in")>0?__HuxNav__.close():__HuxNav__.open()}),document.addEventListener("click",function(e){if(e.target==$toggle)return;if(e.target.className=="icon-bar")return;__HuxNav__.close()})</script><div class=search-page><div class=search-icon-close-container><span class=search-icon-close><i class="fa fa-chevron-down"></i></span></div><div class="search-main container"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><form></form><input type=text id=search-input placeholder=内容搜索...></form><div id=search-results class=mini-post-list></div></div></div></div></div><style type=text/css>header.intro-header{position:relative;background-image:url('')}</style><header class="intro-header style-text"><div class=header-mask></div><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/icorer_blog/tags/redis/ title=redis>redis</a></div><h1>Redis哨兵-官方文档翻译</h1><h2 class=subheading></h2><span class=meta>Posted by LB
on Mon, Feb 24, 2020</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h2 id=sentinel概述>Sentinel概述<a class=anchorjs-link href=#sentinel%e6%a6%82%e8%bf%b0></a></h2><p>Redis Sentinel为Redis提供高可用性。实际上，这意味着使用"哨兵"可以创建一个不需要人工干预就能抵抗某些类型失败的Redis部署。</p><p>Redis Sentinel还提供其他附属任务，如监控、通知和为客户提供配置。</p><p>这是宏观上（即全局）Sentinel功能的完整列表：</p><ul><li><strong>监视</strong>：Sentinel会不断检查你的主实例和副本实例是否按预期工作。</li><li><strong>通知</strong>：Sentinel可以通过API通知系统管理员或其他计算机程序，其中一个被监控的Redis实例出了问题。</li><li><strong>自动故障转移</strong>：如果一个主服务器没有按照预期工作，Sentinel可以启动一个故障转移过程，其中一个副本被提升到主服务器，其他附加的副本被重新配置以使用新的主服务器，<strong>使用Redis服务器的应用程序在连接时被告知要使用的新地址</strong>。</li><li><strong>组态设定提供者</strong>：Sentinel充当客户端服务发现的授权来源：客户端连接到Sentinels，以询问负责给定服务的当前Redis主服务器的地址。 如果发生故障转移，Sentinels将报告新地址。</li></ul><h2 id=sentinel的分布式性质>Sentinel的分布式性质<a class=anchorjs-link href=#sentinel%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e6%80%a7%e8%b4%a8></a></h2><p>Redis Sentinel是一个分布式系统：</p><p>哨兵本身被设计成在一个有多个协作的哨兵进程的配置中运行。有多个哨兵进程协作的好处如下:</p><ol><li>当多个哨兵一致认为某个主节点不再可用时，就会执行故障检测。这降低了误报的概率。</li><li>即使不是所有的哨兵进程都在工作，哨兵也能工作，这使得系统对故障具有健壮性。毕竟，拥有一个本身就是单点故障的故障转移系统是毫无乐趣的。</li></ol><p>哨兵、Redis实例(主实例和副本实例)和连接到哨兵和Redis的客户机的所有组成部分是一个更大的具有特定属性的分布式系统。在本文档中，将逐步介绍概念，从为了理解Sentinel的基本属性所需的基本信息，到为了理解哨兵的工作原理的更复杂的信息（可选）。</p><h2 id=快速入门>快速入门<a class=anchorjs-link href=#%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8></a></h2><h3 id=获得哨兵>获得哨兵<a class=anchorjs-link href=#%e8%8e%b7%e5%be%97%e5%93%a8%e5%85%b5></a></h3><p>当前版本的Sentinel称为Sentinel 2。它是对最初的哨兵实现的重写，使用了更强大、更简单的预测算法(在本文档中有解释)。</p><p>自Redis 2.8起已发布稳定版本的Redis Sentinel。</p><p>在不稳定分支中进行了新的开发，并且有时新功能一旦被认为是稳定的，便会立即移植回最新的稳定分支。</p><p>Redis Sentinel版本1(随Redis 2.6一起发布)是不推荐使用的。</p><h3 id=运行哨兵>运行哨兵<a class=anchorjs-link href=#%e8%bf%90%e8%a1%8c%e5%93%a8%e5%85%b5></a></h3><p>如果您正在使用redis-sentinel可执行文件(或者如果您有一个与redis-server可执行文件同名的符号链接)，您可以使用以下命令行运行Sentinel：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>redis-sentinel /path/to/sentinel.conf
</span></span></code></pre></div><p>否则，您可以直接使用redis-server可执行文件以Sentinel模式启动它：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>redis-server /path/to/sentinel.conf --sentinel
</span></span></code></pre></div><p>这两种方法的工作方式相同。</p><p>但是，在<strong>运行Sentinel时必须使用一个配置文件</strong>，因为系统会使用这个文件来<strong>保存在重新启动时要重新载入的当前状态</strong>。如果没有配置文件，或者配置文件路径不可写，Sentinel将拒绝启动。</p><p>哨兵默认情况下会监听TCP端口26379的连接，因此，为了使哨兵正常工作，必须打开服务器的端口26379，以接收来自其他哨兵实例的IP地址的连接。 否则，哨兵无法讨论也不能就该做什么达成共识，因此将永远不会执行故障转移。</p><h3 id=部署哨兵前需要了解的基本内容>部署哨兵前需要了解的基本内容<a class=anchorjs-link href=#%e9%83%a8%e7%bd%b2%e5%93%a8%e5%85%b5%e5%89%8d%e9%9c%80%e8%a6%81%e4%ba%86%e8%a7%a3%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%86%85%e5%ae%b9></a></h3><ol><li>一个健壮的部署至少需要三个Sentinel实例。</li><li>应将三个哨兵实例放置到被认为以独立方式发生故障的计算机或虚拟机中。例如在不同的可用区域上执行的不同物理服务器或虚拟机。</li><li>Sentinel + Redis分布式系统不保证在故障期间保留已确认的写入，因为Redis使用异步复制。但是，有一些部署Sentinel的方法使窗口丢失写入仅限于某些时刻，而还有其他一些不太安全的方法来部署它。</li><li>您的客户需要Sentinel支持。 流行的客户端库具有Sentinel支持，但不是全部。</li><li>如果您不经常在开发环境中进行测试，那么就没有HA设置是安全的，如果您可以在生产环境中进行测试，如果它们能够工作，那就更好了。你可能有一个错误的配置，只有当它变得太晚(凌晨3点当master停止工作)才会变得明显。</li><li>Sentinel，Docker或其他形式的网络地址转换或端口映射应该小心混合：Docker执行端口重新映射，破坏了其他Sentinel进程的Sentinel自动发现以及主数据库的副本列表。有关更多信息，请参阅本文档后面有关Sentinel和Docker的部分。</li></ol><h3 id=配置哨兵>配置哨兵<a class=anchorjs-link href=#%e9%85%8d%e7%bd%ae%e5%93%a8%e5%85%b5></a></h3><p>edis源发行版包含一个名为Sentinel .conf的文件，它是一个自文档化的示例配置文件，您可以使用它来配置Sentinel，但是典型的最小配置文件，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>sentinel monitor mymaster 127.0.0.1 <span style=color:#bd93f9>6379</span> <span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>sentinel down-after-milliseconds mymaster <span style=color:#bd93f9>60000</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>sentinel failover-timeout mymaster <span style=color:#bd93f9>180000</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>sentinel parallel-syncs mymaster <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>sentinel monitor resque 192.168.1.3 <span style=color:#bd93f9>6380</span> <span style=color:#bd93f9>4</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>sentinel down-after-milliseconds resque <span style=color:#bd93f9>10000</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span>sentinel failover-timeout resque <span style=color:#bd93f9>180000</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span><span>sentinel parallel-syncs resque <span style=color:#bd93f9>5</span>
</span></span></code></pre></div><p>您只需要指定要监视的主机，为每个单独的主机(可能有任意数量的副本)提供一个不同的名称。 无需指定自动发现的副本。 Sentinel将使用有关副本的其他信息自动更新配置（以便在重启时保留该信息）。 每当在故障转移期间将副本提升为主副本时，以及每次发现新的Sentinel时，都会重写配置。</p><p>上面的示例配置基本上监视两组Redis实例，每组实例由一个主实例和一个未定义数量的副本组成。一组实例称为mymaster，另一组称为resque。</p><p>哨兵监视器语句的参数含义如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;
</span></span></code></pre></div><p>为了清晰起见，让我们逐行检查配置选项的含义:</p><p>第一行用于告诉Redis监视一个名为mymaster的主机，该主机位于地址127.0.0.1和端口6379，仲裁者数量为2。一切都很明显，除了仲裁参数：</p><ul><li>仲裁人数是需要就主机不可到达这一事实达成共识的哨兵人数，以便将主机真正标记为发生故障，并在可能的情况下最终启动故障转移过程。</li><li>然而，仲裁仅用于检测故障。为了实际执行故障转移，其中一个哨兵需要被选为故障转移的领导人，并被授权继续进行。<strong>这只会发生在哨兵进程的大多数投票中</strong>。</li></ul><p>例如，如果您有5个哨兵进程，并且给定主服务器的仲裁设置为2，则将发生以下情况：</p><ul><li>如果两个哨兵同时同意主节点不可到达，其中一个将尝试启动故障转移。</li><li>如果至少有三个哨兵可用，则将授权故障转移并实际启动。</li></ul><p>实际上，这意味着在故障期间，如果大多数标记进程无法通信(也就是在少数分区中没有故障转移)，则标记进程将永远不会启动故障转移。</p><h3 id=其他哨兵选项>其他哨兵选项<a class=anchorjs-link href=#%e5%85%b6%e4%bb%96%e5%93%a8%e5%85%b5%e9%80%89%e9%a1%b9></a></h3><p>其他选项几乎总是采用以下形式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>sentinel &lt;option_name&gt; &lt;master_name&gt; &lt;option_value&gt;
</span></span></code></pre></div><p>及作下列用途:</p><ul><li><strong>down-after-milliseconds</strong>：是指Sentinel开始认为实例已关闭的情况下，该实例不应到达的时间（以毫秒为单位）（无论是不回复我们的PING还是出现错误）。</li><li><strong>parallel-syncs</strong>：在故障转移后可以重新配置为使用新的主副本的副本数。该数字越小，完成故障转移过程所花费的时间就越多，但是，如果将副本配置为提供旧数据，则可能不希望所有副本同时与主数据库重新同步。虽然复制过程对副本来说基本上是非阻塞的，但有时它会停止从主服务器加载大量数据。您可能希望通过将此选项设置为值1来确保一次只能访问一个副本。</li></ul><p>其他选项在本文的其余部分中进行了描述，并在Redis发行版附带的示例sentinel.conf文件中进行了说明。</p><p>所有配置参数都可以在运行时使用SENTINEL SET命令进行修改。有关更多信息，请参见<strong>Reconfiguring Sentinel at runtime</strong>章节。</p><h3 id=哨兵部署示例>哨兵部署示例<a class=anchorjs-link href=#%e5%93%a8%e5%85%b5%e9%83%a8%e7%bd%b2%e7%a4%ba%e4%be%8b></a></h3><p>既然您已了解有关哨兵的基本信息，您可能会想知道应该将哨兵进程放置在何处，需要多少个哨兵进程等等。</p><p>本节展示一些示例部署。我们使用ASCII艺术，以图形格式向您展示配置示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>+--------------------+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>|</span> This is a computer <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>|</span> or VM that fails   <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6>|</span> independently. We  <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#ff79c6>|</span> call it a <span style=color:#f1fa8c>&#34;box&#34;</span>    <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span><span style=color:#ff79c6>+--------------------+</span>
</span></span></code></pre></div><p>我们在框内写下它们正在运行的内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>+-------------------+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>|</span> Redis master M1   <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>|</span> Redis Sentinel S1 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6>+-------------------+</span>
</span></span></code></pre></div><p>不同的盒子用线连接起来，以表明它们能够通话：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>+-------------+</span>               <span style=color:#ff79c6>+-------------+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>|</span> Sentinel S1 <span style=color:#ff79c6>|---------------|</span> Sentinel S2 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>+-------------+</span>               <span style=color:#ff79c6>+-------------+</span>
</span></span></code></pre></div><p>网络分区显示为使用斜线的中断线:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>+-------------+</span>                <span style=color:#ff79c6>+-------------+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>|</span> Sentinel S1 <span style=color:#ff79c6>|------</span> <span style=color:#6272a4>// ------| Sentinel S2 |
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span><span style=color:#ff79c6>+-------------+</span>                <span style=color:#ff79c6>+-------------+</span>
</span></span></code></pre></div><p>还要注意:</p><ul><li>主节点称为M1，M2，M3，&mldr;，Mn。</li><li>副本被称为R1, R2, R3，…， Rn (R代表replica)。</li><li>哨兵被称为S1, S2, S3，…,Sn。</li><li>客户被称为C1, C2, C3，…Cn。</li><li>当实例由于哨兵动作而更改角色时，我们将其放在方括号中，因此[M1]表示由于哨兵干预而成为主实例的实例。</li><li>请注意，<strong>我们永远不会显示仅使用两个哨兵的设置</strong>，因为哨兵始终需要与大多数人进行交谈才能启动故障转移。</li></ul><h3 id=示例1仅两个哨兵不要这样做>示例1：仅两个哨兵，不要这样做<a class=anchorjs-link href=#%e7%a4%ba%e4%be%8b1%e4%bb%85%e4%b8%a4%e4%b8%aa%e5%93%a8%e5%85%b5%e4%b8%8d%e8%a6%81%e8%bf%99%e6%a0%b7%e5%81%9a></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>+----+</span>         <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>|</span> M1 <span style=color:#ff79c6>|---------|</span> R1 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>|</span> S1 <span style=color:#ff79c6>|</span>         <span style=color:#ff79c6>|</span> S2 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6>+----+</span>         <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span><span style=color:#8be9fd;font-style:italic>Configuration</span>: quorum <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>
</span></span></code></pre></div><ul><li>在这个设置中，如果主M1失败，R1将被提升，因为两个哨兵可以就失败达成一致(显然将quorum设置为1)，并且由于大多数是两个，因此也可以授权故障转移。所以很明显，表面上它可以工作，但是，请检查下面的要点，看看为什么这个设置是错误的。</li><li>如果M1所在的盒子停止工作，S1也停止工作。在另一个机器S2中运行的标记将无法授权故障转移，因此系统将不可用。</li></ul><p>请注意，需要多数才能订购不同的故障转移，然后将最新配置传播到所有Sentinel。 还要注意，在没有任何协议的情况下，在上述设置的单方面进行故障转移的能力将非常危险：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>+----+</span>           <span style=color:#ff79c6>+------+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>|</span> M1 <span style=color:#ff79c6>|----</span><span style=color:#6272a4>//-----| [M1] |
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span><span style=color:#ff79c6>|</span> S1 <span style=color:#ff79c6>|</span>           <span style=color:#ff79c6>|</span> S2   <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6>+----+</span>           <span style=color:#ff79c6>+------+</span>
</span></span></code></pre></div><p>在上面的配置中，我们以完全对称的方式创建了两个主机(假设S2可以在没有授权的情况下进行故障转移)。客户可能会无限期地向双方写信，并且没有办法了解分区何时修复正确的配置，<strong>以防止出现永久性的脑裂状况</strong>。</p><p>因此，<strong>请始终在三个不同的盒子中至少部署三个哨兵</strong>。</p><h3 id=示例2三个盒子的基本设置>示例2：三个盒子的基本设置<a class=anchorjs-link href=#%e7%a4%ba%e4%be%8b2%e4%b8%89%e4%b8%aa%e7%9b%92%e5%ad%90%e7%9a%84%e5%9f%ba%e6%9c%ac%e8%ae%be%e7%bd%ae></a></h3><p>这是一个非常简单的设置，其优点是易于调整以提高安全性。它基于三个盒子，每个盒子运行一个Redis进程和一个标记进程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>       <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>       <span style=color:#ff79c6>|</span> M1 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>       <span style=color:#ff79c6>|</span> S1 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>       <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>          <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#ff79c6>+----+</span>    <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#ff79c6>|</span> R2 <span style=color:#ff79c6>|----+----|</span> R3 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#ff79c6>|</span> S2 <span style=color:#ff79c6>|</span>         <span style=color:#ff79c6>|</span> S3 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:#ff79c6>+----+</span>         <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#8be9fd;font-style:italic>Configuration</span>: quorum <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>
</span></span></code></pre></div><p>如果主M1失败，则S2和S3将对失败达成一致，并将能够授权故障转移，从而使客户端能够继续。</p><p>在每个Sentinel设置中，由于Redis使用异步复制，因此始终存在丢失某些写入的风险，因为给定的已确认写入可能无法到达被提升为主副本的副本。在上述设置中，由于客户端被旧的主服务器分区，因此存在较高的风险，如下图所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>         <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>         <span style=color:#ff79c6>|</span> M1 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>         <span style=color:#ff79c6>|</span> S1 <span style=color:#ff79c6>|</span> <span style=color:#ff79c6>&lt;-</span> <span style=color:#50fa7b>C1</span> (writes will be lost)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>         <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>            <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>            <span style=color:#ff79c6>/</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>            <span style=color:#ff79c6>/</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#ff79c6>+------+</span>    <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:#ff79c6>|</span> [M2] <span style=color:#ff79c6>|----+----|</span> R3 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#ff79c6>|</span> S2   <span style=color:#ff79c6>|</span>         <span style=color:#ff79c6>|</span> S3 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#ff79c6>+------+</span>         <span style=color:#ff79c6>+----+</span>
</span></span></code></pre></div><p>在这种情况下，网络分区隔离了旧的主数据库M1，因此副本R2被提升为主数据库。但是，与旧主服务器位于同一分区中的客户端（例如C1）可能会继续向旧主服务器写入数据。 此数据将永远丢失，因为当分区恢复正常时，主服务器将被重新配置为新主服务器的副本，从而丢弃其数据集。</p><p><strong>使用以下Redis复制特性可以缓解此问题，该特性允许在主服务器检测到无法将写操作转移到指定数量的副本时停止接受写操作。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>min<span style=color:#ff79c6>-</span>replicas<span style=color:#ff79c6>-</span>to<span style=color:#ff79c6>-</span>write <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>min<span style=color:#ff79c6>-</span>replicas<span style=color:#ff79c6>-</span>max<span style=color:#ff79c6>-</span>lag <span style=color:#bd93f9>10</span>
</span></span></code></pre></div><p>使用上面的配置(请参阅Redis发行版中的自注释Redis .conf示例以获得更多信息)，当Redis实例作为一个主实例时，如果它不能对至少一个副本进行写操作，则将停止接受写操作。由于复制是异步的，因此实际上无法写入意味着从副本已断开连接，或者未向我们发送异步确认超过指定的最大延迟秒数。</p><p>使用此配置，上面示例中的旧Redis master M1将在10秒后不可用。当分区恢复后，哨兵配置将收敛到新的配置，客户端C1将能够获取有效的配置并继续使用新的主服务器。</p><p>但是没有免费的午餐。 通过这种改进，如果两个副本都已关闭，则主服务器将停止接受写入。 这是一个权衡。</p><h3 id=示例3客户端盒子中的哨兵特殊方案>示例3：客户端盒子中的哨兵（特殊方案）<a class=anchorjs-link href=#%e7%a4%ba%e4%be%8b3%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9b%92%e5%ad%90%e4%b8%ad%e7%9a%84%e5%93%a8%e5%85%b5%e7%89%b9%e6%ae%8a%e6%96%b9%e6%a1%88></a></h3><p>有时我们只有两个可用的Redis机器，一个用于主机器，另一个用于副本。在这种情况下，示例2中的配置是不可行的，因此我们可以采用以下方法，即在客户机所在的位置放置哨兵。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>            <span style=color:#ff79c6>+----+</span>         <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>            <span style=color:#ff79c6>|</span> M1 <span style=color:#ff79c6>|----+----|</span> R1 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>            <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>            <span style=color:#ff79c6>+----+</span>    <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>                      <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>         <span style=color:#ff79c6>+------------+------------+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>         <span style=color:#ff79c6>|</span>            <span style=color:#ff79c6>|</span>            <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>         <span style=color:#ff79c6>|</span>            <span style=color:#ff79c6>|</span>            <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>      <span style=color:#ff79c6>+----+</span>        <span style=color:#ff79c6>+----+</span>      <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>      <span style=color:#ff79c6>|</span> C1 <span style=color:#ff79c6>|</span>        <span style=color:#ff79c6>|</span> C2 <span style=color:#ff79c6>|</span>      <span style=color:#ff79c6>|</span> C3 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>      <span style=color:#ff79c6>|</span> S1 <span style=color:#ff79c6>|</span>        <span style=color:#ff79c6>|</span> S2 <span style=color:#ff79c6>|</span>      <span style=color:#ff79c6>|</span> S3 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>      <span style=color:#ff79c6>+----+</span>        <span style=color:#ff79c6>+----+</span>      <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>      <span style=color:#8be9fd;font-style:italic>Configuration</span>: quorum <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>
</span></span></code></pre></div><p>在此设置中，哨兵的观点与客户机相同:如果大多数客户机都可以访问主服务器，那就没问题。 C1，C2，C3是通用客户端，并不意味着C1标识连接到Redis的单个客户端。它更像是应用服务器、Rails应用程序或类似的东西。</p><p>如果运行M1和S1的机器发生故障，故障转移将不会出现问题，但是很容易看到不同的网络分区将导致不同的行为。例如，如果客户端和Redis服务器之间的网络断开，Sentinel将无法设置，因为Redis主服务器和副本都不可用。</p><p>请注意，如果C3被M1分区（在上述网络中几乎是不可能的，但是在不同的布局中或者由于软件层的故障，则更有可能），我们将遇到与示例2中所述类似的问题，区别在于 在这里，我们没有办法打破对称性，因为只有一个副本和一个主服务器，所以当主服务器与其副本断开连接时，主服务器无法停止接受查询，否则在副本失败时该主服务器将永远不可用。</p><p>因此，这是一个有效的设置，但是示例2中的设置具有以下优点，例如Redis的HA系统与Redis本身在相同的框中运行，可能更易于管理，以及在少数分区中设置主分区可以接收写操作的时间范围的能力。</p><h3 id=示例4少于三个客户端的sentinel客户端>示例4：少于三个客户端的Sentinel客户端<a class=anchorjs-link href=#%e7%a4%ba%e4%be%8b4%e5%b0%91%e4%ba%8e%e4%b8%89%e4%b8%aa%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9a%84sentinel%e5%ae%a2%e6%88%b7%e7%ab%af></a></h3><p>如果客户端少于三个框（例如三个Web服务器），则无法使用示例3中描述的设置。 在这种情况下，我们需要采用如下混合设置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>            <span style=color:#ff79c6>+----+</span>         <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>            <span style=color:#ff79c6>|</span> M1 <span style=color:#ff79c6>|----+----|</span> R1 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>            <span style=color:#ff79c6>|</span> S1 <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>|</span> S2 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>            <span style=color:#ff79c6>+----+</span>    <span style=color:#ff79c6>|</span>    <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>                      <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>               <span style=color:#ff79c6>+------+-----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>               <span style=color:#ff79c6>|</span>            <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>               <span style=color:#ff79c6>|</span>            <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>            <span style=color:#ff79c6>+----+</span>        <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>            <span style=color:#ff79c6>|</span> C1 <span style=color:#ff79c6>|</span>        <span style=color:#ff79c6>|</span> C2 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>            <span style=color:#ff79c6>|</span> S3 <span style=color:#ff79c6>|</span>        <span style=color:#ff79c6>|</span> S4 <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>            <span style=color:#ff79c6>+----+</span>        <span style=color:#ff79c6>+----+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>      <span style=color:#8be9fd;font-style:italic>Configuration</span>: quorum <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>
</span></span></code></pre></div><p>这与示例3中的设置类似，但在这里，我们在四个可用的盒子中运行四个哨兵。如果主M1不可用，其他三个哨兵将执行故障转移。</p><p>从理论上讲，这种设置可以删除C2和S4运行的方框，并将quorum设置为2。然而，如果在我们的应用层中没有高可用性，我们就不太可能希望在Redis端使用HA。</p><h3 id=哨兵dockernat和可能的问题>哨兵，Docker，NAT和可能的问题<a class=anchorjs-link href=#%e5%93%a8%e5%85%b5dockernat%e5%92%8c%e5%8f%af%e8%83%bd%e7%9a%84%e9%97%ae%e9%a2%98></a></h3><p>Docker使用了一种称为端口映射的技术:在Docker容器中运行的程序可能与它认为正在使用的端口不同。这对于在同一台服务器上同时运行多个使用相同端口的容器非常有用。</p><p>Docker并不是发生这种情况的唯一软件系统，还有其他网络地址转换设置，其中端口可以重新映射，有时不是端口，而是IP地址。</p><p>重新映射端口和地址会以两种方式导致Sentinel出现问题：</p><ol><li>哨兵自动发现其他哨兵不再有效，因为它基于问候消息，其中每个哨兵宣布它们正在侦听连接的端口和IP地址。 但是，哨兵无法理解地址或端口是否已重新映射，因此它宣布的信息对于其他哨兵连接而言是不正确的。</li><li>副本以类似的方式列在Redis主服务器的INFO输出中：主服务器检查TCP连接的远程对等方时检测到该地址，而端口在握手期间由副本自身发布，但是该端口可能是 错误的原因与第1点所述相同。</li></ol><p>由于哨兵使用主服务器INFO输出信息自动检测副本，因此检测到的副本将无法访问，并且哨兵将永远无法对主副本进行故障转移，因为从系统的角度来看，没有好的副本，因此目前没有用哨兵监视一组与Docker一起部署的主实例和副本实例，除非您指示Docker映射端口1：1。</p><p>对于第一个问题，如果您想使用带有转发端口的Docker（或重新映射端口的任何其他NAT设置）使用Docker运行一组Sentinel实例，则可以使用以下两个Sentinel配置指令来强制Sentinel宣布 特定的IP和端口集：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>sentinel announce<span style=color:#ff79c6>-</span>ip <span style=color:#ff79c6>&lt;</span>ip<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>sentinel announce<span style=color:#ff79c6>-</span>port <span style=color:#ff79c6>&lt;</span>port<span style=color:#ff79c6>&gt;</span>
</span></span></code></pre></div><p>请注意，Docker可以在主机联网模式下运行（请检查&ndash;net=host选项以获取更多信息）。 这不会造成任何问题，因为在此设置中未重新映射端口。</p><h2 id=快速教程>快速教程<a class=anchorjs-link href=#%e5%bf%ab%e9%80%9f%e6%95%99%e7%a8%8b></a></h2><p>在本文档的下一部分中，将逐步介绍有关Sentinel API，配置和语义的所有详细信息。 但是，对于希望尽快使用系统的人来说，本节是一个教程，显示如何配置3个Sentinel实例并与之交互。</p><p>在这里，我们假设实例是在端口5000、5001、5002上执行的。我们还假设您在端口6379上具有正在运行的Redis主服务器，而副本服务器在端口6380上运行。 本教程，假设您正在个人计算机上运行模拟。</p><p>三个Sentinel配置文件应如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>port <span style=color:#bd93f9>5000</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>sentinel monitor mymaster <span style=color:#bd93f9>127.0.0.1</span> <span style=color:#bd93f9>6379</span> <span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>sentinel down<span style=color:#ff79c6>-</span>after<span style=color:#ff79c6>-</span>milliseconds mymaster <span style=color:#bd93f9>5000</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>sentinel failover<span style=color:#ff79c6>-</span>timeout mymaster <span style=color:#bd93f9>60000</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>sentinel parallel<span style=color:#ff79c6>-</span>syncs mymaster <span style=color:#bd93f9>1</span>
</span></span></code></pre></div><p>其他两个配置文件是相同的，但是使用5001和5002作为端口号。</p><p>关于上面的配置，有几点需要注意：</p><ul><li>这个主节点集合叫做mymaster。它标识主服务器及其副本。由于每个主集有不同的名称，所以哨兵可以同时监视不同的主集和副本集。</li><li>仲裁设置为2（sentinel Monitor配置指令的最后一个参数）。</li><li>毫秒后的下降值是5000毫秒，也就是5秒，所以一旦我们在这段时间内没有收到来自ping的任何回复，master将被检测为失败。</li></ul><p>一旦你启动了三个哨兵，你会看到他们记录的一些日志信息，比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>+</span>monitor master mymaster <span style=color:#bd93f9>127.0.0.1</span> <span style=color:#bd93f9>6379</span> quorum <span style=color:#bd93f9>2</span>
</span></span></code></pre></div><p><strong>这是一个Sentinel事件，如果您订阅后面指定的事件名称，则可以通过Pub / Sub接收此类事件</strong>。</p><p>在故障检测和故障转移期间，Sentinel生成并记录不同的事件。</p><h3 id=向哨兵询问主机状态>向哨兵询问主机状态<a class=anchorjs-link href=#%e5%90%91%e5%93%a8%e5%85%b5%e8%af%a2%e9%97%ae%e4%b8%bb%e6%9c%ba%e7%8a%b6%e6%80%81></a></h3><p>在开始使用Sentinel时，最明显的做法是检查它所监视的主服务器是否运行良好：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>$ redis<span style=color:#ff79c6>-</span>cli <span style=color:#ff79c6>-</span>p <span style=color:#bd93f9>5000</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#bd93f9>127.0.0.1</span><span style=color:#ff79c6>:</span><span style=color:#bd93f9>5000</span><span style=color:#ff79c6>&gt;</span> sentinel master mymaster
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span> <span style=color:#bd93f9>1</span>) <span style=color:#f1fa8c>&#34;name&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span> <span style=color:#bd93f9>2</span>) <span style=color:#f1fa8c>&#34;mymaster&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span> <span style=color:#bd93f9>3</span>) <span style=color:#f1fa8c>&#34;ip&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span> <span style=color:#bd93f9>4</span>) <span style=color:#f1fa8c>&#34;127.0.0.1&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span> <span style=color:#bd93f9>5</span>) <span style=color:#f1fa8c>&#34;port&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span> <span style=color:#bd93f9>6</span>) <span style=color:#f1fa8c>&#34;6379&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span> <span style=color:#bd93f9>7</span>) <span style=color:#f1fa8c>&#34;runid&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span> <span style=color:#bd93f9>8</span>) <span style=color:#f1fa8c>&#34;953ae6a589449c13ddefaee3538d356d287f509b&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span> <span style=color:#bd93f9>9</span>) <span style=color:#f1fa8c>&#34;flags&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:#bd93f9>10</span>) <span style=color:#f1fa8c>&#34;master&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span><span style=color:#bd93f9>11</span>) <span style=color:#f1fa8c>&#34;link-pending-commands&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span><span style=color:#bd93f9>12</span>) <span style=color:#f1fa8c>&#34;0&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span><span style=color:#bd93f9>13</span>) <span style=color:#f1fa8c>&#34;link-refcount&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span><span style=color:#bd93f9>14</span>) <span style=color:#f1fa8c>&#34;1&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:#bd93f9>15</span>) <span style=color:#f1fa8c>&#34;last-ping-sent&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span><span style=color:#bd93f9>16</span>) <span style=color:#f1fa8c>&#34;0&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span><span style=color:#bd93f9>17</span>) <span style=color:#f1fa8c>&#34;last-ok-ping-reply&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span><span style=color:#bd93f9>18</span>) <span style=color:#f1fa8c>&#34;735&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span><span style=color:#bd93f9>19</span>) <span style=color:#f1fa8c>&#34;last-ping-reply&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span><span style=color:#bd93f9>20</span>) <span style=color:#f1fa8c>&#34;735&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span><span style=color:#bd93f9>21</span>) <span style=color:#f1fa8c>&#34;down-after-milliseconds&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span><span style=color:#bd93f9>22</span>) <span style=color:#f1fa8c>&#34;5000&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span><span style=color:#bd93f9>23</span>) <span style=color:#f1fa8c>&#34;info-refresh&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span><span style=color:#bd93f9>24</span>) <span style=color:#f1fa8c>&#34;126&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span><span style=color:#bd93f9>25</span>) <span style=color:#f1fa8c>&#34;role-reported&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span><span style=color:#bd93f9>26</span>) <span style=color:#f1fa8c>&#34;master&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span><span style=color:#bd93f9>27</span>) <span style=color:#f1fa8c>&#34;role-reported-time&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span><span style=color:#bd93f9>28</span>) <span style=color:#f1fa8c>&#34;532439&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span><span style=color:#bd93f9>29</span>) <span style=color:#f1fa8c>&#34;config-epoch&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span><span style=color:#bd93f9>30</span>) <span style=color:#f1fa8c>&#34;1&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span><span style=color:#bd93f9>31</span>) <span style=color:#f1fa8c>&#34;num-slaves&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span><span style=color:#bd93f9>32</span>) <span style=color:#f1fa8c>&#34;1&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span><span style=color:#bd93f9>33</span>) <span style=color:#f1fa8c>&#34;num-other-sentinels&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span><span style=color:#bd93f9>34</span>) <span style=color:#f1fa8c>&#34;2&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span><span style=color:#bd93f9>35</span>) <span style=color:#f1fa8c>&#34;quorum&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span><span style=color:#bd93f9>36</span>) <span style=color:#f1fa8c>&#34;2&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39</span><span><span style=color:#bd93f9>37</span>) <span style=color:#f1fa8c>&#34;failover-timeout&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40</span><span><span style=color:#bd93f9>38</span>) <span style=color:#f1fa8c>&#34;60000&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41</span><span><span style=color:#bd93f9>39</span>) <span style=color:#f1fa8c>&#34;parallel-syncs&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42</span><span><span style=color:#bd93f9>40</span>) <span style=color:#f1fa8c>&#34;1&#34;</span>
</span></span></code></pre></div><p>如您所见，它打印了大量关于master的信息。以下是我们特别感兴趣的一些：</p><ol><li>num-other-sentinels是2，因此我们知道Sentinel已经为该主服务器检测到了另外两个Sentinel。 如果您查看日志，将会看到生成的+ sentinel事件。</li><li>flag显示为master。 如果主服务器宕机，我们也可以在这里看到s_down或o_down标志。</li><li>num-slaves正确设置为1，因此Sentinel还检测到我们的主服务器有附加的副本。</li></ol><p>为了进一步了解此实例，您可能需要尝试以下两个命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>SENTINEL slaves mymaster
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>SENTINEL sentinels mymaster
</span></span></code></pre></div><p>第一个将提供有关连接到mater的副本的类似信息，第二个将提供有关其他Sentinel的信息。</p><h3 id=获取当前主服务器的地址>获取当前主服务器的地址<a class=anchorjs-link href=#%e8%8e%b7%e5%8f%96%e5%bd%93%e5%89%8d%e4%b8%bb%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e5%9c%b0%e5%9d%80></a></h3><p>正如我们已经指定的，Sentinel还充当想要连接到一组主服务器和副本的客户端的配置提供者。由于可能出现故障转移或重新配置，客户端不知道对于给定的一组实例，谁是当前活动的主人，因此Sentinel导出一个API来询问这个问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#bd93f9>127.0.0.1</span><span style=color:#ff79c6>:</span><span style=color:#bd93f9>5000</span><span style=color:#ff79c6>&gt;</span> SENTINEL get<span style=color:#ff79c6>-</span>master<span style=color:#ff79c6>-</span>addr<span style=color:#ff79c6>-</span>by<span style=color:#ff79c6>-</span>name mymaster
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#bd93f9>1</span>) <span style=color:#f1fa8c>&#34;127.0.0.1&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#bd93f9>2</span>) <span style=color:#f1fa8c>&#34;6379&#34;</span>
</span></span></code></pre></div><h3 id=测试故障转移>测试故障转移<a class=anchorjs-link href=#%e6%b5%8b%e8%af%95%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb></a></h3><p>此时，我们的玩具哨兵部署已准备好进行测试。 我们可以杀死我们的主机，然后检查配置是否更改。 为此，我们可以这样做：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>redis<span style=color:#ff79c6>-</span>cli <span style=color:#ff79c6>-</span>p <span style=color:#bd93f9>6379</span> DEBUG sleep <span style=color:#bd93f9>30</span>
</span></span></code></pre></div><p>此命令将使我们的主服务器停止响应，休眠30秒。它基本上模拟了由于某种原因挂起的主服务器。</p><p>如果查看哨兵日志，则应该可以看到很多操作：</p><ol><li>哨兵检测主服务器的+sdown事件。</li><li>此事件随后被升级为+ odown，这意味着多个哨兵同意主节点不可访问的事实。</li><li>哨兵投票给将开始第一次故障转移尝试的哨兵。</li><li>故障转移发生。</li></ol><p>如果您再次询问mymaster的当前主地址是什么，最终这次我们应该得到不同的答复：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#bd93f9>127.0.0.1</span><span style=color:#ff79c6>:</span><span style=color:#bd93f9>5000</span><span style=color:#ff79c6>&gt;</span> SENTINEL get<span style=color:#ff79c6>-</span>master<span style=color:#ff79c6>-</span>addr<span style=color:#ff79c6>-</span>by<span style=color:#ff79c6>-</span>name mymaster
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#bd93f9>1</span>) <span style=color:#f1fa8c>&#34;127.0.0.1&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#bd93f9>2</span>) <span style=color:#f1fa8c>&#34;6380&#34;</span>
</span></span></code></pre></div><p>到目前为止一切顺利……此时，您可以跳转来创建哨兵部署，或者可以阅读更多内容以了解所有Sentinel命令和内部信息。</p><h2 id=哨兵api>哨兵API<a class=anchorjs-link href=#%e5%93%a8%e5%85%b5api></a></h2><p>哨兵提供了一个API来检查其状态，检查被监控的主机和副本的健康状况，订阅以接收特定的通知，并在运行时更改Sentinel的配置。</p><p>默认情况下，哨兵使用TCP端口26379运行（请注意，6379是正常的Redis端口）。 哨兵使用Redis协议接受命令，因此您可以使用redis-cli或任何其他未修改的Redis客户端以便与哨兵进行通信。</p><p>可以直接查询哨兵，以从其角度检查受监视的Redis实例的状态，查看其知道的其他哨兵，等等。 或者，使用Pub / Sub，每次发生某些事件（例如故障转移或实例进入错误条件等）时，都可以从哨兵接收推式通知。</p><h3 id=哨兵命令>哨兵命令<a class=anchorjs-link href=#%e5%93%a8%e5%85%b5%e5%91%bd%e4%bb%a4></a></h3><p>以下是已接受命令的列表，但不包括用于修改Sentinel配置的命令，稍后将介绍这些命令。</p><ul><li><strong>PING</strong> 此命令仅返回PONG。</li><li><strong>SENTINEL masters</strong> 显示被监视的master节点们及其状态的列表。</li><li><strong>SENTINEL master &lt; master name ></strong>：显示指定主机的状态和信息。</li><li><strong>SENTINEL slaves &lt; master name></strong> ：显示此主服务器的副本列表及其状态。</li><li><strong>SENTINEL sentinels &lt; master name></strong>： 显示此主服务器的哨兵实例列表及其状态。</li><li><strong>SENTINEL get-master-addr-by-name &lt; master name></strong>：返回具有该名称的主服务器的ip和端口号。 如果此主服务器正在进行故障转移或成功终止，它将返回升级副本的地址和端口。</li><li><strong>SENTINEL reset &lt; pattern ></strong>：此命令将重置所有具有匹配名称的主机。 pattern参数是glob样式的模式。 重置过程将清除主服务器中的所有先前状态（包括正在进行的故障转移），并删除已发现并与主服务器关联的每个副本和标记。</li><li><strong>SENTINEL failover &lt; master name></strong>：强制进行故障转移，就好像主机无法访问一样，并且无需征得其他Sentinels的同意（但是将发布新版本的配置，以便其他Sentinels可以更新其配置）。</li><li><strong>SENTINEL ckquorum &lt; master name></strong>：检查当前的Sentinel配置是否能够达到故障转移主节点所需的仲裁，以及授权故障转移所需的大多数仲裁。 在监视系统中应使用此命令来检查Sentinel部署是否正常。</li><li><strong>SENTINEL ckquorum &lt; master name></strong>：强制Sentinel重写其在磁盘上的配置，包括当前的Sentinel状态。 通常，每当状态更改时（在重新启动后一直保留在磁盘上的状态子集的上下文中），Sentinel都会重写配置。 但是，有时由于操作错误，磁盘故障，程序包升级脚本或配置管理器，配置文件可能会丢失。 在这些情况下，强制Sentinel重写配置文件的方法很方便。 即使先前的配置文件完全丢失，此命令也有效。</li></ul><h3 id=在运行时重新配置哨兵>在运行时重新配置哨兵<a class=anchorjs-link href=#%e5%9c%a8%e8%bf%90%e8%a1%8c%e6%97%b6%e9%87%8d%e6%96%b0%e9%85%8d%e7%bd%ae%e5%93%a8%e5%85%b5></a></h3><p>从Redis版本2.8.4开始，哨兵提供了一个API，以便添加，删除或更改给定主服务器的配置。 请注意，如果您有多个哨兵，则应将所有更改应用于您的实例，以使Redis 哨兵正常工作。 这意味着更改单个哨兵的配置不会自动将更改传播到网络中的其他哨兵。</p><p>以下是用于更新哨兵实例的配置的SENTINEL子命令的列表。</p><ul><li><strong>SENTINEL MONITOR &lt; name> &lt; ip> &lt; port> &lt; quorum></strong>：此命令告诉哨兵开始监视具有指定名称，ip，端口和仲裁的新主服务器。 它与sendinel.conf配置文件中的哨兵监视器配置指令相同，不同之处在于您不能在ip中使用主机名，但需要提供IPv4或IPv6地址。</li><li><strong>SENTINEL REMOVE &lt; name></strong>：用于删除指定的主机：主机将不再受到监视，并且将从Sentinel的内部状态中完全删除，因此SENTINEL主机将不再列出该主机，依此类推。</li><li><strong>SENTINEL SET &lt; name> &lt; option> &lt; value></strong> ：SET命令与Redis的CONFIG SET命令非常相似，用于更改特定主机的配置参数。可以指定多个选项/值对(或者根本不指定)。可以通过sentinel.conf配置的所有配置参数也可以使用SET命令进行配置。</li></ul><p>以下是SENTINEL SET命令的示例，用于修改称为对象高速缓存的主机的毫秒级向下配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>SENTINEL SET objects<span style=color:#ff79c6>-</span>cache<span style=color:#ff79c6>-</span>master down<span style=color:#ff79c6>-</span>after<span style=color:#ff79c6>-</span>milliseconds <span style=color:#bd93f9>1000</span>
</span></span></code></pre></div><p>如前所述，SENTINEL SET可用于设置启动配置文件中可设置的所有配置参数。 而且，可以更改主仲裁配置，而无需先删除并重新添加SENTINEL REMOVE和SENTINEL MONITOR，然后使用以下方法即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>SENTINEL SET objects<span style=color:#ff79c6>-</span>cache<span style=color:#ff79c6>-</span>master quorum <span style=color:#bd93f9>5</span>
</span></span></code></pre></div><p>注意，这里没有等效的GET命令，因为SENTINEL MASTER以简单的解析格式(作为字段/值对数组)提供了所有配置参数。</p><h3 id=增加或移除哨兵>增加或移除哨兵<a class=anchorjs-link href=#%e5%a2%9e%e5%8a%a0%e6%88%96%e7%a7%bb%e9%99%a4%e5%93%a8%e5%85%b5></a></h3><p>由于哨兵实现了自动发现机制，因此向部署中添加新的哨兵是一个简单的过程。 您需要做的就是启动配置为监视当前活动主服务器的新哨兵。 在10秒钟内，哨兵将获取其他哨兵的列表以及附加到master的副本集。</p><p>如果需要一次添加多个Sentinels，建议先添加一个，再等待其他所有Sentinels已经知道第一个，然后再添加下一个。 为了仍然确保只能在分区的一侧实现多数，这很有用，因为在添加新的Sentinels的过程中可能会发生故障。</p><p>通过添加每个新的Sentinel（延迟30秒）以及在没有网络分区的情况下，可以轻松实现这一目标。</p><p>在该过程结束时，可以使用命令SENTINEL MASTER mastername来检查所有Sentinels是否都同意监视主服务器的Sentinels总数。</p><p>删除Sentinel有点复杂：<strong>哨兵永远不会忘记已经见过的哨兵</strong>，即使很长一段时间都无法访问它们，因为我们也不想动态更改授权故障转移和创建新配置号所需的多数。因此，要删除Sentinel，应在没有网络分区的情况下执行以下步骤：</p><ol><li>停止要删除的哨兵的哨兵进程。</li><li>向所有其他Sentinel实例发送SENTINEL RESET <em>命令（如果您只想重置一个主机，则可以使用确切的主机名代替</em>）。一个接一个，在两次实例之间至少等待30秒。</li><li>通过检查每个Sentinel的SENTINEL MASTER主机名的输出，检查所有Sentinels是否同意当前活动的Sentinels数量。</li></ol><h3 id=删除旧的主节点或无法访问的副本>删除旧的主节点或无法访问的副本<a class=anchorjs-link href=#%e5%88%a0%e9%99%a4%e6%97%a7%e7%9a%84%e4%b8%bb%e8%8a%82%e7%82%b9%e6%88%96%e6%97%a0%e6%b3%95%e8%ae%bf%e9%97%ae%e7%9a%84%e5%89%af%e6%9c%ac></a></h3><p>哨兵永远不会忘记给定master的副本，即使长时间无法访问它们也是如此。 这很有用，因为在网络分区或故障事件之后，Sentinels应该能够正确地重新配置返回的副本。</p><p>此外，在故障转移之后，故障转移主服务器实际上被添加为新主服务器的一个副本，通过这种方式，它将被重新配置，以便在新主服务器再次可用时立即复制它。</p><p>然而，有时你想要永远从哨兵监视的副本列表中删除一个副本(可能是旧的master)。</p><p>为此，您需要向所有Sentinel发送SENTINEL RESET mastername命令：它们将在接下来的10秒钟内刷新副本列表，仅添加从当前主INFO输出中正确列出的副本。</p><h3 id=发布订阅消息>发布/订阅消息<a class=anchorjs-link href=#%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e6%b6%88%e6%81%af></a></h3><p>客户端可以使用Sentinel，因为它是与Redis兼容的Pub / Sub服务器（但您不能使用PUBLISH），以便订阅或订阅到频道并获得有关特定事件的通知。</p><p>通道名称与事件名称相同。 例如，名为+ sdown的通道将接收与进入SDOWN的实例相关的所有通知（从您要查询的Sentinel的角度来看，SDOWN意味着该实例不再可访问）。</p><p>要获取所有消息，只需使用PSUBSCRIBE *进行订阅。</p><p>以下是可使用此API接收的频道和消息格式的列表。 第一个单词是通道/事件名称，其余是数据格式。</p><p>注意：如果指定了实例详细信息，则意味着提供了以下参数来标识目标实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>&lt;</span>instance<span style=color:#ff79c6>-</span>type<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>&lt;</span>name<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>&lt;</span>ip<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>&lt;</span>port<span style=color:#ff79c6>&gt;</span> @ <span style=color:#ff79c6>&lt;</span>master<span style=color:#ff79c6>-</span>name<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>&lt;</span>master<span style=color:#ff79c6>-</span>ip<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>&lt;</span>master<span style=color:#ff79c6>-</span>port<span style=color:#ff79c6>&gt;</span>
</span></span></code></pre></div><p>标识主服务器的部分（从@参数到末尾）是可选的，并且仅在实例本身不是主服务器时才指定。</p><ul><li><strong>+reset-master</strong> &lt; instance details> &ndash; 主服务器被重置。</li><li><strong>+slave</strong> &lt; instance details> &ndash; 检测到一个新的副本并附加。</li><li><strong>+failover-state-reconf-slaves</strong> &lt; instance details> &ndash; 故障转移状态已更改为重新配置从属状态。</li><li><strong>+failover-detected</strong> &lt; instance details> &ndash; 检测到由另一个Sentinel或任何其他外部实体启动的故障转移（已将附加副本复制为主服务器）。</li><li><strong>+slave-reconf-sent</strong> &lt; instance details> &ndash; 为了重新配置这个副本，leader sentinel将SLAVEOF命令发送给这个实例。</li><li><strong>+slave-reconf-inprog</strong> &lt; instance details> &ndash; 正在重新配置的副本显示为新主ip:port对的副本，但同步过程尚未完成。</li><li><strong>+slave-reconf-done</strong> &lt; instance details> &ndash; 副本现在与新主服务器同步。</li><li><strong>-dup-sentinel</strong> &lt; instance details> &ndash; 指定的主机的一个或多个哨兵已被删除（例如，此操作在重新启动Sentinel实例时发生）。</li><li><strong>+sentinel</strong> &lt; instance details> &ndash; 一个新的哨兵为这个master被发现和连接。</li><li><strong>+sdown</strong> &lt; instance details> &ndash; 现在，指定的实例处于主观关闭状态。</li><li>-<strong>sdown</strong> &lt; instance details> &ndash; 指定的实例不再处于主观关闭状态。</li><li><strong>+odown</strong> &lt; instance details> &ndash; 现在，指定的实例处于客观关闭状态。</li><li><strong>-odown</strong> &lt; instance details> &ndash; 指定的实例不再处于客观关闭状态。</li><li><strong>+new-epoch</strong> &lt; instance details> &ndash; 当前的纪元已更新。</li><li><strong>+try-failover</strong> &lt; instance details> &ndash; 新的故障转移正在进行中，等待由大多数人选出。</li><li><strong>+elected-leader</strong> &lt; instance details> &ndash; 赢得了指定时期的选举，可以进行故障转移。</li><li><strong>+failover-state-select-slave</strong> &lt; instance details> &ndash; 新的故障转移状态为select-slave：我们正在尝试寻找合适的副本进行升级。</li><li><strong>no-good-slave &lt;</strong> instance details> &ndash; 没有好的复制品可以推广。目前，我们将在一段时间后尝试，但是这种情况可能会改变，状态机将完全中止故障转移。</li><li><strong>selected-slave</strong> &lt; instance details> &ndash; 我们找到了要推广的指定好的副本。</li><li><strong>failover-state-send-slaveof-noone</strong> &lt; instance details> &ndash; 我们正在尝试将升级副本重新配置为主副本，等待它切换。</li><li><strong>failover-end-for-timeout</strong> &lt; instance details> &ndash; 故障切换因超时而终止，无论如何副本最终都将配置为与新的主副本一起复制。</li><li><strong>failover-end</strong> &lt; instance details> &ndash; 故障转移成功结束。所有副本似乎都被重新配置为使用新主服务器进行复制。</li><li><strong>switch-master</strong> &lt; master name> &lt; oldip> &lt; oldport> &lt; newip> &lt; newport> &ndash; 主新IP和地址是配置更改后指定的IP和地址。<strong>这是大多数外部用户感兴趣的消息</strong>。</li><li><strong>+tilt</strong> &ndash; 进入Tilt模式。</li><li><strong>-tilt</strong> &ndash; 退出Tilt模式。</li></ul><h3 id=-busy状态的处理>-BUSY状态的处理<a class=anchorjs-link href=#-busy%e7%8a%b6%e6%80%81%e7%9a%84%e5%a4%84%e7%90%86></a></h3><p>当Lua脚本的运行时间超过配置的Lua脚本的时间限制时，Redis实例将返回-BUSY错误。在触发故障转移之前发生这种情况时，Redis Sentinel将尝试发送一个SCRIPT KILL命令，只有在脚本是只读的情况下才会成功。</p><p>如果该实例在尝试后仍处于错误状态，则最终将对其进行故障转移。</p><h3 id=副本优先级-replicas-priority>副本优先级 (Replicas priority)<a class=anchorjs-link href=#%e5%89%af%e6%9c%ac%e4%bc%98%e5%85%88%e7%ba%a7-replicas-priority></a></h3><p>Redis实例具有一个称为replica-priority（副本优先级）的配置参数。Redis副本实例在其INFO输出中公开了此信息，哨兵使用该信息以便从可用于故障转移master的副本中选择一个副本：</p><ol><li>如果副本优先级设置为0，则永远不会将副本提升为master。</li><li>哨兵优先选择优先级较低的副本。</li></ol><p>例如，如果当前主机的同一数据中心中有一个副本S1，而另一个数据中心中有另一个副本S2，则可以将S1的优先级设置为10，将S2的优先级设置为100，因此如果 主机失败，并且S1和S2均可用，S1将是首选。</p><p>有关选择副本方式的更多信息，请检查本文档的“副本选择和优先级”部分。</p><h3 id=sentinel和redis身份验证>Sentinel和Redis身份验证<a class=anchorjs-link href=#sentinel%e5%92%8credis%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81></a></h3><p>当将主服务器配置为要求客户端提供密码时，作为一种安全措施，副本也需要知道该密码，以便与主服务器进行身份验证并创建用于异步复制协议的主副本服务器连接。</p><p>使用以下配置指令可以实现此目的：</p><ul><li>requirepass在主服务器中，以便设置身份验证密码，并确保实例不会处理未经身份验证的客户端的请求。</li><li>masterauth在副本中，以便让副本通过主服务器的身份验证，以便正确地从其中复制数据。</li></ul><p>使用Sentinel时，没有单个主服务器，因为在故障转移之后，副本可能会充当主服务器，并且可以重新配置旧的主服务器以充当副本，因此您要做的是在 您的所有实例，包括主实例和副本实例。</p><p>这通常也是一种合理的设置，因为您不希望仅保护主服务器中的数据，而是希望在副本中访问相同的数据。</p><p>但是，在不常见的情况下，您需要一个无需身份验证即可访问的副本，您仍然可以通过<strong>将副本优先级设置为零</strong>，以防止将该副本提升为主副本，并仅在该副本中配置masterauth指令来做到这一点。 ，而无需使用requirepass指令，以便未经身份验证的客户端可以读取数据。</p><p>为了在使用requirepass配置哨兵时将哨兵连接到Redis服务器实例，Sentinel配置必须包括哨兵auth-pass指令，格式为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>sentinel auth<span style=color:#ff79c6>-</span>pass <span style=color:#ff79c6>&lt;</span>master<span style=color:#ff79c6>-</span>group<span style=color:#ff79c6>-</span>name<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>&lt;</span>pass<span style=color:#ff79c6>&gt;</span>
</span></span></code></pre></div><h3 id=使用身份验证配置sentinel实例>使用身份验证配置Sentinel实例<a class=anchorjs-link href=#%e4%bd%bf%e7%94%a8%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e9%85%8d%e7%bd%aesentinel%e5%ae%9e%e4%be%8b></a></h3><p>您也可以配置Sentinel实例本身，以通过AUTH命令要求客户端身份验证，但是此功能仅从Redis 5.0.1开始可用。</p><p>为此，只需将以下配置指令添加到所有Sentinel实例中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>requirepass <span style=color:#f1fa8c>&#34;your_password_here&#34;</span>
</span></span></code></pre></div><p>以这种方式配置后，Sentinels将执行以下两项操作：</p><ol><li>客户端需要密码才能发送命令到Sentinels。 这很明显，因为通常这是Redis中这种配置指令的工作方式。</li><li>此外，此Sentinel实例将使用配置为访问本地Sentinel的相同密码，以对其连接到的所有其他Sentinel实例进行身份验证。</li></ol><p><strong>这意味着您将必须在所有Sentinel实例中配置相同的requirepass密码</strong>。这样，每个Sentinel都可以与其他Sentinel进行对话，而无需为每个Sentinel配置访问所有其他Sentinels的密码，这是非常不切实际的。</p><p>在使用此配置之前，请确保您的客户端库能够将AUTH命令发送到Sentinel实例。</p><h3 id=哨兵客户端实现>哨兵客户端实现<a class=anchorjs-link href=#%e5%93%a8%e5%85%b5%e5%ae%a2%e6%88%b7%e7%ab%af%e5%ae%9e%e7%8e%b0></a></h3><p>除非将系统配置为执行一个脚本，该脚本将所有请求透明地重定向到新主实例(虚拟IP或其他类似系统)，否则Sentinel需要显式客户端支持。户端库实现的主题包含在文档<a href=https://redis.io/topics/sentinel-clients target=_blank>Sentinel clients指南</a>中。</p><h2 id=更高级的概念>更高级的概念<a class=anchorjs-link href=#%e6%9b%b4%e9%ab%98%e7%ba%a7%e7%9a%84%e6%a6%82%e5%bf%b5></a></h2><p>在接下来的小节中，我们将介绍一些有关Sentinel如何工作的细节，而不会涉及本文档最后一部分将介绍的实现细节和算法。</p><h3 id=sdown和odown故障状态>SDOWN和ODOWN故障状态<a class=anchorjs-link href=#sdown%e5%92%8codown%e6%95%85%e9%9a%9c%e7%8a%b6%e6%80%81></a></h3><p>Redis Sentinel具有两个不同的关闭状态，一个称为主观关闭状态（SDOWN），它是给定Sentinel实例本地的关闭状态。另一种被称为客观下降条件(ODOWN)，当足够多的哨兵(至少是被监控的主节点的仲裁参数配置的数量)具有一个SDOWN条件时，就会达到这个状态，并使用SENTINEL is-master- down -by-addr命令从其他哨兵那里获得反馈。</p><p>从Sentinel的角度来看，如果在配置中指定的秒数为is-master-down-after-milliseconds，则它没有收到对PING请求的有效答复，则达到SDOWN条件。</p><p>可以接受的对PING的回复如下所示:</p><ul><li>PING回复了+ PONG。</li><li>PING回复-LOADING错误。</li><li>PING答复-MASTERDOWN错误。</li></ul><p>任何其他答复（或根本没有答复）均被视为无效。 <strong>但是请注意，在INFO输出中将自己作为副本发布的逻辑主机被视为已关闭。</strong></p><p>请注意，SDOWN要求在配置的整个时间间隔内没有接收到可接受的应答，因此，如果间隔为30000毫秒(30秒)，并且我们每29秒接收到一个可接受的ping应答，则认为该实例正在工作。</p><p>SDOWN不足以触发故障转移：它仅表示单个Sentinel认为Redis实例不可用。 要触发故障转移，必须达到ODOWN状态。</p><p>要从SDOWN切换到ODOWN，无需使用强大的共识算法，而只是使用一种八卦的方式：如果给定的Sentinel收到报告，称主服务器在给定的时间范围内没有从足够的Sentinels工作，则将SDOWN提升为ODOWN。 如果此确认以后丢失，则清除标志。</p><p>为了真正启动故障转移，需要使用实际多数的更严格的授权，但是在未达到ODOWN状态之前无法触发任何故障转移。</p><p><strong>ODOWN条件仅适用于master</strong>。 对于其他类型的实例，Sentinel不需要执行操作，因此副本和其他哨兵永远不会达到ODOWN状态，而只有SDOWN可以达到。</p><p>然而，SDOWN也有语义含义。例如，SDOWN状态下的副本不会被执行故障转移的标记提升。</p><h3 id=哨兵和副本自动发现>哨兵和副本自动发现<a class=anchorjs-link href=#%e5%93%a8%e5%85%b5%e5%92%8c%e5%89%af%e6%9c%ac%e8%87%aa%e5%8a%a8%e5%8f%91%e7%8e%b0></a></h3><p>哨兵与其他哨兵保持联系，以相互检查彼此的可用性，并交换信息。但是，您不需要在运行的每个哨点实例中配置其他哨点地址列表，因为哨点使用Redis实例的发布/订阅功能来发现监视相同主机和副本的其他哨点。</p><p><strong>通过将问候消息发送到名为 <code>__sentinel__:hello</code>的通道来实现此功能。</strong></p><p>同样，您无需配置附加到主数据库的副本列表，因为哨兵会通过查询Redis自动发现此列表。</p><ul><li>每个哨兵每两秒钟向每个受监视的主副本和副本Pub / Sub通道<code>__sentinel__:hello</code>发布一条消息，并通过ip，port，runid宣布其存在。</li><li>每个哨兵都订阅了每个主副本和副本的pub / Sub通道<code>__sentinel __:hello</code>，以查找未知的标记。 当检测到新的标记时，会将它们添加为该主标记的标记。</li><li>Hello消息还包括主服务器的完整当前配置。 如果接收方哨兵的给定主控配置早于接收方的配置，它将立即更新为新配置。</li><li>在将一个新的哨兵添加到一个主节点之前，哨兵总是检查是否已经有一个具有相同的runid或相同地址(ip和端口对)的岗哨。在这种情况下，所有匹配的哨兵都被移除，新的哨兵被添加。</li></ul><h3 id=在故障转移过程之外对实例进行哨兵重新配置>在故障转移过程之外对实例进行哨兵重新配置<a class=anchorjs-link href=#%e5%9c%a8%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb%e8%bf%87%e7%a8%8b%e4%b9%8b%e5%a4%96%e5%af%b9%e5%ae%9e%e4%be%8b%e8%bf%9b%e8%a1%8c%e5%93%a8%e5%85%b5%e9%87%8d%e6%96%b0%e9%85%8d%e7%bd%ae></a></h3><p>即使没有进行故障转移，Sentinels也会始终尝试在受监视实例上设置当前配置。 特别：</p><ul><li>声称是主服务器的副本(根据当前配置)将被配置为使用当前主服务器进行复制的副本。</li><li>连接到错误主服务器的副本将被重新配置为使用正确的主服务器进行复制。</li></ul><p>为了使Sentinels重新配置副本，必须在一段时间内观察到错误的配置，该时间大于用于广播新配置的时间。</p><p>这样可以防止配置过时的Sentinel（例如，因为它们刚从分区重新加入）将在接收更新之前尝试更改副本的配置。</p><ul><li>当故障转移的主机恢复可用时，它们将重新配置为副本。</li><li>一旦到达分区，在分区期间分区的副本将重新配置。</li></ul><p>关于这一部分要记住的重要教训是: <strong>Sentinel是一个系统，在该系统中，每个进程将始终尝试将最后的逻辑配置强加给受监视实例集。</strong></p><h3 id=复制节点选举和优先级>复制节点选举和优先级<a class=anchorjs-link href=#%e5%a4%8d%e5%88%b6%e8%8a%82%e7%82%b9%e9%80%89%e4%b8%be%e5%92%8c%e4%bc%98%e5%85%88%e7%ba%a7></a></h3><p>当Sentinel实例准备执行故障转移时，由于主服务器处于ODOWN状态，并且Sentinel从大多数已知的Sentinel实例获得了故障转移的授权，因此需要选择合适的副本。</p><p>副本选择过程计算下列关于副本的信息:</p><ol><li>Disconnection time from the master ： 从主服务器断开连接的时间。</li><li>Replica priority：副本优先级</li><li>Replication offset processed：已处理的复制偏移量</li><li>Run ID：运行ID</li></ol><p>从哨兵进行故障转移的角度来看，发现副本与主服务器断开连接的时间超过已配置的主服务器超时的十倍（毫秒级选项），再加上主服务器不可用的时间， 被认为不适合故障转移，因此被跳过。</p><p>用更严格的术语来说，一个副本的INFO输出表明它已与主数据库断开连接的原因不止以下几点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>(down<span style=color:#ff79c6>-</span>after<span style=color:#ff79c6>-</span>milliseconds <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>10</span>) <span style=color:#ff79c6>+</span> milliseconds_since_master_is_in_SDOWN_state
</span></span></code></pre></div><p>被认为是不可靠的，并且完全被忽略。</p><p>副本选择仅考虑通过上述测试的副本，并根据上述条件按照以下顺序对其进行排序。</p><ol><li>副本按Redis实例的redis.conf文件中配置的副本优先级排序。 优先级较低的优先。</li><li>如果优先级相同，则检查副本处理的复制偏移量，并选择从主服务器接收更多数据的副本。</li><li>如果多个副本具有相同的优先级并处理了来自主服务器的相同数据，则会执行进一步的检查，选择字典顺序较小的运行ID的副本。 拥有较低的运行ID并不是副本的真正优势，但是对于使副本选择过程更具确定性很有用，而不是选择随机副本。</li></ol><p>Redis master(可以在故障转移之后将其转换为副本)和副本都必须配置一个副本优先级(如果有机器是强首选的)。 否则，所有实例都可以使用默认的运行ID（建议的设置，因为它是通过复制偏移量选择副本的更有趣的方式）来运行。</p><p>一个Redis实例可以配置一个特殊的副本优先级为0，这样哨兵就永远不会选择它作为新的主进程。但是，哨兵仍然会重新配置以在故障转移后使用新主服务器进行复制，惟一的区别是它本身永远不会成为主服务器。</p><h2 id=算法和内部>算法和内部<a class=anchorjs-link href=#%e7%ae%97%e6%b3%95%e5%92%8c%e5%86%85%e9%83%a8></a></h2><p>在以下各节中，我们将探讨哨兵行为的详细信息。 用户不一定非要知道所有详细信息，但深入了解哨兵可能有助于更有效地部署和操作哨兵。</p><h3 id=仲裁数quorum>仲裁数（Quorum）<a class=anchorjs-link href=#%e4%bb%b2%e8%a3%81%e6%95%b0quorum></a></h3><p>前面几节说明了由Sentinel监视的每个主机都与一个已配置的仲裁相关联。它指定需要就主机的不可达性或错误情况达成一致的Sentinel进程数，以触发故障转移。</p><p>但是，在触发故障转移之后，为了实际执行故障转移，<strong>至少大多数岗哨必须授权岗哨进行故障转移</strong>。哨兵从不在只有少数哨兵存在的分区中执行故障转移。</p><p>让我们把事情讲清楚一点：</p><ul><li>Quorum：为了将主进程标记为<strong>ODOWN</strong>，需要检测错误条件的标记进程的数量。</li><li>故障转移由ODOWN状态触发。</li><li>一旦故障转移被触发，尝试进行故障转移的哨兵将被要求请求对大多数哨兵的授权(如果将quorum设置为大于多数的数字，则需要请求对大多数哨兵的授权)。</li></ul><p>差异看似微妙，但实际上很容易理解和使用。 例如，如果您有5个哨兵实例，并且仲裁数量设置为2，则一旦2个哨兵认为主服务器无法访问，就会触发故障转移，但是，两个哨兵中的一个只能在发生故障时进行故障转移至少获得3个哨兵的授权。</p><p>如果将仲裁配置为5，则所有哨兵必须就主错误情况达成一致，并且需要所有哨兵的授权才能进行故障转移。</p><p><strong>这意味着可以通过两种方式使用仲裁数来调整哨兵：</strong></p><ol><li>如果将仲裁数设置为小于我们部署的大多数哨兵的值，那么我们基本上是在使哨兵对主服务器故障更加敏感，甚至在只有少数哨兵不再能够与主服务器对话时，也会触发故障转移。</li><li>如果将仲裁数设置为大于大多数哨兵的值，则只有在有大量（大于多数）连接良好的哨兵同意主服务器宕机时，我们才使哨兵能够进行故障转移。</li></ol><h3 id=配置纪元>配置纪元<a class=anchorjs-link href=#%e9%85%8d%e7%bd%ae%e7%ba%aa%e5%85%83></a></h3><p>由于一些重要的原因，哨兵需要获得大多数人的授权才能启动故障转移：</p><p>当一个哨兵被授权时，它会得到一个唯一的主节点的配置历期。该数字将在故障转移完成后用于对新配置进行版本控制。因为大多数人都同意将一个给定的版本分配给一个给定的哨兵，所以其他哨兵将不能使用它。这意味着每个故障转移的每个配置都使用唯一的版本进行版本控制。 我们将了解为什么这是如此重要。</p><p>此外，哨兵还有一个规则:如果一个哨兵投票给另一个哨兵，让他对指定的主人进行故障转移，那么他将等待一段时间再尝试对同一个主人进行故障转移。此延迟是您可以在sentinel.conf中配置的故障转移超时。这意味着哨兵不会在同一时间尝试对同一个master进行故障转移，第一个请求被授权的会尝试，如果失败了，另一个会在一段时间后尝试，以此类推。</p><p>Redis哨兵保证了它的活性，如果大多数哨兵都能说话，那么当master倒下时，最终会有一个被授权进行故障转移。</p><p>Redis岗哨还保证了安全性，即每个哨兵都将使用不同的配置时期对同一主服务器进行故障转移。</p><h3 id=配置传播>配置传播<a class=anchorjs-link href=#%e9%85%8d%e7%bd%ae%e4%bc%a0%e6%92%ad></a></h3><p>一旦哨兵能够成功地对主站进行故障转移，它将开始广播新的配置，以便其他哨兵能够更新关于给定主站的信息。</p><p>为了使故障转移成功，它要求哨兵能够将SLAVEOF NO ONE命令发送到所选副本，并且稍后在主服务器的INFO输出中观察到切换到主服务器的情况。</p><p>此时，即使副本的重新配置正在进行中，故障转移也被认为是成功的，并且所有哨兵都必须开始报告新配置。</p><p>传播新配置的方式是我们需要使用不同版本号(配置纪元)授权每个标记故障转移的原因。</p><p>配置将在<code>__sentinel__:hello</code> Pub/Sub频道中广播</p><p>因为每个配置都有不同的版本号，所以较大的版本总是胜过较小的版本。例如，我的master的配置一开始所有的哨兵都认为master是192.168.1.50:6379。这个配置的版本是1。一段时间后，一个标记被授权使用版本2进行故障转移。如果故障转移成功，它将开始广播一个新配置，比如版本2的192.168.1.5:9000。所有其他实例将看到此配置并相应地更新其配置，因为新配置具有更大的版本。</p><p>这意味着哨兵保证了第二个活性属性:一组能够通信的哨兵都将收敛于具有更高版本号的相同配置。</p><p>基本上，如果对网络进行了分区，则每个分区都将收敛到更高的本地配置。 在没有分区的特殊情况下，只有一个分区，每个哨兵都会就配置达成一致。</p><h3 id=分区下的一致性>分区下的一致性<a class=anchorjs-link href=#%e5%88%86%e5%8c%ba%e4%b8%8b%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7></a></h3><p>Redis哨兵配置最终是一致的，因此每个分区都将收敛到可用的更高配置。 然而，在使用哨兵的真实系统中，有三种不同的玩家：</p><ul><li>Redis instances : Redis实例</li><li>Sentinel instances ：哨兵实例</li><li>Clients ： 客户端</li></ul><p>为了定义系统的行为，我们必须考虑这三个方面。</p><p>下面是一个简单的网络，其中有3个节点，每个节点运行一个Redis实例和一个哨兵实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>            <span style=color:#ff79c6>+-------------+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>            <span style=color:#ff79c6>|</span> Sentinel <span style=color:#bd93f9>1</span>  <span style=color:#ff79c6>|-----</span> Client A
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>            <span style=color:#ff79c6>|</span> Redis <span style=color:#bd93f9>1</span> (M) <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>            <span style=color:#ff79c6>+-------------+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>                    <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>                    <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#ff79c6>+-------------+</span>     <span style=color:#ff79c6>|</span>          <span style=color:#ff79c6>+------------+</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#ff79c6>|</span> Sentinel <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>|-----+--</span> <span style=color:#6272a4>// ----| Sentinel 3 |----- Client B
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:#6272a4></span><span style=color:#ff79c6>|</span> Redis <span style=color:#bd93f9>2</span> (S) <span style=color:#ff79c6>|</span>                <span style=color:#ff79c6>|</span> Redis <span style=color:#bd93f9>3</span> (M)<span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#ff79c6>+-------------+</span>                <span style=color:#ff79c6>+------------+</span>
</span></span></code></pre></div><p>在这个系统中，原始状态是Redis 3是主状态，而Redis 1和2是副本状态。旧主服务器之间发生了隔离。哨兵1和2启动了故障转移，提升哨兵1为新主人。</p><p>Sentinel属性可确保Sentinel 1和2现在具有主服务器的新配置。 但是，由于Sentinel 3位于不同的分区中，因此其配置仍旧。</p><p>我们知道，当网络分区修复后，Sentinel 3的配置将得到更新，但是，如果客户端被旧的主服务器分区，在分区期间会发生什么？</p><p>客户仍将能够写入旧版Redis 3。 当分区重新加入时，Redis 3将变成Redis 1的副本，并且分区期间写入的所有数据都将丢失。</p><p>根据您的配置，您可能希望或不希望发生这种情况：</p><ul><li>如果您使用Redis作为缓存，客户端B仍然能够向旧主服务器写入数据，即使它的数据将丢失，这可能会很方便。</li><li>如果您使用Redis作为存储，这是不好的，您需要配置系统，以部分防止这个问题。</li></ul><p>由于Redis是异步复制的，因此在此场景中无法完全防止数据丢失，但是可以使用以下Redis配置选项限制Redis 3和Redis 1之间的差异：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>min<span style=color:#ff79c6>-</span>replicas<span style=color:#ff79c6>-</span>to<span style=color:#ff79c6>-</span>write <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>min<span style=color:#ff79c6>-</span>replicas<span style=color:#ff79c6>-</span>max<span style=color:#ff79c6>-</span>lag <span style=color:#bd93f9>10</span>
</span></span></code></pre></div><p>使用上述配置（请参阅Redis发行版中的自我注释过的redis.conf示例以获取更多信息），Redis实例在充当主实例时，如果无法写入至少1个副本，将停止接受写入。 由于复制是异步的，因此实际上无法写入意味着复制副本已断开连接，或者未向我们发送异步确认超过指定的最大延迟秒数。</p><p>使用此配置，以上示例中的Redis 3将在10秒钟后不可用。 分区修复后，Sentinel 3配置将收敛到新配置，客户端B将能够获取有效配置并继续。</p><p>通常，Redis + Sentinel总体上是一个最终一致的系统，其中合并功能是最后的故障转移胜出，并且将丢弃来自旧主服务器的数据以复制当前主服务器的数据，因此总会有丢失确认写入的窗口 。 这是由于Redis异步复制以及系统“虚拟”合并功能的丢弃特性所致。 请注意，这不是Sentinel本身的限制，并且如果您使用高度一致的复制状态机来安排故障转移，则相同的属性仍将适用。 只有两种方法可以避免丢失已确认的写入：</p><ol><li>使用同步复制（以及适当的共识算法来运行复制状态机）。</li><li>使用最终一致的系统，其中可以合并相同对象的不同版本。</li></ol><p>Redis当前无法使用任何上述系统，并且目前不在开发目标之内。 但是，在Redis商店（如SoundCloud Roshi或Netflix Dynomite）之上有实现解决方案“ 2”的代理。</p><h3 id=哨兵持久状态>哨兵持久状态<a class=anchorjs-link href=#%e5%93%a8%e5%85%b5%e6%8c%81%e4%b9%85%e7%8a%b6%e6%80%81></a></h3><p>哨点状态被保存在哨点配置文件中。例如，每次接收或创建一个新的主配置(leader Sentinels)时，该配置将与配置纪元一起保存在磁盘上。这意味着停止和重新启动标记进程是安全的。</p><h3 id=tilt模式>TILT模式<a class=anchorjs-link href=#tilt%e6%a8%a1%e5%bc%8f></a></h3><p>Redis 哨兵在很大程度上取决于计算机时间：例如，为了了解实例是否可用，它会记住对PING命令最近一次成功回复的时间，并将其与当前时间进行比较以了解它的年代。</p><p>但是，如果计算机时间以意外的方式更改，或者计算机非常繁忙，或者由于某种原因导致进程阻塞，则哨兵可能会以意外的方式开始运行。</p><p>TILT模式是一种特殊的“保护”模式，当检测到某些异常现象时，哨兵可以进入该模式，这会降低系统的可靠性。 哨兵计时器中断通常每秒被调用10次，因此我们希望两次调用计时器中断之间大约会间隔100毫秒。</p><p>哨兵的作用是在上次调用计时器中断时进行注册，并将其与当前调用进行比较：如果时差为负或意外大（2秒或更长时间），则进入TILT模式（或者如果已经存在） 进入了从TILT模式退出的退出）。</p><p>在TILT模式下，哨兵将继续监视所有内容，但是：</p><ul><li>它完全停止了活动。</li><li>由于不再信任检测故障的能力，因此它开始对SENTINEL is-master-by-addr请求作出否定答复。</li></ul><p>如果30秒钟内一切正常，则退出TILT模式。</p><p>请注意，可以使用许多内核提供的单调时钟API以某种方式替换TILT模式。 但是，尚不清楚这是否是一个好的解决方案，因为当前系统避免了问题，以防进程只是被挂起或长时间未由调度程序执行。</p><p>原文链接：<a href=https://redis.io/topics/sentinel target=_blank>https://redis.io/topics/sentinel</a></p><hr style=visibility:hidden><ul class=pager><li class=previous><a href=/icorer_blog/posts/mkv-high-performance-distributed-memory-kv-opening/ data-toggle=tooltip data-placement=top title=MKV-高性能分布式内存KV-开篇>Previous<br><span>MKV-高性能分布式内存KV-开篇</span></a></li><li class=next><a href=/icorer_blog/posts/php-rdkafka-kernel-extension-related-source-code-analysis/ data-toggle=tooltip data-placement=top title="PHP-rdkafka 内核扩展相关源码分析">Next<br><span>PHP-rdkafka 内核扩展相关源码分析</span></a></li></ul><hr style=visibility:hidden></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5>FEATURED TAGS</h5><div class=tags><a href=/icorer_blog/tags/blockchain/>blockchain</a>
<a href=/icorer_blog/tags/clang/>CLang</a>
<a href=/icorer_blog/tags/cloudnative/>cloudnative</a>
<a href=/icorer_blog/tags/cmake/>Cmake</a>
<a href=/icorer_blog/tags/deca/>DeCA</a>
<a href=/icorer_blog/tags/dpki/>DPKI</a>
<a href=/icorer_blog/tags/drand/>drand</a>
<a href=/icorer_blog/tags/epoll/>epoll</a>
<a href=/icorer_blog/tags/fpga/>FPGA</a>
<a href=/icorer_blog/tags/gc/>GC</a>
<a href=/icorer_blog/tags/golang/>GoLang</a>
<a href=/icorer_blog/tags/hackathon/>Hackathon</a>
<a href=/icorer_blog/tags/http2/>HTTP2</a>
<a href=/icorer_blog/tags/http3/>HTTP3</a>
<a href=/icorer_blog/tags/icefiredb/>IceFireDB</a>
<a href=/icorer_blog/tags/k8s/>k8s</a>
<a href=/icorer_blog/tags/kafka/>kafka</a>
<a href=/icorer_blog/tags/linux/>linux</a>
<a href=/icorer_blog/tags/nginx/>Nginx</a>
<a href=/icorer_blog/tags/nosql/>NoSQL</a>
<a href=/icorer_blog/tags/php/>PHP</a>
<a href=/icorer_blog/tags/php-kernel/>php kernel</a>
<a href=/icorer_blog/tags/php%E5%86%85%E6%A0%B8/>PHP内核</a>
<a href=/icorer_blog/tags/quic/>QUIC</a>
<a href=/icorer_blog/tags/redis/>redis</a>
<a href=/icorer_blog/tags/serverless/>serverless</a>
<a href=/icorer_blog/tags/ssi/>SSI</a>
<a href=/icorer_blog/tags/unikernel/>unikernel</a>
<a href=/icorer_blog/tags/wanxiang/>Wanxiang</a>
<a href=/icorer_blog/tags/web3/>web3</a>
<a href=/icorer_blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件</a>
<a href=/icorer_blog/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a>
<a href=/icorer_blog/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/>信息安全</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/>内存数据库</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/>内存泄漏</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/>内核源码</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6/>内核研究</a>
<a href=/icorer_blog/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/>区块链</a>
<a href=/icorer_blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>垃圾回收</a>
<a href=/icorer_blog/tags/%E5%AD%98%E5%82%A8/>存储</a>
<a href=/icorer_blog/tags/%E5%AE%B9%E5%99%A8/>容器</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/>底层开发</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/>底层研究</a>
<a href=/icorer_blog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/>开源项目</a>
<a href=/icorer_blog/tags/%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97/>异构计算</a>
<a href=/icorer_blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a>
<a href=/icorer_blog/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/>性能测试</a>
<a href=/icorer_blog/tags/%E6%8A%80%E6%9C%AF%E7%A7%91%E6%99%AE/>技术科普</a>
<a href=/icorer_blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/>数据库技术</a>
<a href=/icorer_blog/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/>文章翻译</a>
<a href=/icorer_blog/tags/%E6%96%B0%E6%9E%B6%E6%9E%84/>新架构</a>
<a href=/icorer_blog/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/>时序数据库</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/>服务治理</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/>服务网格</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E9%81%A5%E6%B5%8B/>服务遥测</a>
<a href=/icorer_blog/tags/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/>测试报告</a>
<a href=/icorer_blog/tags/%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/>研究报告</a>
<a href=/icorer_blog/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/>缓存技术</a>
<a href=/icorer_blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a>
<a href=/icorer_blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/>虚拟机</a>
<a href=/icorer_blog/tags/%E8%A1%8C%E4%B8%9A%E6%8A%A5%E5%91%8A/>行业报告</a>
<a href=/icorer_blog/tags/%E8%AE%BA%E6%96%87/>论文</a>
<a href=/icorer_blog/tags/%E9%9B%B6%E4%BF%A1%E4%BB%BB/>零信任</a>
<a href=/icorer_blog/tags/%E9%AB%98%E6%80%A7%E8%83%BD/>高性能</a></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=/icorer_blog/index.xml><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/corerman1><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/gitsrc><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 笔迹-工匠之芯 2022</p></div></div></div></footer><script src=/icorer_blog/js/jquery.min.js></script>
<script src=/icorer_blog/js/bootstrap.min.js crossorigin=anonymous></script>
<script src=/icorer_blog/js/hux-blog.min.c4ea77041cd3edbfc8b2622cd887a9a5d8760a4162d14489e36d2a3fa4c90172.js></script>
<script src=/icorer_blog/js/simple-jekyll-search.min.js></script>
<script src=/icorer_blog/js/search.min.7d1445cf07369bca2715d9f63738c16c73a7a2273a95d6729bee561f7e84c6c8.js></script>
<script src=/icorer_blog/zoomjs/zoom.min.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB37D8LWFT"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VB37D8LWFT")</script></body></html>