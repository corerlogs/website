<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=icon type=image/ico sizes=16x16 href=/icorer_blog/img/favicon.ico><meta property="og:image" content="https://icorer.com/img/34047788_pepere.jpg"><title>PHP扩展开发2.2：线程安全 | 笔迹-工匠之芯</title><meta name=author content="LB"><meta name=description content="背景介绍 线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
一般来说，线程安全的函数应该为每个调用它的线程分配专门的空间，来储存需要单独保存的状态（如果需要的话），不依赖于“线程惯性”，把多个线程共享的变量正确对待（如，通知编译器该变量为“易失（volatile）”型，阻止其进行一些不恰当的优化），而且，线程安全的函数一般不应该修改全局对象。
很多C库代码（比如某些strtok的实现，它将“多次调用中需要保持不变的状态”储存在静态变量中，导致不恰当的共享）不是线程安全的，在多线程环境中调用这些函数时，要进行特别的预防措施，或者寻找别的替代方案。 更多线程安全信息请浏览维基百科：链接地址
在PHP初期，是作为单进程的CGI来运行的，所以并没有考虑线程安全问题。我们可以随意的在全局作用域中设置变量并在程序中对他进行修改、访问，内核申请的资源如果没有正确的释放，也会在CGI进程结束后自动地被清理干净。
后来，php被作为apache多进程模式下的一个模块运行，但是这仍然把php局限在一个进程里，我们设置的全局变量，只要在每个请求之前将其正确的初始化，并在每个请求之后正确的清理干净，便不会带来什么麻烦。由于对于一个进程来说，同一个时间只能处理一个请求，所以这是内核中加入了针对每个请求的内存管理功能，来防止服务器资源利用出现错误。
随着使用在多线程模式的软件系统越来越多，php内核中亟需一种新的资源管理方式，并最终在php内核中形成了一个新的抽象层：TSRM(Thread Safe Resource Management)。
线程安全与非线程安全在一个没有线程的程序中，我们往往倾向于把全局变量声明在源文件的顶部，编译器会自动的为它分配资源供我们在声明语句之下的程序逻辑中使用。（即使通过fork()出一个子进程，它也会重新申请一段内存，父子进程中的变量从此没有了任何联系）
但是在一个多线程的程序中，如果我们需要每个线程都拥有自己独立的资源的话，便需要为每个线程独立开辟出一个区域来存放它们各自的资源，在使用资源的时候，每个线程便会只在自己的那一亩三分地里找，而不会拔了别人的庄稼。
线程安全资源池（Thread-SafeDataPools）在扩展的ModuleInit里，扩展可以调用ts_allocate_id()函数来告诉 TRSM 自己需要多少资源。TRSM 接收后更新系统使用的资源，并得到一个指向刚分配的那份资源的id。
1typedef struct { 2	int sampleint; 3	char *samplestring; 4} php_sample_globals; 5int sample_globals_id; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 ts_allocate_id(&amp;sample_globals_id, 10 sizeof(php_sample_globals), 11 (ts_allocate_ctor) php_sample_globals_ctor, 12 (ts_allocate_dtor) php_sample_globals_dtor); 13 return SUCCESS; 14} 当一个请求需要访问数据段的时候，扩展从TSRM层请求当前线程的资源池，以ts_allocate_id()返回的资源ID来获取偏移量。换句话说，在代码流中，你可能会在前面所说的MINIT语句中碰到SAMPLE_G(sampleint)=5;这样的语句。在线程安全的构建下，这个语句通过一些宏扩展如下：
1(((php_sample_globals*)(*((void ***)tsrm_ls))[sample_globals_id-1])->sampleint = 5; 如果你看不懂上面的转换也不用沮丧，它已经很好的封装在PHPAPI中了，以至于许多开发者都不需要知道它怎样工作的。
当不在线程环境时因为在PHP的线程安全构建中访问全局资源涉及到在线程数据池查找对应的偏移量，这是一些额外的负载，结果就是它比对应的非线程方式（直接从编译期已经计算好的真实的全局变量地址中取出数据）慢一些。 考虑上面的例子，这一次在非线程构建下：
1typedef struct { 2 int sampleint; 3 char *samplestring; 4} php_sample_globals; 5php_sample_globals sample_globals; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 php_sample_globals_ctor(&amp;sample_globals TSRMLS_CC); 10 return SUCCESS; 11} 首先注意到的是这里并没有定义一个int型的标识去引用全局的结构定义， 只是简单的在进程的全局空间定义了一个结构体。 也就是说SAMPLE_G(sampleint) = 5;展开后就是sample_globals."><meta name=keywords content="blog,博客,工匠之芯,笔迹-工匠之芯"><meta name=twitter:card content="summary"><meta name=twitter:title content="PHP扩展开发2.2：线程安全"><meta name=twitter:description content="背景介绍 线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
一般来说，线程安全的函数应该为每个调用它的线程分配专门的空间，来储存需要单独保存的状态（如果需要的话），不依赖于“线程惯性”，把多个线程共享的变量正确对待（如，通知编译器该变量为“易失（volatile）”型，阻止其进行一些不恰当的优化），而且，线程安全的函数一般不应该修改全局对象。
很多C库代码（比如某些strtok的实现，它将“多次调用中需要保持不变的状态”储存在静态变量中，导致不恰当的共享）不是线程安全的，在多线程环境中调用这些函数时，要进行特别的预防措施，或者寻找别的替代方案。 更多线程安全信息请浏览维基百科：链接地址
在PHP初期，是作为单进程的CGI来运行的，所以并没有考虑线程安全问题。我们可以随意的在全局作用域中设置变量并在程序中对他进行修改、访问，内核申请的资源如果没有正确的释放，也会在CGI进程结束后自动地被清理干净。
后来，php被作为apache多进程模式下的一个模块运行，但是这仍然把php局限在一个进程里，我们设置的全局变量，只要在每个请求之前将其正确的初始化，并在每个请求之后正确的清理干净，便不会带来什么麻烦。由于对于一个进程来说，同一个时间只能处理一个请求，所以这是内核中加入了针对每个请求的内存管理功能，来防止服务器资源利用出现错误。
随着使用在多线程模式的软件系统越来越多，php内核中亟需一种新的资源管理方式，并最终在php内核中形成了一个新的抽象层：TSRM(Thread Safe Resource Management)。
线程安全与非线程安全在一个没有线程的程序中，我们往往倾向于把全局变量声明在源文件的顶部，编译器会自动的为它分配资源供我们在声明语句之下的程序逻辑中使用。（即使通过fork()出一个子进程，它也会重新申请一段内存，父子进程中的变量从此没有了任何联系）
但是在一个多线程的程序中，如果我们需要每个线程都拥有自己独立的资源的话，便需要为每个线程独立开辟出一个区域来存放它们各自的资源，在使用资源的时候，每个线程便会只在自己的那一亩三分地里找，而不会拔了别人的庄稼。
线程安全资源池（Thread-SafeDataPools）在扩展的ModuleInit里，扩展可以调用ts_allocate_id()函数来告诉 TRSM 自己需要多少资源。TRSM 接收后更新系统使用的资源，并得到一个指向刚分配的那份资源的id。
1typedef struct { 2	int sampleint; 3	char *samplestring; 4} php_sample_globals; 5int sample_globals_id; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 ts_allocate_id(&amp;sample_globals_id, 10 sizeof(php_sample_globals), 11 (ts_allocate_ctor) php_sample_globals_ctor, 12 (ts_allocate_dtor) php_sample_globals_dtor); 13 return SUCCESS; 14} 当一个请求需要访问数据段的时候，扩展从TSRM层请求当前线程的资源池，以ts_allocate_id()返回的资源ID来获取偏移量。换句话说，在代码流中，你可能会在前面所说的MINIT语句中碰到SAMPLE_G(sampleint)=5;这样的语句。在线程安全的构建下，这个语句通过一些宏扩展如下：
1(((php_sample_globals*)(*((void ***)tsrm_ls))[sample_globals_id-1])->sampleint = 5; 如果你看不懂上面的转换也不用沮丧，它已经很好的封装在PHPAPI中了，以至于许多开发者都不需要知道它怎样工作的。
当不在线程环境时因为在PHP的线程安全构建中访问全局资源涉及到在线程数据池查找对应的偏移量，这是一些额外的负载，结果就是它比对应的非线程方式（直接从编译期已经计算好的真实的全局变量地址中取出数据）慢一些。 考虑上面的例子，这一次在非线程构建下：
1typedef struct { 2 int sampleint; 3 char *samplestring; 4} php_sample_globals; 5php_sample_globals sample_globals; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 php_sample_globals_ctor(&amp;sample_globals TSRMLS_CC); 10 return SUCCESS; 11} 首先注意到的是这里并没有定义一个int型的标识去引用全局的结构定义， 只是简单的在进程的全局空间定义了一个结构体。 也就是说SAMPLE_G(sampleint) = 5;展开后就是sample_globals."><meta property="og:title" content="PHP扩展开发2.2：线程安全"><meta property="og:description" content="背景介绍 线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
一般来说，线程安全的函数应该为每个调用它的线程分配专门的空间，来储存需要单独保存的状态（如果需要的话），不依赖于“线程惯性”，把多个线程共享的变量正确对待（如，通知编译器该变量为“易失（volatile）”型，阻止其进行一些不恰当的优化），而且，线程安全的函数一般不应该修改全局对象。
很多C库代码（比如某些strtok的实现，它将“多次调用中需要保持不变的状态”储存在静态变量中，导致不恰当的共享）不是线程安全的，在多线程环境中调用这些函数时，要进行特别的预防措施，或者寻找别的替代方案。 更多线程安全信息请浏览维基百科：链接地址
在PHP初期，是作为单进程的CGI来运行的，所以并没有考虑线程安全问题。我们可以随意的在全局作用域中设置变量并在程序中对他进行修改、访问，内核申请的资源如果没有正确的释放，也会在CGI进程结束后自动地被清理干净。
后来，php被作为apache多进程模式下的一个模块运行，但是这仍然把php局限在一个进程里，我们设置的全局变量，只要在每个请求之前将其正确的初始化，并在每个请求之后正确的清理干净，便不会带来什么麻烦。由于对于一个进程来说，同一个时间只能处理一个请求，所以这是内核中加入了针对每个请求的内存管理功能，来防止服务器资源利用出现错误。
随着使用在多线程模式的软件系统越来越多，php内核中亟需一种新的资源管理方式，并最终在php内核中形成了一个新的抽象层：TSRM(Thread Safe Resource Management)。
线程安全与非线程安全在一个没有线程的程序中，我们往往倾向于把全局变量声明在源文件的顶部，编译器会自动的为它分配资源供我们在声明语句之下的程序逻辑中使用。（即使通过fork()出一个子进程，它也会重新申请一段内存，父子进程中的变量从此没有了任何联系）
但是在一个多线程的程序中，如果我们需要每个线程都拥有自己独立的资源的话，便需要为每个线程独立开辟出一个区域来存放它们各自的资源，在使用资源的时候，每个线程便会只在自己的那一亩三分地里找，而不会拔了别人的庄稼。
线程安全资源池（Thread-SafeDataPools）在扩展的ModuleInit里，扩展可以调用ts_allocate_id()函数来告诉 TRSM 自己需要多少资源。TRSM 接收后更新系统使用的资源，并得到一个指向刚分配的那份资源的id。
1typedef struct { 2	int sampleint; 3	char *samplestring; 4} php_sample_globals; 5int sample_globals_id; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 ts_allocate_id(&amp;sample_globals_id, 10 sizeof(php_sample_globals), 11 (ts_allocate_ctor) php_sample_globals_ctor, 12 (ts_allocate_dtor) php_sample_globals_dtor); 13 return SUCCESS; 14} 当一个请求需要访问数据段的时候，扩展从TSRM层请求当前线程的资源池，以ts_allocate_id()返回的资源ID来获取偏移量。换句话说，在代码流中，你可能会在前面所说的MINIT语句中碰到SAMPLE_G(sampleint)=5;这样的语句。在线程安全的构建下，这个语句通过一些宏扩展如下：
1(((php_sample_globals*)(*((void ***)tsrm_ls))[sample_globals_id-1])->sampleint = 5; 如果你看不懂上面的转换也不用沮丧，它已经很好的封装在PHPAPI中了，以至于许多开发者都不需要知道它怎样工作的。
当不在线程环境时因为在PHP的线程安全构建中访问全局资源涉及到在线程数据池查找对应的偏移量，这是一些额外的负载，结果就是它比对应的非线程方式（直接从编译期已经计算好的真实的全局变量地址中取出数据）慢一些。 考虑上面的例子，这一次在非线程构建下：
1typedef struct { 2 int sampleint; 3 char *samplestring; 4} php_sample_globals; 5php_sample_globals sample_globals; 6 7PHP_MINIT_FUNCTION(sample) 8{ 9 php_sample_globals_ctor(&amp;sample_globals TSRMLS_CC); 10 return SUCCESS; 11} 首先注意到的是这里并没有定义一个int型的标识去引用全局的结构定义， 只是简单的在进程的全局空间定义了一个结构体。 也就是说SAMPLE_G(sampleint) = 5;展开后就是sample_globals."><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_blog/posts/php-extension-development-2.2-thread-safety/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-07-06T17:26:18+08:00"><meta property="article:modified_time" content="2018-07-06T17:26:18+08:00"><link rel=stylesheet href=/icorer_blog/css/bootstrap.min.css crossorigin=anonymous><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/icorer_blog/sass/main.css><link rel=stylesheet href=/icorer_blog/zoomjs/zoom.min.css><script src=/icorer_blog/js/lazysizes.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/icorer_blog/apple-touch-icon.png><link rel=manifest href=/icorer_blog/site.webmanifest></head><body><nav class="navbar navbar-default navbar-custom navbar-fixed-top invert"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://icorer.com/icorer_blog/>笔迹-工匠之芯</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=https://icorer.com title=工匠之芯>工匠之芯</a></li><li><a href=https://icorer.com/icorer_about title=关于我>关于我</a></li><li><a href=https://github.com/gitsrc title=开源仓库>开源仓库</a></li><li class=search-icon><a href=javascript:void(0)><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse"),__HuxNav__={close:function(){$navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)},open:function(){$collapse.style.height="auto",$navbar.className+=" in"}};$toggle.addEventListener("click",function(){$navbar.className.indexOf("in")>0?__HuxNav__.close():__HuxNav__.open()}),document.addEventListener("click",function(e){if(e.target==$toggle)return;if(e.target.className=="icon-bar")return;__HuxNav__.close()})</script><div class=search-page><div class=search-icon-close-container><span class=search-icon-close><i class="fa fa-chevron-down"></i></span></div><div class="search-main container"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><form></form><input type=text id=search-input placeholder=内容搜索...></form><div id=search-results class=mini-post-list></div></div></div></div></div><style type=text/css>header.intro-header{position:relative;background-image:url('')}</style><header class="intro-header style-text"><div class=header-mask></div><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/icorer_blog/tags/php/ title=PHP>PHP</a>
<a class=tag href=/icorer_blog/tags/php%E5%86%85%E6%A0%B8/ title=PHP内核>PHP内核</a>
<a class=tag href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/ title=底层研究>底层研究</a></div><h1>PHP扩展开发2.2：线程安全</h1><h2 class=subheading></h2><span class=meta>Posted by LB
on Fri, Jul 6, 2018</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=背景介绍>背景介绍<a class=anchorjs-link href=#%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d></a></h1><blockquote><p>线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p></blockquote><blockquote><p>一般来说，线程安全的函数应该为每个调用它的线程分配专门的空间，来储存需要单独保存的状态（如果需要的话），不依赖于“线程惯性”，把多个线程共享的变量正确对待（如，通知编译器该变量为“易失（volatile）”型，阻止其进行一些不恰当的优化），而且，线程安全的函数一般不应该修改全局对象。</p></blockquote><blockquote><p>很多C库代码（比如某些strtok的实现，它将“多次调用中需要保持不变的状态”储存在静态变量中，导致不恰当的共享）不是线程安全的，在多线程环境中调用这些函数时，要进行特别的预防措施，或者寻找别的替代方案。
更多线程安全信息请浏览维基百科：<a href=https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8 title=链接地址 target=_blank>链接地址</a></p></blockquote><p>在PHP初期，是作为单进程的CGI来运行的，所以并没有考虑线程安全问题。我们可以随意的在全局作用域中设置变量并在程序中对他进行修改、访问，内核申请的资源如果没有正确的释放，也会在CGI进程结束后自动地被清理干净。</p><p>后来，php被作为apache多进程模式下的一个模块运行，但是这仍然把php局限在一个进程里，我们设置的全局变量，只要在每个请求之前将其正确的初始化，并在每个请求之后正确的清理干净，便不会带来什么麻烦。由于对于一个进程来说，同一个时间只能处理一个请求，所以这是内核中加入了针对每个请求的内存管理功能，来防止服务器资源利用出现错误。</p><p>随着使用在多线程模式的软件系统越来越多，php内核中亟需一种新的资源管理方式，并最终在php内核中形成了一个新的抽象层：TSRM(Thread Safe Resource Management)。</p><h1 id=线程安全与非线程安全>线程安全与非线程安全<a class=anchorjs-link href=#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e4%b8%8e%e9%9d%9e%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8></a></h1><p>在一个没有线程的程序中，我们往往倾向于把全局变量声明在源文件的顶部，编译器会自动的为它分配资源供我们在声明语句之下的程序逻辑中使用。（即使通过fork()出一个子进程，它也会重新申请一段内存，父子进程中的变量从此没有了任何联系）</p><p>但是在一个多线程的程序中，如果我们需要每个线程都拥有自己独立的资源的话，便需要为每个线程独立开辟出一个区域来存放它们各自的资源，在使用资源的时候，每个线程便会只在自己的那一亩三分地里找，而不会拔了别人的庄稼。</p><h2 id=线程安全资源池thread-safedatapools>线程安全资源池（Thread-SafeDataPools）<a class=anchorjs-link href=#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e8%b5%84%e6%ba%90%e6%b1%a0thread-safedatapools></a></h2><p>在扩展的ModuleInit里，扩展可以调用ts_allocate_id()函数来告诉 TRSM 自己需要多少资源。TRSM 接收后更新系统使用的资源，并得到一个指向刚分配的那份资源的id。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#ff79c6>typedef</span> <span style=color:#ff79c6>struct</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>	<span style=color:#8be9fd>int</span> sampleint;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>	<span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>samplestring;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>} php_sample_globals;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#8be9fd>int</span> sample_globals_id;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#50fa7b>PHP_MINIT_FUNCTION</span>(sample)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#50fa7b>ts_allocate_id</span>(<span style=color:#ff79c6>&amp;</span>sample_globals_id,
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        <span style=color:#ff79c6>sizeof</span>(php_sample_globals),
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>        (ts_allocate_ctor) php_sample_globals_ctor,
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>        (ts_allocate_dtor) php_sample_globals_dtor);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#ff79c6>return</span> SUCCESS;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>}
</span></span></code></pre></div><p>当一个请求需要访问数据段的时候，扩展从TSRM层请求当前线程的资源池，以ts_allocate_id()返回的资源ID来获取偏移量。换句话说，在代码流中，你可能会在前面所说的MINIT语句中碰到SAMPLE_G(sampleint)=5;这样的语句。在线程安全的构建下，这个语句通过一些宏扩展如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>(((php_sample_globals<span style=color:#ff79c6>*</span>)(<span style=color:#ff79c6>*</span>((<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>***</span>)tsrm_ls))[sample_globals_id<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>])<span style=color:#ff79c6>-&gt;</span>sampleint <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>5</span>;
</span></span></code></pre></div><p>如果你看不懂上面的转换也不用沮丧，它已经很好的封装在PHPAPI中了，以至于许多开发者都不需要知道它怎样工作的。</p><h2 id=当不在线程环境时>当不在线程环境时<a class=anchorjs-link href=#%e5%bd%93%e4%b8%8d%e5%9c%a8%e7%ba%bf%e7%a8%8b%e7%8e%af%e5%a2%83%e6%97%b6></a></h2><p>因为在PHP的线程安全构建中访问全局资源涉及到在线程数据池查找对应的偏移量，这是一些额外的负载，结果就是它比对应的非线程方式（直接从编译期已经计算好的真实的全局变量地址中取出数据）慢一些。 考虑上面的例子，这一次在非线程构建下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#ff79c6>typedef</span> <span style=color:#ff79c6>struct</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>    <span style=color:#8be9fd>int</span> sampleint;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>samplestring;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>} php_sample_globals;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>php_sample_globals sample_globals;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#50fa7b>PHP_MINIT_FUNCTION</span>(sample)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#50fa7b>php_sample_globals_ctor</span>(<span style=color:#ff79c6>&amp;</span>sample_globals TSRMLS_CC);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#ff79c6>return</span> SUCCESS;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>}
</span></span></code></pre></div><p>首先注意到的是这里并没有定义一个int型的标识去引用全局的结构定义， 只是简单的在进程的全局空间定义了一个结构体。 也就是说SAMPLE_G(sampleint) = 5;展开后就是sample_globals.sampleint = 5; 简单，快速，高效。 非线程构建还有进程隔离的优势，这样给定的请求碰到完全出乎意料的情况时，它也不会影响其他进程， 即便是产生段错误也不会导致整个webserver瘫痪。 实际上，Apache的MaxRequestsPerChild指令就是设计用来提升这个特性的， 它经常性的有目的性的kill掉子进程并产生新的子进程，来避免某些可能由于进程长时间运行“累积”而来的问题（比如内存泄露）。</p><h2 id=访问全局变量>访问全局变量<a class=anchorjs-link href=#%e8%ae%bf%e9%97%ae%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f></a></h2><p>在创建一个扩展时，你并不知道它最终的运行环境是否是线程安全的。幸运的是，你要使用的标准包含文件集合中已经包含了条件定义的ZTS预处理标记。当PHP因为SAPI需要或通过enable-maintainer-zts选项安装等原因以线程安全方式构建时，这个值会被自动的定义，并可以用一组#ifdef ZTS这样的指令集去测试它的值。 就像你前面看到的，只有在PHP以线程安全方式编译时，才会存在线程安全池，只有线程安全池存在时，才会真的在线程安全池中分配空间。这就是为什么前面的例子包裹在ZTS检查中的原因，非线程方式供非线程构建使用。 在本章前面PHP_MINIT_FUNCTION(myextension)的例子中，你可以看到#ifdef ZTS被用作条件调用正确的全局初始代码。对于ZTS模式它使用ts_allocate_id()弹出myextension_globals_id变量，而非ZTS模式只是直接调用myextension_globals的初始化方法。这两个变量已经在你的扩展源文件中使用Zend宏：DECLARE_MODULE_GLOBALS(myextension)声明，它将自动的处理对ZTS的测试并依赖构建的ZTS模式选择正确的方式声明。 在访问这些全局变量的时候，你需要使用前面给出的自定义宏SAMPLE_G()。</p><h2 id=即便你不需要线程也要考虑线程>即便你不需要线程也要考虑线程<a class=anchorjs-link href=#%e5%8d%b3%e4%be%bf%e4%bd%a0%e4%b8%8d%e9%9c%80%e8%a6%81%e7%ba%bf%e7%a8%8b%e4%b9%9f%e8%a6%81%e8%80%83%e8%99%91%e7%ba%bf%e7%a8%8b></a></h2><p>正常的PHP构建默认是关闭线程安全的，只有在被构建的sapi明确需要线程安全或线程安全在./configure阶段显式的打开时，才会以线程安全方式构建。 给出了全局查找的速度问题和进程隔离的缺点后，你可能会疑惑为什么明明不需要还有人故意打开它呢？这是因为，多数情况下，扩展和SAPI的开发者认为你是线程安全开关的操作者，这样做可以很大程度上确保新代码可以在所有环境中正常运行。 当线程安全启用时，一个名为tsrm_ls的特殊指针被增加到了很多的内部函数原型中。这个指针允许PHP区分不同线程的数据。回想一下本章前面ZTS模式下的SAMPLE_G()宏函数中就使用了它。没有它，正在执行的函数就不知道查找和设置哪个线程的符号表；不知道应该执行哪个脚本，引擎也完全无法跟踪它的内部寄存器。这个指针保留了线程处理的所有页面请求。 这个可选的指针参数通过下面一组定义包含到原型中。当ZTS禁用时，这些定义都被展开为空；当ZTS开启时，它们展开如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>#define TSRMLS_D     void ***tsrm_ls
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>#define TSRMLS_DC     , void ***tsrm_ls
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>#define TSRMLS_C     tsrm_ls
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6>#define TSRMLS_CC     , tsrm_ls
</span></span></span></code></pre></div><p>非ZTS构建对下面的代码看到的是两个参数：int, char *。在ZTS构建下，原型则包含三个参数：int, char *, void*** 。当你的程序调用这个函数时，只有在ZTS启用时才需要传递第三个参数。下面代码的第二行展示了宏的展开：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>php_myext_action</span>(<span style=color:#8be9fd>int</span> action_id, <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>message TSRMLS_DC);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#50fa7b>php_myext_action</span>(<span style=color:#bd93f9>42</span>, <span style=color:#f1fa8c>&#34;The meaning of life&#34;</span> TSRMLS_CC);
</span></span></code></pre></div><p>通过在函数调用中包含这个特殊的变量，php_myext_action就可以使用tsrm_ls的值和MYEXT_G()宏函数一起访问它的线程特有全局数据。在非ZTS构建上，tsrm_ls将不可用，但是这是ok的，因为此时MYEXT_G()宏函数以及其他类似的宏都不会使用它。 现在考虑，你在一个新的扩展上工作，并且有下面的函数，它可以在你本地使用CLI SAPI的构建上正常工作，并且即便使用apache 1的apxs SAPI编译也可以正常工作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>php_myext_isset</span>(<span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>varname, <span style=color:#8be9fd>int</span> varname_len)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    zval <span style=color:#ff79c6>**</span>dummy;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#ff79c6>if</span> (<span style=color:#50fa7b>zend_hash_find</span>(<span style=color:#50fa7b>EG</span>(active_symbol_table),
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        varname, varname_len <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>        (<span style=color:#8be9fd>void</span><span style=color:#ff79c6>**</span>)<span style=color:#ff79c6>&amp;</span>dummy) <span style=color:#ff79c6>==</span> SUCCESS) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>        <span style=color:#6272a4>/* Variable exists */</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>        <span style=color:#6272a4>/* Undefined variable */</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>}
</span></span></code></pre></div><p>所有的一切看起来都工作正常，你打包这个扩展发送给他人构建并运行在生产服务器上。让你气馁的是，对方报告扩展编译失败。 事实上它们使用了Apache 2.0的线程模式，因此它们的php构建启用了ZTS。当编译期碰到你使用的EG()宏函数时，它尝试在本地空间查找tsrm_ls没有找到，因为你并没有定义它并且没有在你的函数中传递。 修复这个问题非常简单；只需要在php_myext_isset()的定义上增加TSRMLS_DC，并在每行调用它的地方增加TSRMLS_CC。不幸的是，现在对方已经有点不信任你的扩展质量了，这样就会推迟你的演示周期。这种问题越早解决越好。 现在有了enable-maintainer-zts指令。通过在./configure时增加该指令来构建php，你的构建将自动的包含ZTS，哪怕你当前的SAPI（比如CLI）不需要它。打开这个开关，你可以避免这些常见的不应该出现的错误。 注意：在PHP4中，enable-maintainer-zts标记等价的名字是enable-experimental-zts；请确认使用你的php版本对应的正确标记。</p><p>##寻回丢失的tsrm_ls
有时，我们需要在一个函数中使用tsrm_ls指针，但却不能传递它。通常这是因为你的扩展作为某个使用回调的库的接口，它并没有提供返回抽象指针的地方。考虑下面的代码片段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>php_myext_event_callback</span>(<span style=color:#8be9fd>int</span> eventtype, <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>message)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    zval <span style=color:#ff79c6>*</span>event;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#6272a4>/* $event = array(&#39;event&#39;=&gt;$eventtype,
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#6272a4>                    &#39;message&#39;=&gt;$message) */</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#50fa7b>MAKE_STD_ZVAL</span>(event);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#50fa7b>array_init</span>(event);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#50fa7b>add_assoc_long</span>(event, <span style=color:#f1fa8c>&#34;type&#34;</span>, eventtype);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#50fa7b>add_assoc_string</span>(event, <span style=color:#f1fa8c>&#34;message&#34;</span>, message, <span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#6272a4>/* $eventlog[] = $event; */</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    <span style=color:#50fa7b>add_next_index_zval</span>(<span style=color:#50fa7b>EXT_G</span>(eventlog), event);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:#50fa7b>PHP_FUNCTION</span>(myext_startloop)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    <span style=color:#6272a4>/* The eventlib_loopme() function,
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span><span style=color:#6272a4>     * exported by an external library,
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span><span style=color:#6272a4>     * waits for an event to happen,
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span><span style=color:#6272a4>     * then dispatches it to the
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span><span style=color:#6272a4>     * callback handler specified.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>    <span style=color:#50fa7b>eventlib_loopme</span>(php_myext_event_callback);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>}
</span></span></code></pre></div><p>虽然你可能不完全理解这段代码，但你应该注意到了回调函数中使用了EXT_G()宏函数，我们知道在线程安全构建下它需要tsrm_ls指针。修改函数原型并不好也不应该这样做，因为外部的库并不知道php的线程安全模型。那这种情况下怎样让tsrm_ls可用呢？ 解决方案是前面提到的名为TSRMLS_FETCH()的Zend宏函数。将它放到代码片段的顶部，这个宏将执行给予当前线程上下文的查找，并定义本地的tsrm_ls指针拷贝。 这个宏可以在任何地方使用并且不用通过函数调用传递tsrm_ls，尽管这看起来很诱人，但是，要注意到这一点：TSRMLS_FETCH调用需要一定的处理时间。这在单次迭代中并不明显，但是随着你的线程数增多，随着你调用TSRMLS_FETCH()的点的增多，你的扩展就会显现出这个瓶颈。因此，请谨慎的使用它。 注意：为了和c++编译器兼容，请确保将TSRMLS_FETCH()和所有变量定义放在给定块作用域的顶部（任何其他语句之前）。因为TSRMLS_FETCH()宏自身有多种不同的解析方式，因此最好将它作为变量定义的最后一行。</p><hr style=visibility:hidden><ul class=pager><li class=previous><a href=/icorer_blog/posts/php-extension-development-2.1-php-lifecycle/ data-toggle=tooltip data-placement=top title=PHP扩展开发2.1：PHP生命周期>Previous<br><span>PHP扩展开发2.1：PHP生命周期</span></a></li><li class=next><a href=/icorer_blog/posts/source-code-reading-php-tsrm-thread-safety-manager/ data-toggle=tooltip data-placement=top title="源码阅读：PHP TSRM 线程安全管理器">Next<br><span>源码阅读：PHP TSRM 线程安全管理器</span></a></li></ul><hr style=visibility:hidden></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5>FEATURED TAGS</h5><div class=tags><a href=/icorer_blog/tags/blockchain/>blockchain</a>
<a href=/icorer_blog/tags/clang/>CLang</a>
<a href=/icorer_blog/tags/cloudnative/>cloudnative</a>
<a href=/icorer_blog/tags/cmake/>Cmake</a>
<a href=/icorer_blog/tags/cometbft/>CometBFT</a>
<a href=/icorer_blog/tags/cosmos/>cosmos</a>
<a href=/icorer_blog/tags/dcdn/>DCDN</a>
<a href=/icorer_blog/tags/deca/>DeCA</a>
<a href=/icorer_blog/tags/depin/>DePIN</a>
<a href=/icorer_blog/tags/dpki/>DPKI</a>
<a href=/icorer_blog/tags/drand/>drand</a>
<a href=/icorer_blog/tags/eip/>EIP</a>
<a href=/icorer_blog/tags/epoll/>epoll</a>
<a href=/icorer_blog/tags/ethereum/>Ethereum</a>
<a href=/icorer_blog/tags/fpga/>FPGA</a>
<a href=/icorer_blog/tags/gc/>GC</a>
<a href=/icorer_blog/tags/golang/>GoLang</a>
<a href=/icorer_blog/tags/hackathon/>Hackathon</a>
<a href=/icorer_blog/tags/http2/>HTTP2</a>
<a href=/icorer_blog/tags/http3/>HTTP3</a>
<a href=/icorer_blog/tags/icefiredb/>IceFireDB</a>
<a href=/icorer_blog/tags/k8s/>k8s</a>
<a href=/icorer_blog/tags/kafka/>kafka</a>
<a href=/icorer_blog/tags/layer2/>Layer2</a>
<a href=/icorer_blog/tags/linux/>linux</a>
<a href=/icorer_blog/tags/nginx/>Nginx</a>
<a href=/icorer_blog/tags/nosql/>NoSQL</a>
<a href=/icorer_blog/tags/php/>PHP</a>
<a href=/icorer_blog/tags/php-kernel/>php kernel</a>
<a href=/icorer_blog/tags/php%E5%86%85%E6%A0%B8/>PHP内核</a>
<a href=/icorer_blog/tags/quic/>QUIC</a>
<a href=/icorer_blog/tags/redis/>redis</a>
<a href=/icorer_blog/tags/sbt/>SBT</a>
<a href=/icorer_blog/tags/serverless/>serverless</a>
<a href=/icorer_blog/tags/ssi/>SSI</a>
<a href=/icorer_blog/tags/tendermint/>Tendermint</a>
<a href=/icorer_blog/tags/unikernel/>unikernel</a>
<a href=/icorer_blog/tags/wanxiang/>Wanxiang</a>
<a href=/icorer_blog/tags/web3/>web3</a>
<a href=/icorer_blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件</a>
<a href=/icorer_blog/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a>
<a href=/icorer_blog/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/>以太坊</a>
<a href=/icorer_blog/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/>信息安全</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/>内存数据库</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/>内存泄漏</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/>内核源码</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6/>内核研究</a>
<a href=/icorer_blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a>
<a href=/icorer_blog/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/>区块链</a>
<a href=/icorer_blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>垃圾回收</a>
<a href=/icorer_blog/tags/%E5%AD%98%E5%82%A8/>存储</a>
<a href=/icorer_blog/tags/%E5%AE%B9%E5%99%A8/>容器</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/>底层开发</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/>底层研究</a>
<a href=/icorer_blog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/>开源项目</a>
<a href=/icorer_blog/tags/%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97/>异构计算</a>
<a href=/icorer_blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a>
<a href=/icorer_blog/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/>性能测试</a>
<a href=/icorer_blog/tags/%E6%8A%80%E6%9C%AF%E7%A7%91%E6%99%AE/>技术科普</a>
<a href=/icorer_blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
<a href=/icorer_blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/>数据库技术</a>
<a href=/icorer_blog/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/>文章翻译</a>
<a href=/icorer_blog/tags/%E6%96%B0%E6%9E%B6%E6%9E%84/>新架构</a>
<a href=/icorer_blog/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/>时序数据库</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/>服务治理</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/>服务网格</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E9%81%A5%E6%B5%8B/>服务遥测</a>
<a href=/icorer_blog/tags/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/>测试报告</a>
<a href=/icorer_blog/tags/%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/>研究报告</a>
<a href=/icorer_blog/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/>缓存技术</a>
<a href=/icorer_blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a>
<a href=/icorer_blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/>虚拟机</a>
<a href=/icorer_blog/tags/%E8%A1%8C%E4%B8%9A%E6%8A%A5%E5%91%8A/>行业报告</a>
<a href=/icorer_blog/tags/%E8%AE%BA%E6%96%87/>论文</a>
<a href=/icorer_blog/tags/%E8%B7%A8%E9%93%BE/>跨链</a>
<a href=/icorer_blog/tags/%E9%9B%B6%E4%BF%A1%E4%BB%BB/>零信任</a>
<a href=/icorer_blog/tags/%E9%AB%98%E6%80%A7%E8%83%BD/>高性能</a></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=/icorer_blog/index.xml><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/lb_icefirelabs><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/gitsrc><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 笔迹-工匠之芯 2023</p></div></div></div></footer><script src=/icorer_blog/js/jquery.min.js></script>
<script src=/icorer_blog/js/bootstrap.min.js crossorigin=anonymous></script>
<script src=/icorer_blog/js/hux-blog.min.c4ea77041cd3edbfc8b2622cd887a9a5d8760a4162d14489e36d2a3fa4c90172.js></script>
<script src=/icorer_blog/js/simple-jekyll-search.min.js></script>
<script src=/icorer_blog/js/search.min.7d1445cf07369bca2715d9f63738c16c73a7a2273a95d6729bee561f7e84c6c8.js></script>
<script src=/icorer_blog/zoomjs/zoom.min.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB37D8LWFT"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VB37D8LWFT")</script></body></html>