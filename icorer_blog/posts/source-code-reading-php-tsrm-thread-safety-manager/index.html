<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=icon type=image/ico sizes=16x16 href=/icorer_blog/img/favicon.ico><meta property="og:image" content="https://res.cloudinary.com/malloc/image/upload/v1669271757/icorer.com/34047788_pepere.jpg"><title>源码阅读：PHP TSRM 线程安全管理器 | 笔迹-工匠之芯</title><meta name=author content="LB"><meta name=description content="TSRM 简介在查看php源代码或开发php扩展的时候，会出现大量 TSRMLS_ 宏字样在函数参数的位置，这些宏就是Zend为线程安全机制所提供的（Zend Thread Safety，简称ZTS）用于保证线程的安全 , 是防止多线程环境下以模块的形式加载并执行PHP解释器，导致内部一些公共资源读取错误，而提供的一种解决方法。
什么时候需要用 TSRM只要服务器是多线程环境并且PHP以模块的形式提供，那么就需要TSRM启用，例如apache下的 worker 模式(多进程多线程)环境，这种情况就必须要使用线程安全版本的PHP，也就是要启用TSRM , 在Linux下是编译PHP的时候指定是否开启TSRM、windows下是提供线程安全版本和非线程安全版本的PHP。
PHP 如何实现 TSRM正常多线程环境下操作公共的资源都是加上互斥锁，而PHP没有选择加锁，因为加锁可能多少会有些性能损耗，PHP的解决方法是为每一个线程都copy一份当前PHP内核所有的公共资源过来，每个线程指向自己的公共资源区，互不影响，各操作各的公共资源。
公共资源是什么就是各种各样的 struct 结构体 定义。
#TSRM数据结构
tsrm_tls_entry结构体tsrm_tls_entry 线程结构体、每个线程都有一份该结构体。
1typedef struct _tsrm_tls_entry tsrm_tls_entry; 2struct _tsrm_tls_entry { 3 void **storage; 4 int count; 5 THREAD_T thread_id; 6 tsrm_tls_entry *next; 7} 8static tsrm_tls_entry **tsrm_tls_table = NULL //线程指针表头指针 9static int tsrm_tls_table_size; //当前线程结构体数量 ###字段说明
void **storage ：资源指针、就是指向自己的公共资源内存区 int count : 资源数、就是 PHP内核 + 扩展模块 共注册了多少公共资源 THREAD_T thread_id ： 线程id tsrm_tls_entry *next：指向下一个线程指针，因为当前每一个线程指针都存在一个线程指针表里（类似于hash表），这个next可以理解成是hash冲突链式解决法."><meta name=keywords content="blog,博客,工匠之芯,笔迹-工匠之芯"><meta name=twitter:card content="summary"><meta name=twitter:title content="源码阅读：PHP TSRM 线程安全管理器"><meta name=twitter:description content="TSRM 简介在查看php源代码或开发php扩展的时候，会出现大量 TSRMLS_ 宏字样在函数参数的位置，这些宏就是Zend为线程安全机制所提供的（Zend Thread Safety，简称ZTS）用于保证线程的安全 , 是防止多线程环境下以模块的形式加载并执行PHP解释器，导致内部一些公共资源读取错误，而提供的一种解决方法。
什么时候需要用 TSRM只要服务器是多线程环境并且PHP以模块的形式提供，那么就需要TSRM启用，例如apache下的 worker 模式(多进程多线程)环境，这种情况就必须要使用线程安全版本的PHP，也就是要启用TSRM , 在Linux下是编译PHP的时候指定是否开启TSRM、windows下是提供线程安全版本和非线程安全版本的PHP。
PHP 如何实现 TSRM正常多线程环境下操作公共的资源都是加上互斥锁，而PHP没有选择加锁，因为加锁可能多少会有些性能损耗，PHP的解决方法是为每一个线程都copy一份当前PHP内核所有的公共资源过来，每个线程指向自己的公共资源区，互不影响，各操作各的公共资源。
公共资源是什么就是各种各样的 struct 结构体 定义。
#TSRM数据结构
tsrm_tls_entry结构体tsrm_tls_entry 线程结构体、每个线程都有一份该结构体。
1typedef struct _tsrm_tls_entry tsrm_tls_entry; 2struct _tsrm_tls_entry { 3 void **storage; 4 int count; 5 THREAD_T thread_id; 6 tsrm_tls_entry *next; 7} 8static tsrm_tls_entry **tsrm_tls_table = NULL //线程指针表头指针 9static int tsrm_tls_table_size; //当前线程结构体数量 ###字段说明
void **storage ：资源指针、就是指向自己的公共资源内存区 int count : 资源数、就是 PHP内核 + 扩展模块 共注册了多少公共资源 THREAD_T thread_id ： 线程id tsrm_tls_entry *next：指向下一个线程指针，因为当前每一个线程指针都存在一个线程指针表里（类似于hash表），这个next可以理解成是hash冲突链式解决法."><meta property="og:title" content="源码阅读：PHP TSRM 线程安全管理器"><meta property="og:description" content="TSRM 简介在查看php源代码或开发php扩展的时候，会出现大量 TSRMLS_ 宏字样在函数参数的位置，这些宏就是Zend为线程安全机制所提供的（Zend Thread Safety，简称ZTS）用于保证线程的安全 , 是防止多线程环境下以模块的形式加载并执行PHP解释器，导致内部一些公共资源读取错误，而提供的一种解决方法。
什么时候需要用 TSRM只要服务器是多线程环境并且PHP以模块的形式提供，那么就需要TSRM启用，例如apache下的 worker 模式(多进程多线程)环境，这种情况就必须要使用线程安全版本的PHP，也就是要启用TSRM , 在Linux下是编译PHP的时候指定是否开启TSRM、windows下是提供线程安全版本和非线程安全版本的PHP。
PHP 如何实现 TSRM正常多线程环境下操作公共的资源都是加上互斥锁，而PHP没有选择加锁，因为加锁可能多少会有些性能损耗，PHP的解决方法是为每一个线程都copy一份当前PHP内核所有的公共资源过来，每个线程指向自己的公共资源区，互不影响，各操作各的公共资源。
公共资源是什么就是各种各样的 struct 结构体 定义。
#TSRM数据结构
tsrm_tls_entry结构体tsrm_tls_entry 线程结构体、每个线程都有一份该结构体。
1typedef struct _tsrm_tls_entry tsrm_tls_entry; 2struct _tsrm_tls_entry { 3 void **storage; 4 int count; 5 THREAD_T thread_id; 6 tsrm_tls_entry *next; 7} 8static tsrm_tls_entry **tsrm_tls_table = NULL //线程指针表头指针 9static int tsrm_tls_table_size; //当前线程结构体数量 ###字段说明
void **storage ：资源指针、就是指向自己的公共资源内存区 int count : 资源数、就是 PHP内核 + 扩展模块 共注册了多少公共资源 THREAD_T thread_id ： 线程id tsrm_tls_entry *next：指向下一个线程指针，因为当前每一个线程指针都存在一个线程指针表里（类似于hash表），这个next可以理解成是hash冲突链式解决法."><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_blog/posts/source-code-reading-php-tsrm-thread-safety-manager/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-07-08T23:49:18+08:00"><meta property="article:modified_time" content="2018-07-08T23:49:18+08:00"><link rel=stylesheet href=/icorer_blog/css/bootstrap.min.css crossorigin=anonymous><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/icorer_blog/sass/main.css><link rel=stylesheet href=/icorer_blog/zoomjs/zoom.min.css><script src=/icorer_blog/js/lazysizes.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/icorer_blog/apple-touch-icon.png><link rel=manifest href=/icorer_blog/site.webmanifest></head><body><nav class="navbar navbar-default navbar-custom navbar-fixed-top invert"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://icorer.com/icorer_blog/>笔迹-工匠之芯</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=https://icorer.com title=工匠之芯>工匠之芯</a></li><li><a href=https://icorer.com/icorer_about title=关于我>关于我</a></li><li><a href=https://github.com/gitsrc title=开源仓库>开源仓库</a></li><li class=search-icon><a href=javascript:void(0)><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse"),__HuxNav__={close:function(){$navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)},open:function(){$collapse.style.height="auto",$navbar.className+=" in"}};$toggle.addEventListener("click",function(){$navbar.className.indexOf("in")>0?__HuxNav__.close():__HuxNav__.open()}),document.addEventListener("click",function(e){if(e.target==$toggle)return;if(e.target.className=="icon-bar")return;__HuxNav__.close()})</script><div class=search-page><div class=search-icon-close-container><span class=search-icon-close><i class="fa fa-chevron-down"></i></span></div><div class="search-main container"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><form></form><input type=text id=search-input placeholder=内容搜索...></form><div id=search-results class=mini-post-list></div></div></div></div></div><style type=text/css>header.intro-header{position:relative;background-image:url('')}</style><header class="intro-header style-text"><div class=header-mask></div><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/icorer_blog/tags/php/ title=PHP>PHP</a>
<a class=tag href=/icorer_blog/tags/php%E5%86%85%E6%A0%B8/ title=PHP内核>PHP内核</a>
<a class=tag href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/ title=底层研究>底层研究</a></div><h1>源码阅读：PHP TSRM 线程安全管理器</h1><h2 class=subheading></h2><span class=meta>Posted by LB
on Sun, Jul 8, 2018</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=tsrm-简介>TSRM 简介<a class=anchorjs-link href=#tsrm-%e7%ae%80%e4%bb%8b></a></h1><p>在查看php源代码或开发php扩展的时候，会出现大量 TSRMLS_ 宏字样在函数参数的位置，这些宏就是Zend为线程安全机制所提供的（Zend Thread Safety，简称ZTS）用于保证线程的安全 , 是防止多线程环境下以模块的形式加载并执行PHP解释器，导致内部一些公共资源读取错误，而提供的一种解决方法。</p><h1 id=什么时候需要用-tsrm>什么时候需要用 TSRM<a class=anchorjs-link href=#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%9c%80%e8%a6%81%e7%94%a8-tsrm></a></h1><p>只要服务器是多线程环境并且PHP以模块的形式提供，那么就需要TSRM启用，例如apache下的 worker 模式(多进程多线程)环境，这种情况就必须要使用线程安全版本的PHP，也就是要启用TSRM , 在Linux下是编译PHP的时候指定是否开启TSRM、windows下是提供线程安全版本和非线程安全版本的PHP。</p><h1 id=php-如何实现-tsrm>PHP 如何实现 TSRM<a class=anchorjs-link href=#php-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-tsrm></a></h1><p>正常多线程环境下操作公共的资源都是加上互斥锁，而PHP没有选择加锁，因为加锁可能多少会有些性能损耗，PHP的解决方法是为每一个线程都copy一份当前PHP内核所有的公共资源过来，每个线程指向自己的公共资源区，互不影响，各操作各的公共资源。</p><h1 id=公共资源是什么>公共资源是什么<a class=anchorjs-link href=#%e5%85%ac%e5%85%b1%e8%b5%84%e6%ba%90%e6%98%af%e4%bb%80%e4%b9%88></a></h1><p>就是各种各样的 struct 结构体 定义。</p><p>#TSRM数据结构</p><h2 id=tsrm_tls_entry结构体>tsrm_tls_entry结构体<a class=anchorjs-link href=#tsrm_tls_entry%e7%bb%93%e6%9e%84%e4%bd%93></a></h2><p>tsrm_tls_entry 线程结构体、每个线程都有一份该结构体。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>typedef</span> <span style=color:#ff79c6>struct</span> _tsrm_tls_entry tsrm_tls_entry;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>struct</span> _tsrm_tls_entry {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>**</span>storage;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    <span style=color:#8be9fd>int</span> count;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>    THREAD_T thread_id;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>    tsrm_tls_entry <span style=color:#ff79c6>*</span>next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span><span style=color:#ff79c6>static</span> tsrm_tls_entry   <span style=color:#ff79c6>**</span>tsrm_tls_table <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>NULL</span> <span style=color:#6272a4>//线程指针表头指针
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span><span><span style=color:#6272a4></span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span>  tsrm_tls_table_size;  <span style=color:#6272a4>//当前线程结构体数量
</span></span></span></code></pre></div><p>###字段说明</p><ol><li>void **storage ：资源指针、就是指向自己的公共资源内存区</li><li>int count : 资源数、就是 PHP内核 + 扩展模块 共注册了多少公共资源</li><li>THREAD_T thread_id ： 线程id</li><li>tsrm_tls_entry *next：指向下一个线程指针，因为当前每一个线程指针都存在一个线程指针表里（类似于hash表），这个next可以理解成是hash冲突链式解决法.</li></ol><h2 id=tsrm_resource_type结构体>tsrm_resource_type结构体<a class=anchorjs-link href=#tsrm_resource_type%e7%bb%93%e6%9e%84%e4%bd%93></a></h2><p>tsrm_resource_type 公共资源类型结构体、注册了多少公共资源就有多少个该结构体</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>typedef</span> <span style=color:#ff79c6>struct</span> {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#8be9fd>size_t</span> size;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    ts_allocate_ctor ctor;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    ts_allocate_dtor dtor;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>    <span style=color:#8be9fd>int</span> done; 
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>} tsrm_resource_type;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span><span style=color:#ff79c6>static</span> tsrm_resource_type   <span style=color:#ff79c6>*</span>resource_types_table<span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>NULL</span>;  <span style=color:#6272a4>//公共资源类型表头指针
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span><span><span style=color:#6272a4></span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span>  resource_types_table_size; <span style=color:#6272a4>//当前公共资源类型数量
</span></span></span></code></pre></div><h3 id=字段说明>字段说明<a class=anchorjs-link href=#%e5%ad%97%e6%ae%b5%e8%af%b4%e6%98%8e></a></h3><ol><li>size_t size : 资源大小</li><li>ts_allocate_ctor ctor: 构造函数指针、在给每一个线程创建该资源的时候会调用一下当前ctor指针</li><li>ts_allocate_dtor dtor : 析构函数指针、释放该资源的时候会调用一下当前dtor指针</li><li>int done : 资源是否已经销毁 0:正常 1:已销毁</li></ol><h2 id=全局资源id>全局资源id<a class=anchorjs-link href=#%e5%85%a8%e5%b1%80%e8%b5%84%e6%ba%90id></a></h2><p>typedef int ts_rsrc_id;
static ts_rsrc_id id_count;</p><h3 id=什么是全局资源id>什么是全局资源id<a class=anchorjs-link href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%85%a8%e5%b1%80%e8%b5%84%e6%ba%90id></a></h3><p>TSRM 在注册公共资源的时候，会给每一个资源都生成一个唯一id，以后获取该资源时需指定对应的资源id。</p><h3 id=为什么需要全局资源id>为什么需要全局资源id<a class=anchorjs-link href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%85%a8%e5%b1%80%e8%b5%84%e6%ba%90id></a></h3><p>因为我们每个线程都会把当前注册的所有公共资源全部copy一份过来，也就是一个malloc()一个大数组，这个资源id就是该数组的索引，也就是要想获取对应的资源，需指定对应资源的id。</p><p>通熟易懂的说:
因为TSRM就是让每一个线程都指向自己的这一堆公共资源(数组)，而想在这这一堆公共资源找到你想要的资源就要通过对应的资源id才可以，如果不是这种线程安全版本的，那就不会把这些公共资源都聚合到一堆，直接通过对应的名字获取就好了。</p><h1 id=大概执行流程>大概执行流程<a class=anchorjs-link href=#%e5%a4%a7%e6%a6%82%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b></a></h1><ol><li>内核初始化时 初始化TSRM 、注册内核涉及到的公共资源、注册外部扩展涉及到的公共资源。</li><li>对应的线程调用PHP解释器函数入口位置，初始化当前线程的 公共资源数据。</li><li>需要那个公共资源就通过对应的资源id获取即可。</li></ol><h1 id=tsrm初始化结构图>TSRM初始化结构图<a class=anchorjs-link href=#tsrm%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84%e5%9b%be></a></h1><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2018/07/1791952555.png data-action=zoom alt class=lazyload></a></figure></p><h1 id=tsrm源码分析>TSRM源码分析<a class=anchorjs-link href=#tsrm%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90></a></h1><h2 id=tsrm源文件路径>TSRM源文件路径<a class=anchorjs-link href=#tsrm%e6%ba%90%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84></a></h2><p>/php-5.3.27/TSRM/TSRM.c
/php-5.3.27/TSRM/TSRM.h</p><h2 id=tsrm涉及到主要的函数>TSRM涉及到主要的函数<a class=anchorjs-link href=#tsrm%e6%b6%89%e5%8f%8a%e5%88%b0%e4%b8%bb%e8%a6%81%e7%9a%84%e5%87%bd%e6%95%b0></a></h2><p>初始化tsrm
tsrm_startup()</p><p>注册公共资源
ts_allocate_id()</p><p>获取、注册所有公共资源，不存在则初始化，返回 &storage 指针
#define TSRMLS_FETCH() void ***tsrm_ls = (void ***) ts_resource_ex(0, NULL)</p><p>通过指定资源id获取对应的资源
#define ts_resource(id) ts_resource_ex(id, NULL)</p><p>初始化当前线程，并copy已有的公共资源数据到storage指针
allocate_new_resource()</p><h2 id=tsrm-一些常见的宏定义>TSRM 一些常见的宏定义<a class=anchorjs-link href=#tsrm-%e4%b8%80%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e5%ae%8f%e5%ae%9a%e4%b9%89></a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#ff79c6>#ifdef ZTS
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#ff79c6>#define TSRMLS_D void ***tsrm_ls
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#ff79c6>#define TSRMLS_DC , TSRMLS_D
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#ff79c6>#define TSRMLS_C tsrm_ls
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#ff79c6>#define TSRMLS_CC , TSRMLS_C
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#ff79c6>#else
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#ff79c6>#define TSRMLS_D void
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#ff79c6>#define TSRMLS_DC
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:#ff79c6>#define TSRMLS_C
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#ff79c6>#define TSRMLS_CC
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#ff79c6>#endif
</span></span></span></code></pre></div><p>可以看到如果开启了TSRM则ZTS为真，那么这组TSRM宏就会被定义，常在扩展里面看到的函数参数列表的这些宏，就会被替换成void ***tsrm_ls 指针，实际上就是当前的线程调用该函数把该线程的公共资源区地址&storage**传递进去，以保证函数内部执行流程准确的获取对应线程的公共资源。</p><h2 id=tsrm-大概的调用函数方式>TSRM 大概的调用函数方式<a class=anchorjs-link href=#tsrm-%e5%a4%a7%e6%a6%82%e7%9a%84%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0%e6%96%b9%e5%bc%8f></a></h2><p>调用
TSRMLS_FETCH() 替换 void ***tsrm_ls</p><p>执行
-> test(int a TSRMLS_CC) -> test_1(int b TSRMLS_CC)</p><p>替换
-> test(int a ,tsrm_ls) -> test_1(int b ,tsrm_ls)</p><h2 id=tsrm-如何释放>TSRM 如何释放<a class=anchorjs-link href=#tsrm-%e5%a6%82%e4%bd%95%e9%87%8a%e6%94%be></a></h2><p>上面说了apache的worker模式 多进程多线程，就是一个进程开多个线程调用PHP解释器，当每个线程结束的时候并不会马上把当前线程创建的资源数据销毁掉（因为有可能该线程又会马上被使用到，就不用再重新初始化该线程对应所有的公共资源数据了, 直接就可以使用），而是等进程要结束的时候，才会遍历所有线程，释放所有的线程以及对应的资源数据。</p><h2 id=源代码注释>源代码注释<a class=anchorjs-link href=#%e6%ba%90%e4%bb%a3%e7%a0%81%e6%b3%a8%e9%87%8a></a></h2><h3 id=1-tsrm_startup-函数说明>1. tsrm_startup 函数说明<a class=anchorjs-link href=#1-tsrm_startup-%e5%87%bd%e6%95%b0%e8%af%b4%e6%98%8e></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>TSRM_API <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>tsrm_startup</span>(<span style=color:#8be9fd>int</span> expected_threads, <span style=color:#8be9fd>int</span> expected_resources, <span style=color:#8be9fd>int</span> debug_level, <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>debug_filename)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#6272a4>//省略...
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#6272a4></span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#6272a4>//默认线程数
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#6272a4></span>    tsrm_tls_table_size <span style=color:#ff79c6>=</span> expected_threads;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#6272a4>//创建tsrm_tls_entry指针数组
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#6272a4></span>    tsrm_tls_table <span style=color:#ff79c6>=</span> (tsrm_tls_entry <span style=color:#ff79c6>**</span>) <span style=color:#50fa7b>calloc</span>(tsrm_tls_table_size, <span style=color:#ff79c6>sizeof</span>(tsrm_tls_entry <span style=color:#ff79c6>*</span>));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#6272a4>//省略...
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#6272a4></span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#6272a4>//全局资源唯一ID初始化
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:#6272a4></span>    id_count<span style=color:#ff79c6>=</span><span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#6272a4>//默认资源类型数
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span><span style=color:#6272a4></span>    resource_types_table_size <span style=color:#ff79c6>=</span> expected_resources;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    <span style=color:#6272a4>//省略...
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span><span style=color:#6272a4></span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    <span style=color:#6272a4>//创建tsrm_resource_type结构体数组
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span><span style=color:#6272a4></span>    resource_types_table <span style=color:#ff79c6>=</span> (tsrm_resource_type <span style=color:#ff79c6>*</span>) <span style=color:#50fa7b>calloc</span>(resource_types_table_size, <span style=color:#ff79c6>sizeof</span>(tsrm_resource_type));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    <span style=color:#6272a4>//省略...
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span><span style=color:#6272a4></span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>}
</span></span></code></pre></div><p>一般该函数在PHP内核初始化的时候调用，为了节省内存，默认都会是一个线程数和一个资源类型数，之后如果不够用会进行扩容。</p><h3 id=2ts_allocate_id-函数说明>2.ts_allocate_id 函数说明<a class=anchorjs-link href=#2ts_allocate_id-%e5%87%bd%e6%95%b0%e8%af%b4%e6%98%8e></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>TSRM_API ts_rsrc_id <span style=color:#50fa7b>ts_allocate_id</span>(ts_rsrc_id <span style=color:#ff79c6>*</span>rsrc_id, <span style=color:#8be9fd>size_t</span> size, ts_allocate_ctor ctor, ts_allocate_dtor dtor)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#8be9fd>int</span> i;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#6272a4>//省略...
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//生成当前资源的唯一id
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>*</span>rsrc_id <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>TSRM_SHUFFLE_RSRCidD</span>(id_count<span style=color:#ff79c6>++</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#50fa7b>TSRM_ERROR</span>((TSRM_ERROR_LEVEL_CORE, <span style=color:#f1fa8c>&#34;Obtained resource id %d&#34;</span>, <span style=color:#ff79c6>*</span>rsrc_id));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#6272a4>//判断当前资源类型表是否小于当前资源数
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//如果小于则对资源类型表进行扩容
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (resource_types_table_size <span style=color:#ff79c6>&lt;</span> id_count) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>        resource_types_table <span style=color:#ff79c6>=</span> (tsrm_resource_type <span style=color:#ff79c6>*</span>) <span style=color:#50fa7b>realloc</span>(resource_types_table, <span style=color:#ff79c6>sizeof</span>(tsrm_resource_type)<span style=color:#ff79c6>*</span>id_count);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>        <span style=color:#6272a4>//省略...
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span><span style=color:#6272a4></span>        resource_types_table_size <span style=color:#ff79c6>=</span> id_count;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    <span style=color:#6272a4>//赋值公共资源的大小，构造函数和析构函数指针
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:#6272a4></span>    resource_types_table[<span style=color:#50fa7b>TSRM_UNSHUFFLE_RSRC_ID</span>(<span style=color:#ff79c6>*</span>rsrc_id)].size <span style=color:#ff79c6>=</span> size;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    resource_types_table[<span style=color:#50fa7b>TSRM_UNSHUFFLE_RSRC_ID</span>(<span style=color:#ff79c6>*</span>rsrc_id)].ctor <span style=color:#ff79c6>=</span> ctor;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    resource_types_table[<span style=color:#50fa7b>TSRM_UNSHUFFLE_RSRC_ID</span>(<span style=color:#ff79c6>*</span>rsrc_id)].dtor <span style=color:#ff79c6>=</span> dtor;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>    resource_types_table[<span style=color:#50fa7b>TSRM_UNSHUFFLE_RSRC_ID</span>(<span style=color:#ff79c6>*</span>rsrc_id)].done <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>    <span style=color:#6272a4>//遍历说有的线程结构体，把当前创建的资源数据赋给storage指向的内存空间
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span> (i<span style=color:#ff79c6>=</span><span style=color:#bd93f9>0</span>; i<span style=color:#ff79c6>&lt;</span>tsrm_tls_table_size; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>        tsrm_tls_entry <span style=color:#ff79c6>*</span>p <span style=color:#ff79c6>=</span> tsrm_tls_table[i];
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>        
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>        <span style=color:#6272a4>//第一种情况
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span><span style=color:#6272a4></span>        <span style=color:#6272a4>//p有可能是null，因为还没有调用 TSRMLS_FETCH() 初始化线程结构体指针
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span><span style=color:#6272a4></span>        <span style=color:#6272a4>//所以 resource_types_table 就先暂时保存该资源的 size，之后等初始化
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span><span style=color:#6272a4></span>        <span style=color:#6272a4>//线程结构体指针的时候，会自动在创建该公共资源的内存空间，并赋值storage
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span><span style=color:#6272a4></span>        
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>        <span style=color:#6272a4>//第二种情况
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span><span style=color:#6272a4></span>        <span style=color:#6272a4>//已初始化对应的线程结构体指针，那么就直接根据当前新创建的资源id号对
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span><span style=color:#6272a4></span>        <span style=color:#6272a4>//p-&gt;storage进行扩容，因为资源id都是递增增加的,并根据当前资源的size
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span><span style=color:#6272a4></span>        <span style=color:#6272a4>//malloc创建具体的资源内存空间，创建完成之后回调一下ctor
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>while</span> (p) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span>            <span style=color:#ff79c6>if</span> (p<span style=color:#ff79c6>-&gt;</span>count <span style=color:#ff79c6>&lt;</span> id_count) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span>                <span style=color:#8be9fd>int</span> j;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39</span><span>                p<span style=color:#ff79c6>-&gt;</span>storage <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>) <span style=color:#50fa7b>realloc</span>(p<span style=color:#ff79c6>-&gt;</span>storage, <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>)<span style=color:#ff79c6>*</span>id_count);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40</span><span>                <span style=color:#ff79c6>for</span> (j<span style=color:#ff79c6>=</span>p<span style=color:#ff79c6>-&gt;</span>count; j<span style=color:#ff79c6>&lt;</span>id_count; j<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41</span><span>                    p<span style=color:#ff79c6>-&gt;</span>storage[j] <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>) <span style=color:#50fa7b>malloc</span>(resource_types_table[j].size);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42</span><span>                    <span style=color:#ff79c6>if</span> (resource_types_table[j].ctor) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43</span><span>                        resource_types_table[j].<span style=color:#50fa7b>ctor</span>(p<span style=color:#ff79c6>-&gt;</span>storage[j], <span style=color:#ff79c6>&amp;</span>p<span style=color:#ff79c6>-&gt;</span>storage);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44</span><span>                    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45</span><span>                }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46</span><span>                <span style=color:#6272a4>//id_count每次+1 ， 实际上就是我们公共资源的总数量
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47</span><span><span style=color:#6272a4></span>                p<span style=color:#ff79c6>-&gt;</span>count <span style=color:#ff79c6>=</span> id_count;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48</span><span>            }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49</span><span>            <span style=color:#6272a4>//指向下一个线程结构体指针
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50</span><span><span style=color:#6272a4></span>            p <span style=color:#ff79c6>=</span> p<span style=color:#ff79c6>-&gt;</span>next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53</span><span>    <span style=color:#6272a4>//省略...
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//返回刚才id_count++
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>*</span>rsrc_id;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56</span><span>}
</span></span></code></pre></div><p>当需要注册创建一个公共资源数据的时候就要调用该函数，一般都是在多线程环境下才会调用，也可看出来，该函数会遍历所有的线程结构体指针，并不断的ralloc和malloc 所以反复调用该函数也会有性能损耗.</p><h3 id=3tsrmls_fetch---ts_resource_ex-函数说明>3.TSRMLS_FETCH() -> ts_resource_ex 函数说明<a class=anchorjs-link href=#3tsrmls_fetch---ts_resource_ex-%e5%87%bd%e6%95%b0%e8%af%b4%e6%98%8e></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>TSRM_API <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span><span style=color:#50fa7b>ts_resource_ex</span>(ts_rsrc_id id, THREAD_T <span style=color:#ff79c6>*</span>th_id)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    THREAD_T thread_id;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#8be9fd>int</span> hash_value;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    tsrm_tls_entry <span style=color:#ff79c6>*</span>thread_resources;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#6272a4>//省略...
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#6272a4></span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#ff79c6>if</span>(tsrm_tls_table) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>        <span style=color:#6272a4>//获取当前线程ID
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>th_id) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>            <span style=color:#6272a4>//省略...
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:#6272a4></span>            thread_id <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>tsrm_thread_id</span>();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>            thread_id <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>*</span>th_id;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    <span style=color:#50fa7b>TSRM_ERROR</span>((TSRM_ERROR_LEVEL_INFO, <span style=color:#f1fa8c>&#34;Fetching resource id %d for thread %ld&#34;</span>, id, (<span style=color:#8be9fd>long</span>) thread_id));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    <span style=color:#50fa7b>tsrm_mutex_lock</span>(tsmm_mutex);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>    <span style=color:#ff79c6>#define THREAD_HASH_OF(thr,ts)  (unsigned long)thr%(unsigned long)ts
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span><span style=color:#ff79c6></span>    <span style=color:#6272a4>//通过线程id和当前初始化线程数大小进行取模运算，算出当前线程指针位置因为
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//当前线程指针都存在tsrm_tls_table表里，如果当前位置已经存在一个线程指针
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//则 tsrm_tls_table-&gt;next 实际上就是一个hash冲突链式解决方法.
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span><span style=color:#6272a4></span>    hash_value <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>THREAD_HASH_OF</span>(thread_id, tsrm_tls_table_size);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>    thread_resources <span style=color:#ff79c6>=</span> tsrm_tls_table[hash_value];
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>    <span style=color:#6272a4>//如果不存在去创建当前线程，并将之前调用ts_allocate_id注册创建的那些公共资源
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//全部copy过来.
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>thread_resources) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>        <span style=color:#50fa7b>allocate_new_resource</span>(<span style=color:#ff79c6>&amp;</span>tsrm_tls_table[hash_value], thread_id);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>        <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>ts_resource_ex</span>(id, <span style=color:#ff79c6>&amp;</span>thread_id);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span>         <span style=color:#ff79c6>do</span> {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span>            <span style=color:#6272a4>//判断线程id是否相等
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>if</span> (thread_resources<span style=color:#ff79c6>-&gt;</span>thread_id <span style=color:#ff79c6>==</span> thread_id) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span>                <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span>            }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span>            <span style=color:#6272a4>//如果不等于则next
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>if</span> (thread_resources<span style=color:#ff79c6>-&gt;</span>next) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39</span><span>                thread_resources <span style=color:#ff79c6>=</span> thread_resources<span style=color:#ff79c6>-&gt;</span>next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40</span><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41</span><span>               <span style=color:#6272a4>//如果不存在则还是去初始化创建当前线程
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42</span><span><span style=color:#6272a4></span>                <span style=color:#50fa7b>allocate_new_resource</span>(<span style=color:#ff79c6>&amp;</span>thread_resources<span style=color:#ff79c6>-&gt;</span>next, thread_id);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43</span><span>                <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>ts_resource_ex</span>(id, <span style=color:#ff79c6>&amp;</span>thread_id);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44</span><span>            }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45</span><span>         } <span style=color:#ff79c6>while</span> (thread_resources);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47</span><span>    <span style=color:#6272a4>//找到或创建完当前线程之后，返回当前线程公共资源区&amp;storage指针 
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//如果指定资源id的话则返回 storage[id] 指针
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49</span><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>TSRM_SAFE_RETURN_RSRC</span>(thread_resources<span style=color:#ff79c6>-&gt;</span>storage, id, thread_resources<span style=color:#ff79c6>-&gt;</span>count);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50</span><span>}
</span></span></code></pre></div><h3 id=4allocate_new_resource-函数说明>4.allocate_new_resource 函数说明<a class=anchorjs-link href=#4allocate_new_resource-%e5%87%bd%e6%95%b0%e8%af%b4%e6%98%8e></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>allocate_new_resource</span>(tsrm_tls_entry <span style=color:#ff79c6>**</span>thread_resources_ptr, THREAD_T thread_id)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#8be9fd>int</span> i;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#6272a4>//thread_resources_ptr 
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//有可能是&amp;tsrm_tls_table[hash_value]指针
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//有可能是&amp;tsrm_tls_table[hash_value]-&gt;next指针，这种情况就是hash冲突了
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#6272a4></span>    (<span style=color:#ff79c6>*</span>thread_resources_ptr) <span style=color:#ff79c6>=</span> (tsrm_tls_entry <span style=color:#ff79c6>*</span>) <span style=color:#50fa7b>malloc</span>(<span style=color:#ff79c6>sizeof</span>(tsrm_tls_entry));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    (<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>storage <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>**</span>) <span style=color:#50fa7b>malloc</span>(<span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>)<span style=color:#ff79c6>*</span>id_count);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    (<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>count <span style=color:#ff79c6>=</span> id_count;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    (<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>thread_id <span style=color:#ff79c6>=</span> thread_id;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    (<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#6272a4>/* Set thread local storage to this new thread resources structure */</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#50fa7b>tsrm_tls_set</span>(<span style=color:#ff79c6>*</span>thread_resources_ptr);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    <span style=color:#ff79c6>if</span> (tsrm_new_thread_begin_handler) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>        <span style=color:#50fa7b>tsrm_new_thread_begin_handler</span>(thread_id, <span style=color:#ff79c6>&amp;</span>((<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>storage));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    <span style=color:#6272a4>//这个循环就是把resource_types_table表里面的全部资源类型数据取出来
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//根据size大小创建具体的内存空间，并赋值给当前线程的storage
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//因为刚才调用ts_allocate_id这个函数，可能存在线程指针没有初始化的情况
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//所以只创建全局资源类型数据了，并没有创建具体的资源数据.
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span> (i<span style=color:#ff79c6>=</span><span style=color:#bd93f9>0</span>; i<span style=color:#ff79c6>&lt;</span>id_count; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>        <span style=color:#ff79c6>if</span> (resource_types_table[i].done) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>            (<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>storage[i] <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>        } <span style=color:#ff79c6>else</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span>        {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>            (<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>storage[i] <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>) <span style=color:#50fa7b>malloc</span>(resource_types_table[i].size);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>            <span style=color:#ff79c6>if</span> (resource_types_table[i].ctor) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>                resource_types_table[i].<span style=color:#50fa7b>ctor</span>((<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>storage[i], <span style=color:#ff79c6>&amp;</span>(<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>storage);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>            }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span>    }  
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span>    <span style=color:#6272a4>//调用该函数指针，复制配置信息并回调有配置callback函数的配置项来
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//填充当前线程对应的storage全局区
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (tsrm_new_thread_end_handler) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span>        <span style=color:#50fa7b>tsrm_new_thread_end_handler</span>(thread_id, <span style=color:#ff79c6>&amp;</span>((<span style=color:#ff79c6>*</span>thread_resources_ptr)<span style=color:#ff79c6>-&gt;</span>storage));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39</span><span>}
</span></span></code></pre></div><h2 id=扩展tsrm使用>扩展TSRM使用<a class=anchorjs-link href=#%e6%89%a9%e5%b1%95tsrm%e4%bd%bf%e7%94%a8></a></h2><p>我们在开发扩展的时候也要按照线程安全版本去开发，通过 ZTS 宏判断当前 PHP 是否线程安全版本。</p><h3 id=1扩展里公共资源定义>1.扩展里公共资源定义：<a class=anchorjs-link href=#1%e6%89%a9%e5%b1%95%e9%87%8c%e5%85%ac%e5%85%b1%e8%b5%84%e6%ba%90%e5%ae%9a%e4%b9%89></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#6272a4>//定义公共资源数据，替换之后就是一个zend_模块名字的结构体
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#6272a4></span><span style=color:#50fa7b>ZEND_BEGIN_MODULE_GLOBALS</span>(module_name)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#8be9fd>int</span> id;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#8be9fd>char</span> name;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#50fa7b>ZEND_END_MODULE_GLOBALS</span>(module_name)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#6272a4>//对应的宏定义
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#6272a4></span><span style=color:#ff79c6>#define ZEND_BEGIN_MODULE_GLOBALS(module_name)
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#ff79c6></span>    <span style=color:#ff79c6>typedef</span> <span style=color:#ff79c6>struct</span> _zend_##module_name##_globals {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:#ff79c6>#define ZEND_END_MODULE_GLOBALS(module_name)
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#ff79c6></span>} zend_##module_name##_globals;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#6272a4>//替换后
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:#6272a4></span><span style=color:#ff79c6>typedef</span> <span style=color:#ff79c6>struct</span> _zend_module_name_globals {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>   <span style=color:#8be9fd>int</span> id;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>   <span style=color:#8be9fd>char</span> name;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>} zend_module_name_globals;
</span></span></code></pre></div><p>###2.扩展里的资源id定义</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>#ifdef ZTS
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6></span>  <span style=color:#ff79c6>#define ZEND_DECLARE_MODULE_GLOBALS(module_name)              
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6></span>          ts_rsrc_id module_name##_globals_id;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6>#else
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#ff79c6>#define ZEND_DECLARE_MODULE_GLOBALS(module_name)                               
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span><span style=color:#ff79c6></span>          zend_##module_name##_globals module_name##_globals;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span><span style=color:#ff79c6>#endif
</span></span></span></code></pre></div><p>（1） 线程安全版本：则自动声明全局资源唯一id，因为每个线程都会通过当前的id去storage指向内存区获取资源数据
（2）非线程安全版本：则自动声明当前结构体变量，每次通过变量名获取资源就好了，因为不存在其他线程争抢的情况</p><h3 id=3扩展里获取公共资源数据>3.扩展里获取公共资源数据<a class=anchorjs-link href=#3%e6%89%a9%e5%b1%95%e9%87%8c%e8%8e%b7%e5%8f%96%e5%85%ac%e5%85%b1%e8%b5%84%e6%ba%90%e6%95%b0%e6%8d%ae></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>#ifdef ZTS
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6></span>    <span style=color:#ff79c6>#define MODULE_G(v) TSRMG(xx_globals_id, zend_xx_globals *, v)
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#ff79c6>#else
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6></span>    <span style=color:#ff79c6>#define MODULE_G(v) (xx_globals.v)
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#ff79c6>#endif
</span></span></span></code></pre></div><p>如上每次获取资源全部通过自己定义的MODULE_G()宏获取，如果是线程安全则通过对应的TSRM管理器获取当前线程指定的资源id数据，如果不是则直接通过资源变量名字获取即可。</p><h3 id=4扩展里初始化公共资源>4.扩展里初始化公共资源<a class=anchorjs-link href=#4%e6%89%a9%e5%b1%95%e9%87%8c%e5%88%9d%e5%a7%8b%e5%8c%96%e5%85%ac%e5%85%b1%e8%b5%84%e6%ba%90></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#6272a4>//一般初始化公共资源数据,都会在扩展的MINIT函数执行
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#6272a4>//如果是ZTS则ts_allocate_id调用之.
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4></span><span style=color:#50fa7b>PHP_MINIT_FUNCTION</span>(myextension){
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    <span style=color:#ff79c6>#ifdef ZTS
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#ff79c6></span>       <span style=color:#50fa7b>ts_allocate_id</span>(<span style=color:#ff79c6>&amp;</span>xx_globals_id，<span style=color:#ff79c6>sizeof</span>(zend_module_name_globals),ctor,dtor)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>    <span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span><span style=color:#ff79c6></span>}
</span></span></code></pre></div><p>#结束语
上面介绍的就是PHP-TSRM线程安全管理器的实现，了解TSRM之后，无论是看内核源码还是开发PHP扩展都有很大的好处，因为内核和扩展里面充斥着大量的TSRM_宏定义。</p><hr style=visibility:hidden><ul class=pager><li class=previous><a href=/icorer_blog/posts/php-extension-development-2.2-thread-safety/ data-toggle=tooltip data-placement=top title=PHP扩展开发2.2：线程安全>Previous<br><span>PHP扩展开发2.2：线程安全</span></a></li><li class=next><a href=/icorer_blog/posts/programming-notes-c-language-callback-function/ data-toggle=tooltip data-placement=top title=编程笔记：C语言回调函数>Next<br><span>编程笔记：C语言回调函数</span></a></li></ul><hr style=visibility:hidden></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5>FEATURED TAGS</h5><div class=tags><a href=/icorer_blog/tags/blockchain/>blockchain</a>
<a href=/icorer_blog/tags/clang/>CLang</a>
<a href=/icorer_blog/tags/cloudnative/>cloudnative</a>
<a href=/icorer_blog/tags/cmake/>Cmake</a>
<a href=/icorer_blog/tags/deca/>DeCA</a>
<a href=/icorer_blog/tags/dpki/>DPKI</a>
<a href=/icorer_blog/tags/drand/>drand</a>
<a href=/icorer_blog/tags/eip/>EIP</a>
<a href=/icorer_blog/tags/epoll/>epoll</a>
<a href=/icorer_blog/tags/ethereum/>Ethereum</a>
<a href=/icorer_blog/tags/fpga/>FPGA</a>
<a href=/icorer_blog/tags/gc/>GC</a>
<a href=/icorer_blog/tags/golang/>GoLang</a>
<a href=/icorer_blog/tags/hackathon/>Hackathon</a>
<a href=/icorer_blog/tags/http2/>HTTP2</a>
<a href=/icorer_blog/tags/http3/>HTTP3</a>
<a href=/icorer_blog/tags/icefiredb/>IceFireDB</a>
<a href=/icorer_blog/tags/k8s/>k8s</a>
<a href=/icorer_blog/tags/kafka/>kafka</a>
<a href=/icorer_blog/tags/layer2/>Layer2</a>
<a href=/icorer_blog/tags/linux/>linux</a>
<a href=/icorer_blog/tags/nginx/>Nginx</a>
<a href=/icorer_blog/tags/nosql/>NoSQL</a>
<a href=/icorer_blog/tags/php/>PHP</a>
<a href=/icorer_blog/tags/php-kernel/>php kernel</a>
<a href=/icorer_blog/tags/php%E5%86%85%E6%A0%B8/>PHP内核</a>
<a href=/icorer_blog/tags/quic/>QUIC</a>
<a href=/icorer_blog/tags/redis/>redis</a>
<a href=/icorer_blog/tags/sbt/>SBT</a>
<a href=/icorer_blog/tags/serverless/>serverless</a>
<a href=/icorer_blog/tags/ssi/>SSI</a>
<a href=/icorer_blog/tags/unikernel/>unikernel</a>
<a href=/icorer_blog/tags/wanxiang/>Wanxiang</a>
<a href=/icorer_blog/tags/web3/>web3</a>
<a href=/icorer_blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件</a>
<a href=/icorer_blog/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a>
<a href=/icorer_blog/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/>以太坊</a>
<a href=/icorer_blog/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/>信息安全</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/>内存数据库</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/>内存泄漏</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/>内核源码</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6/>内核研究</a>
<a href=/icorer_blog/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/>区块链</a>
<a href=/icorer_blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>垃圾回收</a>
<a href=/icorer_blog/tags/%E5%AD%98%E5%82%A8/>存储</a>
<a href=/icorer_blog/tags/%E5%AE%B9%E5%99%A8/>容器</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/>底层开发</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/>底层研究</a>
<a href=/icorer_blog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/>开源项目</a>
<a href=/icorer_blog/tags/%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97/>异构计算</a>
<a href=/icorer_blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a>
<a href=/icorer_blog/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/>性能测试</a>
<a href=/icorer_blog/tags/%E6%8A%80%E6%9C%AF%E7%A7%91%E6%99%AE/>技术科普</a>
<a href=/icorer_blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/>数据库技术</a>
<a href=/icorer_blog/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/>文章翻译</a>
<a href=/icorer_blog/tags/%E6%96%B0%E6%9E%B6%E6%9E%84/>新架构</a>
<a href=/icorer_blog/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/>时序数据库</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/>服务治理</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/>服务网格</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E9%81%A5%E6%B5%8B/>服务遥测</a>
<a href=/icorer_blog/tags/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/>测试报告</a>
<a href=/icorer_blog/tags/%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/>研究报告</a>
<a href=/icorer_blog/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/>缓存技术</a>
<a href=/icorer_blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a>
<a href=/icorer_blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/>虚拟机</a>
<a href=/icorer_blog/tags/%E8%A1%8C%E4%B8%9A%E6%8A%A5%E5%91%8A/>行业报告</a>
<a href=/icorer_blog/tags/%E8%AE%BA%E6%96%87/>论文</a>
<a href=/icorer_blog/tags/%E9%9B%B6%E4%BF%A1%E4%BB%BB/>零信任</a>
<a href=/icorer_blog/tags/%E9%AB%98%E6%80%A7%E8%83%BD/>高性能</a></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=/icorer_blog/index.xml><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/corerman1><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/gitsrc><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 笔迹-工匠之芯 2023</p></div></div></div></footer><script src=/icorer_blog/js/jquery.min.js></script>
<script src=/icorer_blog/js/bootstrap.min.js crossorigin=anonymous></script>
<script src=/icorer_blog/js/hux-blog.min.c4ea77041cd3edbfc8b2622cd887a9a5d8760a4162d14489e36d2a3fa4c90172.js></script>
<script src=/icorer_blog/js/simple-jekyll-search.min.js></script>
<script src=/icorer_blog/js/search.min.7d1445cf07369bca2715d9f63738c16c73a7a2273a95d6729bee561f7e84c6c8.js></script>
<script src=/icorer_blog/zoomjs/zoom.min.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB37D8LWFT"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VB37D8LWFT")</script></body></html>