<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:image" content="
              https://res.cloudinary.com/malloc/image/upload/v1669271757/icorer.com/34047788_pepere.jpg
            "><title>⽤于区块链可扩展性的⾼效能 FPGA-Redis 混合 NoSQL 缓存系统 | 笔迹-工匠之芯</title><meta name=author content="LB"><meta name=description content="一、FPGA-Redis介绍鼓舞人心的区块链技术在加密货币以外的领域取得了很多采用和成功领域落地，因为它的好处已经被探索和成功测试。可扩展性是区块链的最大挑战之一，许多设备（轻量级节点）尤其是物联网依赖于完整的区块链服务器，因此需要减少服务器上的工作负载以获得高性能。这篇论文提出了一种高性能、高效的混合（多级）和分布式NoSQL缓存系统，用于提高区块链应用程序的可扩展（吞吐量）。我们研究了区块链中的性能瓶颈，并设计了一种高效的千兆以太网FPGA NoSQL缓存架构，该架构通过Hiredis C客户端与Redis数据库协同工作。Curl和Jansson用于连接区块链。我们为特定于区块链的高效缓存设计了一个定制的SHA-256核心。我们的结果显示，当FPGA上发生缓存命中时，性能提高了103倍。所提出的FPGA-Redis系统获得了高达4.09倍的改进，还实现了较小的FPGA面积利用率和较低的功耗。
二、概述区块链技术激励了许多人，帮助许多企业和政府改进系统，解决了信任、安全、速度、成本、效率和中心化等诸多瓶颈问题。英国政府办公室的报告确认区块链可以保护数据、降低成本并为记录提供透明度。区块链由中本聪于2008年首次提出并支持加密货币（比特币）和许多其他用于医疗保健、身份管理、网络安全等应用程序。Corda是R3的区块链（由200多家公司组成的联盟，主要是金融机构），用于增强商业交易和网络，R3一直在为企业使用和探索区块链。
尽管区块链很强大，但可扩展性（低吞吐量、高延迟、存储问题和读取性能差）是其巨大的挑战，但研究较少。与非区块链应用程序相比，区块链应用程序的吞吐量要低很多。比特币和以太坊支持每秒3-4和15-20笔交易（TPS），而Visa和PayPal分别支持1667和193TPS，另一方面，与非区块链服务器相比，区块链服务器的查询响应（读取性能）也很差。例如在我们处理约每秒96个响应的区块链系统中，查询延迟超过10毫秒。同样，Blockcypher 区块链服务器⽀持每秒3个请求。与⾮区块 链服务器相⽐，Google和YouTube分别处理每秒84,405个请求和每秒85,021次观看。糟糕的读取性能是由于区块链的结构和巨大的尺寸（比特币超过288GB）以及区块链数据存储在硬盘上的事实。与用于存储Redis等NoSQL缓存的RAM（快150,000倍）不同，硬盘具有较高的访问延迟。由于这种糟糕的读取性能，现有的区块链无法处理有效服务器所需的每秒大量客户端请求。许多轻量级节点（数以千计的物联网设备和简化验证（SPV）节点），仅依赖区块链服务器来获取区块链数据，因为其庞大的规模，它们无法存储完整的区块链。现在越来越多的轻量级客户端使用区块链并将更多的工作放在区块链服务器上，因此必须减少区块链服务器上的工作量以提升性能，从而更好地扩展区块量应用程序。
NoSQL缓存是提高和增强区块量服务器读取性能的一种有效方式。Redis、Hadoop和Memcached等NoSQL缓存如今已广泛用于大型Web数据中心，例如Yahoo、Twitter、Facebook、Youtube甚至Google，其中数百个分布式NoSQL部署缓存服务器是为了改善许多性能和可伸缩问题并节省成本。NoSQL缓存具有非常高的性能进行大规模水平扩展的优势，并且比使用更强大的CPU和内存（垂直扩展）更新现有服务器更经济。水平扩展是指使用廉价商品服务器的副本来获得更好的性能，而不是传统的垂直扩展，其中将更强大的资源添加到单个服务器使系统更加昂贵。仅苹果公司就使用了超过75000个NoSQL缓存（Cassandra）表格系列集群来存储超过10PB的数据。
分布式 NoSQL 缓存由于其⾼性能以及区块链请求（尤其是块头请求）的时间局部性，可以极⼤地提⾼区块链服务器响应的吞吐量和延迟性能。许多轻量级节点（如简化⽀付验证节点（特殊⽬的公司 )在添加新块的⼏个⼩时内。
尽管具有⾼性能，但软件 NoSQL 缓存在⾼性能时会消耗⾼功率和更多CPU 资源（在⽹络处理上）。因此，当 FPGA 发⽣缓存命中时，使⽤ FPGA来降低功耗和 CPU 资源消耗并提⾼性能。然⽽，FPGA 中的⼩尺⼨和有限的内存给可以缓存在 FPGA 上的数据量带来了缺陷和限制，从⽽通过增加 FPGA 的未命中率来影响系统性能。
本⽂研究了区块链中的性能瓶颈，并提出了⼀种⾼效的⾼性能混合分布式NoSQL FPGA-Redis 缓存系统，以减少区块链服务器的⼯作负载并提⾼其性能。我们设计并实现了⼀个千兆以太⽹ FPGA ⽹络接⼝控制器 (NIC)，该控制器包含键值存储，⽤于有效地缓存 FPGA 上的区块链数据。Redis 软件缓存和 Redis 应⽤程序内置在 Redis 服务器 PC 中，它通过 FPGA 上实现的千兆总线主控直接内存地址 (BMD) PCI Express (PCIe) 端点连接到 NIC。Redis 应⽤程序使⽤Hiredis API（实现与Redis缓存对话的Redi 的C客⼾端）。整个缓存系统通过我们的服务器应⽤程序中内置的Curl和Jansson API 连接到全节点区块链服务器。
该系统改善了FPGA NoSQL缓存内存⼩的缺点，同时以更低的功耗提⾼了 软件缓存的性能。FPGA 和 Redis 协同⼯作。Redis 通过提供另⼀个缓存层来补充 FPGA 缓存的有限内存。当在 FPGA 上未找到请求的数据（发⽣缓存未命中）时，数据从 Redis（如果缓存）⽽不是存储在主内存中的主区块链中获取。由于 Redis ⽐主存更快，因此整个系统的性能得到了提⾼。反过来，FPGA 通过处理⽹络处理来降低Redis的⾼性能和CPU资源消耗。我们只在FPGA和Redis（包括缓存）上缓存频繁的请求（即块头、确认、块⾼度、时间跨度和 Merkle根），⽽在Redis上缓存不频繁和⼤数据请求（例如块请求）只要。此外，仅当FPGA上发⽣缓存未命中时才检查Redis 缓存。"><meta name=keywords content="blog,博客,工匠之芯,笔迹-工匠之芯"><meta name=twitter:card content="summary"><meta name=twitter:title content="⽤于区块链可扩展性的⾼效能 FPGA-Redis 混合 NoSQL 缓存系统"><meta name=twitter:description content="一、FPGA-Redis介绍鼓舞人心的区块链技术在加密货币以外的领域取得了很多采用和成功领域落地，因为它的好处已经被探索和成功测试。可扩展性是区块链的最大挑战之一，许多设备（轻量级节点）尤其是物联网依赖于完整的区块链服务器，因此需要减少服务器上的工作负载以获得高性能。这篇论文提出了一种高性能、高效的混合（多级）和分布式NoSQL缓存系统，用于提高区块链应用程序的可扩展（吞吐量）。我们研究了区块链中的性能瓶颈，并设计了一种高效的千兆以太网FPGA NoSQL缓存架构，该架构通过Hiredis C客户端与Redis数据库协同工作。Curl和Jansson用于连接区块链。我们为特定于区块链的高效缓存设计了一个定制的SHA-256核心。我们的结果显示，当FPGA上发生缓存命中时，性能提高了103倍。所提出的FPGA-Redis系统获得了高达4.09倍的改进，还实现了较小的FPGA面积利用率和较低的功耗。
二、概述区块链技术激励了许多人，帮助许多企业和政府改进系统，解决了信任、安全、速度、成本、效率和中心化等诸多瓶颈问题。英国政府办公室的报告确认区块链可以保护数据、降低成本并为记录提供透明度。区块链由中本聪于2008年首次提出并支持加密货币（比特币）和许多其他用于医疗保健、身份管理、网络安全等应用程序。Corda是R3的区块链（由200多家公司组成的联盟，主要是金融机构），用于增强商业交易和网络，R3一直在为企业使用和探索区块链。
尽管区块链很强大，但可扩展性（低吞吐量、高延迟、存储问题和读取性能差）是其巨大的挑战，但研究较少。与非区块链应用程序相比，区块链应用程序的吞吐量要低很多。比特币和以太坊支持每秒3-4和15-20笔交易（TPS），而Visa和PayPal分别支持1667和193TPS，另一方面，与非区块链服务器相比，区块链服务器的查询响应（读取性能）也很差。例如在我们处理约每秒96个响应的区块链系统中，查询延迟超过10毫秒。同样，Blockcypher 区块链服务器⽀持每秒3个请求。与⾮区块 链服务器相⽐，Google和YouTube分别处理每秒84,405个请求和每秒85,021次观看。糟糕的读取性能是由于区块链的结构和巨大的尺寸（比特币超过288GB）以及区块链数据存储在硬盘上的事实。与用于存储Redis等NoSQL缓存的RAM（快150,000倍）不同，硬盘具有较高的访问延迟。由于这种糟糕的读取性能，现有的区块链无法处理有效服务器所需的每秒大量客户端请求。许多轻量级节点（数以千计的物联网设备和简化验证（SPV）节点），仅依赖区块链服务器来获取区块链数据，因为其庞大的规模，它们无法存储完整的区块链。现在越来越多的轻量级客户端使用区块链并将更多的工作放在区块链服务器上，因此必须减少区块链服务器上的工作量以提升性能，从而更好地扩展区块量应用程序。
NoSQL缓存是提高和增强区块量服务器读取性能的一种有效方式。Redis、Hadoop和Memcached等NoSQL缓存如今已广泛用于大型Web数据中心，例如Yahoo、Twitter、Facebook、Youtube甚至Google，其中数百个分布式NoSQL部署缓存服务器是为了改善许多性能和可伸缩问题并节省成本。NoSQL缓存具有非常高的性能进行大规模水平扩展的优势，并且比使用更强大的CPU和内存（垂直扩展）更新现有服务器更经济。水平扩展是指使用廉价商品服务器的副本来获得更好的性能，而不是传统的垂直扩展，其中将更强大的资源添加到单个服务器使系统更加昂贵。仅苹果公司就使用了超过75000个NoSQL缓存（Cassandra）表格系列集群来存储超过10PB的数据。
分布式 NoSQL 缓存由于其⾼性能以及区块链请求（尤其是块头请求）的时间局部性，可以极⼤地提⾼区块链服务器响应的吞吐量和延迟性能。许多轻量级节点（如简化⽀付验证节点（特殊⽬的公司 )在添加新块的⼏个⼩时内。
尽管具有⾼性能，但软件 NoSQL 缓存在⾼性能时会消耗⾼功率和更多CPU 资源（在⽹络处理上）。因此，当 FPGA 发⽣缓存命中时，使⽤ FPGA来降低功耗和 CPU 资源消耗并提⾼性能。然⽽，FPGA 中的⼩尺⼨和有限的内存给可以缓存在 FPGA 上的数据量带来了缺陷和限制，从⽽通过增加 FPGA 的未命中率来影响系统性能。
本⽂研究了区块链中的性能瓶颈，并提出了⼀种⾼效的⾼性能混合分布式NoSQL FPGA-Redis 缓存系统，以减少区块链服务器的⼯作负载并提⾼其性能。我们设计并实现了⼀个千兆以太⽹ FPGA ⽹络接⼝控制器 (NIC)，该控制器包含键值存储，⽤于有效地缓存 FPGA 上的区块链数据。Redis 软件缓存和 Redis 应⽤程序内置在 Redis 服务器 PC 中，它通过 FPGA 上实现的千兆总线主控直接内存地址 (BMD) PCI Express (PCIe) 端点连接到 NIC。Redis 应⽤程序使⽤Hiredis API（实现与Redis缓存对话的Redi 的C客⼾端）。整个缓存系统通过我们的服务器应⽤程序中内置的Curl和Jansson API 连接到全节点区块链服务器。
该系统改善了FPGA NoSQL缓存内存⼩的缺点，同时以更低的功耗提⾼了 软件缓存的性能。FPGA 和 Redis 协同⼯作。Redis 通过提供另⼀个缓存层来补充 FPGA 缓存的有限内存。当在 FPGA 上未找到请求的数据（发⽣缓存未命中）时，数据从 Redis（如果缓存）⽽不是存储在主内存中的主区块链中获取。由于 Redis ⽐主存更快，因此整个系统的性能得到了提⾼。反过来，FPGA 通过处理⽹络处理来降低Redis的⾼性能和CPU资源消耗。我们只在FPGA和Redis（包括缓存）上缓存频繁的请求（即块头、确认、块⾼度、时间跨度和 Merkle根），⽽在Redis上缓存不频繁和⼤数据请求（例如块请求）只要。此外，仅当FPGA上发⽣缓存未命中时才检查Redis 缓存。"><meta property="og:title" content="⽤于区块链可扩展性的⾼效能 FPGA-Redis 混合 NoSQL 缓存系统"><meta property="og:description" content="一、FPGA-Redis介绍鼓舞人心的区块链技术在加密货币以外的领域取得了很多采用和成功领域落地，因为它的好处已经被探索和成功测试。可扩展性是区块链的最大挑战之一，许多设备（轻量级节点）尤其是物联网依赖于完整的区块链服务器，因此需要减少服务器上的工作负载以获得高性能。这篇论文提出了一种高性能、高效的混合（多级）和分布式NoSQL缓存系统，用于提高区块链应用程序的可扩展（吞吐量）。我们研究了区块链中的性能瓶颈，并设计了一种高效的千兆以太网FPGA NoSQL缓存架构，该架构通过Hiredis C客户端与Redis数据库协同工作。Curl和Jansson用于连接区块链。我们为特定于区块链的高效缓存设计了一个定制的SHA-256核心。我们的结果显示，当FPGA上发生缓存命中时，性能提高了103倍。所提出的FPGA-Redis系统获得了高达4.09倍的改进，还实现了较小的FPGA面积利用率和较低的功耗。
二、概述区块链技术激励了许多人，帮助许多企业和政府改进系统，解决了信任、安全、速度、成本、效率和中心化等诸多瓶颈问题。英国政府办公室的报告确认区块链可以保护数据、降低成本并为记录提供透明度。区块链由中本聪于2008年首次提出并支持加密货币（比特币）和许多其他用于医疗保健、身份管理、网络安全等应用程序。Corda是R3的区块链（由200多家公司组成的联盟，主要是金融机构），用于增强商业交易和网络，R3一直在为企业使用和探索区块链。
尽管区块链很强大，但可扩展性（低吞吐量、高延迟、存储问题和读取性能差）是其巨大的挑战，但研究较少。与非区块链应用程序相比，区块链应用程序的吞吐量要低很多。比特币和以太坊支持每秒3-4和15-20笔交易（TPS），而Visa和PayPal分别支持1667和193TPS，另一方面，与非区块链服务器相比，区块链服务器的查询响应（读取性能）也很差。例如在我们处理约每秒96个响应的区块链系统中，查询延迟超过10毫秒。同样，Blockcypher 区块链服务器⽀持每秒3个请求。与⾮区块 链服务器相⽐，Google和YouTube分别处理每秒84,405个请求和每秒85,021次观看。糟糕的读取性能是由于区块链的结构和巨大的尺寸（比特币超过288GB）以及区块链数据存储在硬盘上的事实。与用于存储Redis等NoSQL缓存的RAM（快150,000倍）不同，硬盘具有较高的访问延迟。由于这种糟糕的读取性能，现有的区块链无法处理有效服务器所需的每秒大量客户端请求。许多轻量级节点（数以千计的物联网设备和简化验证（SPV）节点），仅依赖区块链服务器来获取区块链数据，因为其庞大的规模，它们无法存储完整的区块链。现在越来越多的轻量级客户端使用区块链并将更多的工作放在区块链服务器上，因此必须减少区块链服务器上的工作量以提升性能，从而更好地扩展区块量应用程序。
NoSQL缓存是提高和增强区块量服务器读取性能的一种有效方式。Redis、Hadoop和Memcached等NoSQL缓存如今已广泛用于大型Web数据中心，例如Yahoo、Twitter、Facebook、Youtube甚至Google，其中数百个分布式NoSQL部署缓存服务器是为了改善许多性能和可伸缩问题并节省成本。NoSQL缓存具有非常高的性能进行大规模水平扩展的优势，并且比使用更强大的CPU和内存（垂直扩展）更新现有服务器更经济。水平扩展是指使用廉价商品服务器的副本来获得更好的性能，而不是传统的垂直扩展，其中将更强大的资源添加到单个服务器使系统更加昂贵。仅苹果公司就使用了超过75000个NoSQL缓存（Cassandra）表格系列集群来存储超过10PB的数据。
分布式 NoSQL 缓存由于其⾼性能以及区块链请求（尤其是块头请求）的时间局部性，可以极⼤地提⾼区块链服务器响应的吞吐量和延迟性能。许多轻量级节点（如简化⽀付验证节点（特殊⽬的公司 )在添加新块的⼏个⼩时内。
尽管具有⾼性能，但软件 NoSQL 缓存在⾼性能时会消耗⾼功率和更多CPU 资源（在⽹络处理上）。因此，当 FPGA 发⽣缓存命中时，使⽤ FPGA来降低功耗和 CPU 资源消耗并提⾼性能。然⽽，FPGA 中的⼩尺⼨和有限的内存给可以缓存在 FPGA 上的数据量带来了缺陷和限制，从⽽通过增加 FPGA 的未命中率来影响系统性能。
本⽂研究了区块链中的性能瓶颈，并提出了⼀种⾼效的⾼性能混合分布式NoSQL FPGA-Redis 缓存系统，以减少区块链服务器的⼯作负载并提⾼其性能。我们设计并实现了⼀个千兆以太⽹ FPGA ⽹络接⼝控制器 (NIC)，该控制器包含键值存储，⽤于有效地缓存 FPGA 上的区块链数据。Redis 软件缓存和 Redis 应⽤程序内置在 Redis 服务器 PC 中，它通过 FPGA 上实现的千兆总线主控直接内存地址 (BMD) PCI Express (PCIe) 端点连接到 NIC。Redis 应⽤程序使⽤Hiredis API（实现与Redis缓存对话的Redi 的C客⼾端）。整个缓存系统通过我们的服务器应⽤程序中内置的Curl和Jansson API 连接到全节点区块链服务器。
该系统改善了FPGA NoSQL缓存内存⼩的缺点，同时以更低的功耗提⾼了 软件缓存的性能。FPGA 和 Redis 协同⼯作。Redis 通过提供另⼀个缓存层来补充 FPGA 缓存的有限内存。当在 FPGA 上未找到请求的数据（发⽣缓存未命中）时，数据从 Redis（如果缓存）⽽不是存储在主内存中的主区块链中获取。由于 Redis ⽐主存更快，因此整个系统的性能得到了提⾼。反过来，FPGA 通过处理⽹络处理来降低Redis的⾼性能和CPU资源消耗。我们只在FPGA和Redis（包括缓存）上缓存频繁的请求（即块头、确认、块⾼度、时间跨度和 Merkle根），⽽在Redis上缓存不频繁和⼤数据请求（例如块请求）只要。此外，仅当FPGA上发⽣缓存未命中时才检查Redis 缓存。"><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_blog/posts/blockchain_fpga_redis_nosql/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-25T22:35:12+08:00"><meta property="article:modified_time" content="2021-05-25T22:35:12+08:00"><link rel=stylesheet href=/icorer_blog/css/bootstrap.min.css crossorigin=anonymous><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/icorer_blog/sass/main.css><link rel=stylesheet href=/icorer_blog/zoomjs/zoom.min.css><script src=/icorer_blog/js/lazysizes.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/icorer_blog/apple-touch-icon.png><link rel=icon type=image/ico sizes=16x16 href=/icorer_blog/img/favicon.ico><link rel=manifest href=/icorer_blog/site.webmanifest></head><body><nav class="navbar navbar-default navbar-custom navbar-fixed-top invert"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://icorer.com/icorer_blog/>笔迹-工匠之芯</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=https://icorer.com title=工匠之芯>工匠之芯</a></li><li><a href=https://icorer.com/icorer_about title=关于我>关于我</a></li><li><a href=https://github.com/gitsrc title=开源仓库>开源仓库</a></li><li class=search-icon><a href=javascript:void(0)><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse"),__HuxNav__={close:function(){$navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)},open:function(){$collapse.style.height="auto",$navbar.className+=" in"}};$toggle.addEventListener("click",function(){$navbar.className.indexOf("in")>0?__HuxNav__.close():__HuxNav__.open()}),document.addEventListener("click",function(e){if(e.target==$toggle)return;if(e.target.className=="icon-bar")return;__HuxNav__.close()})</script><div class=search-page><div class=search-icon-close-container><span class=search-icon-close><i class="fa fa-chevron-down"></i></span></div><div class="search-main container"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><form></form><input type=text id=search-input placeholder=内容搜索...></form><div id=search-results class=mini-post-list></div></div></div></div></div><style type=text/css>header.intro-header{position:relative;background-image:url('')}</style><header class="intro-header style-text"><div class=header-mask></div><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/icorer_blog/tags/redis/ title=redis>redis</a>
<a class=tag href=/icorer_blog/tags/%E8%AE%BA%E6%96%87/ title=论文>论文</a>
<a class=tag href=/icorer_blog/tags/fpga/ title=FPGA>FPGA</a>
<a class=tag href=/icorer_blog/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/ title=区块链>区块链</a>
<a class=tag href=/icorer_blog/tags/blockchain/ title=blockchain>blockchain</a>
<a class=tag href=/icorer_blog/tags/nosql/ title=NoSQL>NoSQL</a>
<a class=tag href=/icorer_blog/tags/%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97/ title=异构计算>异构计算</a></div><h1>⽤于区块链可扩展性的⾼效能 FPGA-Redis 混合 NoSQL 缓存系统</h1><h2 class=subheading></h2><span class=meta>Posted by LB
on Tue, May 25, 2021</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=一fpga-redis介绍>一、FPGA-Redis介绍<a class=anchorjs-link href=#%e4%b8%80fpga-redis%e4%bb%8b%e7%bb%8d></a></h1><p>鼓舞人心的区块链技术在加密货币以外的领域取得了很多采用和成功领域落地，因为它的好处已经被探索和成功测试。可扩展性是区块链的最大挑战之一，许多设备（轻量级节点）尤其是物联网依赖于完整的区块链服务器，因此需要减少服务器上的工作负载以获得高性能。这篇论文提出了一种高性能、高效的混合（多级）和分布式NoSQL缓存系统，用于提高区块链应用程序的可扩展（吞吐量）。我们研究了区块链中的性能瓶颈，并设计了一种高效的千兆以太网FPGA NoSQL缓存架构，该架构通过Hiredis C客户端与Redis数据库协同工作。Curl和Jansson用于连接区块链。我们为特定于区块链的高效缓存设计了一个定制的SHA-256核心。我们的结果显示，当FPGA上发生缓存命中时，性能提高了103倍。所提出的FPGA-Redis系统获得了高达4.09倍的改进，还实现了较小的FPGA面积利用率和较低的功耗。</p><h1 id=二概述>二、概述<a class=anchorjs-link href=#%e4%ba%8c%e6%a6%82%e8%bf%b0></a></h1><p>区块链技术激励了许多人，帮助许多企业和政府改进系统，解决了信任、安全、速度、成本、效率和中心化等诸多瓶颈问题。英国政府办公室的报告确认区块链可以保护数据、降低成本并为记录提供透明度。区块链由中本聪于2008年首次提出并支持加密货币（比特币）和许多其他用于医疗保健、身份管理、网络安全等应用程序。Corda是R3的区块链（由200多家公司组成的联盟，主要是金融机构），用于增强商业交易和网络，R3一直在为企业使用和探索区块链。</p><p>尽管区块链很强大，但可扩展性（低吞吐量、高延迟、存储问题和读取性能差）是其巨大的挑战，但研究较少。与非区块链应用程序相比，区块链应用程序的吞吐量要低很多。比特币和以太坊支持每秒3-4和15-20笔交易（TPS），而Visa和PayPal分别支持1667和193TPS，另一方面，与非区块链服务器相比，区块链服务器的查询响应（读取性能）也很差。例如在我们处理约每秒96个响应的区块链系统中，查询延迟超过10毫秒。同样，Blockcypher 区块链服务器⽀持每秒3个请求。与⾮区块 链服务器相⽐，Google和YouTube分别处理每秒84,405个请求和每秒85,021次观看。糟糕的读取性能是由于区块链的结构和巨大的尺寸（比特币超过288GB）以及区块链数据存储在硬盘上的事实。与用于存储Redis等NoSQL缓存的RAM（快150,000倍）不同，硬盘具有较高的访问延迟。由于这种糟糕的读取性能，现有的区块链无法处理有效服务器所需的每秒大量客户端请求。许多轻量级节点（数以千计的物联网设备和简化验证（SPV）节点），仅依赖区块链服务器来获取区块链数据，因为其庞大的规模，它们无法存储完整的区块链。现在越来越多的轻量级客户端使用区块链并将更多的工作放在区块链服务器上，因此必须减少区块链服务器上的工作量以提升性能，从而更好地扩展区块量应用程序。</p><p>NoSQL缓存是提高和增强区块量服务器读取性能的一种有效方式。Redis、Hadoop和Memcached等NoSQL缓存如今已广泛用于大型Web数据中心，例如Yahoo、Twitter、Facebook、Youtube甚至Google，其中数百个分布式NoSQL部署缓存服务器是为了改善许多性能和可伸缩问题并节省成本。NoSQL缓存具有非常高的性能进行大规模水平扩展的优势，并且比使用更强大的CPU和内存（垂直扩展）更新现有服务器更经济。水平扩展是指使用廉价商品服务器的副本来获得更好的性能，而不是传统的垂直扩展，其中将更强大的资源添加到单个服务器使系统更加昂贵。仅苹果公司就使用了超过75000个NoSQL缓存（Cassandra）表格系列集群来存储超过10PB的数据。</p><p>分布式 NoSQL 缓存由于其⾼性能以及区块链请求（尤其是块头请求）的时间局部性，可以极⼤地提⾼区块链服务器响应的吞吐量和延迟性能。许多轻量级节点（如简化⽀付验证节点（<em>特殊⽬的公司</em> )在添加新块的⼏个⼩时内。</p><p>尽管具有⾼性能，但软件 NoSQL 缓存在⾼性能时会消耗⾼功率和更多CPU 资源（在⽹络处理上）。因此，当 FPGA 发⽣缓存命中时，使⽤ FPGA来降低功耗和 CPU 资源消耗并提⾼性能。然⽽，FPGA 中的⼩尺⼨和有限的内存给可以缓存在 FPGA 上的数据量带来了缺陷和限制，从⽽通过增加 FPGA 的未命中率来影响系统性能。</p><p>本⽂研究了区块链中的性能瓶颈，并提出了⼀种⾼效的<strong>⾼性能混合分布式NoSQL FPGA-Redis 缓存</strong>系统，以减少区块链服务器的⼯作负载并提⾼其性能。我们设计并实现了⼀个千兆以太⽹ FPGA ⽹络接⼝控制器 (NIC)，该控制器包含键值存储，⽤于有效地缓存 FPGA 上的区块链数据。Redis 软件缓存和 Redis 应⽤程序内置在 Redis 服务器 PC 中，它通过 FPGA 上实现的千兆总线主控直接内存地址 (BMD) PCI Express (PCIe) 端点连接到 NIC。Redis 应⽤程序使⽤Hiredis API（实现与Redis缓存对话的Redi 的C客⼾端）。整个缓存系统通过我们的服务器应⽤程序中内置的Curl和Jansson API 连接到全节点区块链服务器。</p><p>该系统改善了FPGA NoSQL缓存内存⼩的缺点，同时以更低的功耗提⾼了 软件缓存的性能。FPGA 和 Redis 协同⼯作。Redis 通过提供另⼀个缓存层来补充 FPGA 缓存的有限内存。当在 FPGA 上未找到请求的数据（发⽣缓存未命中）时，数据从 Redis（如果缓存）⽽不是存储在主内存中的主区块链中获取。由于 Redis ⽐主存更快，因此整个系统的性能得到了提⾼。反过来，FPGA 通过处理⽹络处理来降低Redis的⾼性能和CPU资源消耗。我们只在FPGA和Redis（包括缓存）上缓存频繁的请求（即块头、确认、块⾼度、时间跨度和 Merkle根），⽽在Redis上缓存不频繁和⼤数据请求（例如块请求）只要。此外，仅当FPGA上发⽣缓存未命中时才检查Redis 缓存。</p><p>我们观察到⼤多数区块链数据都需要⼀个 SHA-256 哈希值参数来请求。因此，我们利⽤这种独特的区块链性质，以两种⽅式使我们的系统⾼效且特 定于区块链：</p><ol><li>我们设计并实现了⼀个定制的SHA-256哈希核⼼，我们针对区块链的哈希表。只有当参数不是哈希值时才执⾏实际的哈希，从 ⽽节省了⼏次哈希执⾏并提⾼了性能。</li><li>由于SHA-256哈希函数是⽆冲突的并且是标准的国家科学技术研究院（NIST）推荐，我们使⽤它来减少冲突并增强我们的哈希表以获得更好的性能和效率。</li></ol><p>我们开发了⼀个轻量级的客⼾端应⽤程序和服务器应⽤程序（服务器应⽤程序）来评估与我们系统接⼝的真实⽐特币核⼼服务器的吞吐量性能。对于发送的 5000 个请求，我们的结果显⽰显着提⾼了 103倍与从主区块链响应数据时相比，当所有请求在FPGA上发生缓存命中时（FPGA上的命中率为100%）。当FPGA和Redis缓存都发生缓存命中时，FPGA上的命中率低于100%，Redis将系统性能提高多大4.09倍与仅使用FPGA缓存时相比。我们也得到了1.3倍散列执行的性能提升，通过自定义SHA-256散列核心加速。此外，我们的系统使用小功率和FPGA工作区利用率。</p><p>缓存系统是安全的，因为它不直接连接到客⼾端和互联⽹。它仅由服务器 应⽤程序在内部访问。可以在托管客⼾端访问的服务器应⽤程序的主区块链 服务器中应⽤ TSL/SSL 和⾝份验证等安全措施。此外，Redis 和 FPGA 缓存 不⽀持 NoSQL 注⼊。Redis还允许禁用或重命名这些命令（可能被攻击者滥用）。Redis还具有内部授权功能，可以限制对服务器应⽤程序的访问以提⾼安全性。Redis Enterprise 是基于云的 Redis 替代⽅案，如果需要，可⽤于⾼级安全功能。为了获得额外的访问安全性，服务器应⽤程序和缓存系统之间也可以使⽤内部防⽕墙，以保证仅访问服务器应⽤程序。私有区块链可以直接在区块链服务器上申请访问授权，也可以使⽤外部防⽕墙进⾏客⼾端访问控制。</p><p>我们的贡献总结如下：</p><ul><li>我们调查区块链中的性能瓶颈。</li><li>我们设计并实现了⼀个⾼效、⾼性能的分布式混合 NoSQL FPGA-Redis 缓存系统，⽤于提⾼区块链应⽤程序的可扩展性和吞吐量。系统缓存不同的区 块链数据类型，提供⾼命中率、⾼性能、持久性、复制和冗余。</li><li>我们采⽤混合缓存包含策略来优化 FPGA 的有限内存（包含缓存⽤于频繁请求，不包含⽤于不频繁和⼤数据请求）。</li><li>我们为区块链设计并实现了⼀个⾃定义的 SHA-256 哈希核⼼，以减少哈希冲突并节省哈希执⾏，从⽽实现⾼效的哈希表和更好的性能。</li><li>我们构建了轻量级客⼾端和服务器应⽤程序以及 Curl API、Jansson API 和Hiredis 客⼾端来连接实时⽐特币区块链和 Redis 服务器。我们的绩效评估结果显⽰出显着的进步。</li></ul><h1 id=三背景>三、背景<a class=anchorjs-link href=#%e4%b8%89%e8%83%8c%e6%99%af></a></h1><h2 id=31-区块链结构>3.1 区块链结构<a class=anchorjs-link href=#31-%e5%8c%ba%e5%9d%97%e9%93%be%e7%bb%93%e6%9e%84></a></h2><p>区块链是连续和互连的数据块的分布式记录（数据库），由密码学保护（⽤于数据完整性和安全性）以防⽌篡改。区块链由区块链⽹络的共识 管理。根据共识协议添加新块。区块链⽀持加密货币（例如⽐特币）和许多其他应⽤程序。省去中央机关和中介机构，实现⾃治。</p><p>相同的区块链副本在⽆数联⽹计算机（完整节点）上存储和更新。这些块相互连接，使得每个块包含其前⼀个块的哈希。因此，区块哈希会随着区块内容的任何修改⽽变化；检测到更改是因为新散列不同于已经存储在下⼀个块中以及⽹络中其他 计算机上的散列。为了使攻击者成功修改数据，他必须修改受影响计算机和所有其他计算机上的所有先前块。因此，数据的修改是不可⾏的，这提供了区块链的安全性。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/3754273799.png data-action=zoom alt class=lazyload></a></figure></p><p>图1显⽰了由区块头和每个区块中的交易数据组成的⽐特币区块链的结构。标头由⼏个项⽬组成，例如前⼀个块的哈希、时间戳、交易的 Merkle根、nonce 和 nBits。交易数据包含区块中所有交易的哈希值。</p><h2 id=32-区块链的重要性和应用>3.2 区块链的重要性和应用<a class=anchorjs-link href=#32-%e5%8c%ba%e5%9d%97%e9%93%be%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7%e5%92%8c%e5%ba%94%e7%94%a8></a></h2><p>区块链之所以有⽤是因为它的重要特性。英国政府办公室的报告披露，使⽤区块链可以保护数据记录、降低成本并提供交易透明度。⼀些有趣的区块链功能和好处包括其分布式和去中⼼化功能，可防⽌数据丢失并消除中介 机构和中央机构。数据完整性和安全功能可保护区块链数据免受篡改。因此，使⽤区块链提供了数据安全性、匿名性、成本节约、速度、效率、隐私透明度、可追溯性和其他好处。它消除了与中央机构和中介机构相关的所有问题。例如，区块链在⽤于国际交易时，尤其是在银⾏中，将缩短交易结算 时间。这些区块链的好处使它在加密货币以外的⼏个领域都⾮常有⽤。</p><p>随着⼈们意识到区块链的好处，许多区块链应⽤程序应运⽽⽣。这些应⽤程序可⽤于加密货币、智能合约、银⾏、证券交易所营销、保险、医疗保健 管理、知识产权、⾝份管理、⼟地登记、能源和⽂件盖章。其他应⽤在投票系统、DNS 服务、供应链、物联⽹、建筑管理、建筑服务、信任管理和其他领域。</p><p>区块链的突破以它在 IBM 等⼏家公司和乔治亚州等国家的⼴泛采⽤为标志。NAS-DAQ、Augur、Coinsetters 和Bitshares 使⽤区块链进⾏交易和股票营销。Stampery、Ascribe 和 Microsoft 使⽤区块链认证电⼦邮件和⽂档。Everledger 使⽤区块链记录钻⽯证书。爱沙尼亚将其 100 万条医疗记录存储在区块链上。Healthbank、Gem 和 Hyperledger ⼀直 在将区块链⽤于数据访问和假药保护等健康服务。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/776409672.png data-action=zoom alt class=lazyload></a></figure></p><h2 id=33-区块链中的密码学概念>3.3 区块链中的密码学概念<a class=anchorjs-link href=#33-%e5%8c%ba%e5%9d%97%e9%93%be%e4%b8%ad%e7%9a%84%e5%af%86%e7%a0%81%e5%ad%a6%e6%a6%82%e5%bf%b5></a></h2><p>区块链技术设计的优点之⼀是如何将多个已建⽴的加密概念与共识协议结合在⼀起。哈希函数、数字签名和默克尔树⽤于区块链。</p><p>安全散列算法 SHA-256 ⽤于⼤多数区块链系统中，⽤于计算块和交易散列以及地址创建。在⼯作量证明共识中，矿⼯（区块创建者）重复计算区块头的SHA-256哈希值，直到他们获得所需的哈希值（⼩于区块头中的 nBit值）才能使他们的区块有效。交易经过哈希处理，消息摘要⽤于创建交易的 数字签名。椭圆曲线数字签名算法（ECDSA）⽤于签署和验证交易。</p><p>为了创建区块链地址，使⽤椭圆曲线密码学 (ECC) ⽣成密钥对。在⽐特币和⼤多数区块链应⽤程序中，RACE Integrity Primitives Evaluation Message Digest (RIPEMD160) 散列对⽣成的公钥的 SHA256 散列执⾏，以⽣成 160 位输出。该输出附加了⼀个校验和和⼀个1字节的版本号，⽤于进⼀ 步转换为 base58 编码，这是最终的区块链地址。</p><p>在区块头中，Merkle根是代表区块中所有交易的单个哈希值。它是通过构建所有交易的默克尔树获得的。图 2 以只有四个交易的区块的默克尔树为例。⼀对交易哈希被重复哈希，直到它们减少到单个哈希结果。这个结果就 是默克尔树顶部的默克尔根。任何交易的任何变化都会改变 Merkle 根，因此，区块头会发⽣变化，从⽽导致检测到修改。</p><h2 id=34-redis和nosql数据库系统>3.4 Redis和NoSQL数据库系统<a class=anchorjs-link href=#34-redis%e5%92%8cnosql%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f></a></h2><p>NoSQL（Not only SQL）数据库是⼀种⾮关系型数据库系统，其中键（索引）映射到数据结构（例如字符串、列表、数组），⽽不需要表或模式。它通常是⼀个键值存储 (KVS)，其中每个值都使⽤指定的唯⼀键或索 引来存储和检索。⽬前有超过 225 个 NoSQL 数据库，包括内存数据库（其中 Redis 和 Memcached ⽐较突出）以及 MongoDB 等磁盘数据库。NoSQL数据库⽐关系数据库提供更⾼的吞吐量性能、更低的延迟、⾼可扩展性、分 布式架构、可⽤性、更低的成本和更⼤的灵活性 。⼀些流⾏的 Web服务使⽤ NoSQL KVS 进⾏⾼性能缓存和数据存储。Facebook、维基百科、LiveJournal、Flickr、WordPress 和 Mixi 正在使⽤ Memcached。Redis 被Twitter、Yahoo!、Instagram、Github、阿⾥巴巴、Snapchat、Coinbase、StackOverflow、Craigslist 和 Flickr ⼴泛使⽤。</p><p>Redis 代表 Remote Dictionary Server 是⼀种⾼性能、开源、远程内存 数据结构存储（BSD 许可），它提供持久性（通过写⼊磁盘）、复制（使⽤主/从实现⾼读取性能）、健壮性和客⼾端分⽚（⽤于⾼写⼊性能）。Redis不仅⽤作缓存，还⽤作主要或辅助数据存储的数据库以及消息代理。它将键 映射到在⼤多数其他 NoSQL 数据库中不受⽀持的五种不同数据结构类型（字符串、集合、列表、哈希和排序集）中的所选数据结构。</p><p>Redis ⽀持的五种不同数据结构类型及其其他特性使 Redis ⽐⼤多数其他NoSQL 数据库（如 memcached（仅⽤作缓存））适⽤于更⼴泛的应⽤程序。Redis 与其对应的部分相⽐提供了更多的优势，现在它已经⾮常成熟，⽀持每秒数百 GB 的数据和数百万个请求。简⽽⾔之，当需要低延迟、跨平台存储和持久性时，Redis 是最⼴泛使⽤的。尽管 Redis 实现了与Memcached 相似或更好的性能（取决于系统），但Redis⽐ Memcached更有优势，并且在⽀持不同的数据结构、更好的驱逐策略、复制、更好的持久性和更好的事务控制⽅⾯更强⼤。</p><h2 id=35-相关工作>3.5 相关工作<a class=anchorjs-link href=#35-%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c></a></h2><p>尽管可扩展性和吞吐量问题是区块链中的⼤问题，但它们的研究较少。闪电⽹络，分⽚⽅法，信任链 和侧链被提出来提⾼区块链的可扩展性和吞吐量。这些⽅法旨在增加区块链每秒的交易数量（写⼊性能）。相⽐之下，我们的⽬标是提⾼区块链数据检索性能（读取性能）。布鲁斯提议通过引⼊⼀个只存储账⼾余额的新数据库来删除他的Cryptonite 加密货币中旧的、⽤过的交易数据。尽管这种⽅法可能适⽤于加密货币，但是，它可能不适合其他区块链应⽤程序，例如也保留旧记录的医疗保健。</p><p>使⽤ FPGA 上的 Memcached 已经实现了⼏个⾮区块链 Web 缓存。伊斯特万、阿隆索、布洛特和维瑟斯提出了⼀种新颖的 FPGA 键值存储(KVS) 哈希表架构，具有⾼达 10Gbps 的处理能⼒。福⽥等⼈提出了⼀ 个⽤于 Web 服务器的 FPGA NIC Memcached。拉⽡萨尼等⼈为 CPU Memcached 实现了⼀个 FPGA 在线加速器，以实现更好的性能。其他作品 包括 Chalamasetti 和Tokusashi 。相⽐之下，这些作品对于Web 缓存来说是通⽤的（在设计上）。我们优化我们的⼯作，以使⽤混合（多级）FPGA-Redis 缓存和 SHA-256 哈希来实现区块链数据的⾼效⾼性能缓存，以获得更好的性能。我们使⽤ Redis 作为我们的软件缓存，因为它优于他们使⽤的 Memcached。</p><p>Sakikabara 等⼈提出了⼀种专注于简化⽀付验证节点（SPV）的 区块链FPGA硬件缓存系统，当缓存命中FPGA时，平均吞吐量提⾼了1.97倍。他们使⽤直接映射缓存组织，他们系统的内存访问的⾼延迟导致他们在访问内存时停⽌接收数据包。他们⽤前缀区块链数据（⽽不是真正的完整区块链节点）轻轻填充了⼀些 RAM 内存，并实施了⼀个软件来根据请求检索数据。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/3692030190.png data-action=zoom alt class=lazyload></a></figure></p><p>相⽐之下，我们的系统使⽤连接到实时完整区块链节点的混合（多级）FPGA-Redis 缓存。Redis 的加⼊是为了改善 FPGA 内存有限的缺点，因此通过响应 FPGA 上丢失的请求⽽不是从具有更⾼访问延迟的主区块链获取响应来提⾼系统性能，如图 3所示。 Redis成熟，开源，具有更好的性能和良好的测试。我们使⽤ 4 路集关联缓存策略和⾃定义SHA-256 散列，以降低散列冲突率并避免他们使⽤的直接映射的⾼冲突未命中问题。我们还探索并使⽤了流⽔线数据流架构以及具有更宽宽度的⾜够队 列来实现⾼性能，⽽不会像他们的情况那样在访问内存时停⽌数据包的接收。我们的系统旨在使⽤我们的⾃定义 SHA-256 哈希核⼼专⻔针对区块链，以提⾼效率和更好的性能，同时他们的系统也是通⽤的。当缓存命中仅针对所有请求时，我们最终实现了 103 倍的更⾼吞吐量提升，而当 FPGA 上的某些请求未命中缓存时，性能提升为1.97倍。</p><p>在我们的论⽂中 ，我们提出了仅 FPGA 的缓存系统。然⽽，由于FPGA上的内存有限，很难在FPGA上达到100%的命中率，⽽且FPGA上的未命中率也越来越⾼。当⼀些请求在 FPGA 上缓存未命中时，由于从主存储器中的主区块链获取请求数据的⾼延迟，整个系统的性能会下降，如图3中虚线所⽰。</p><p>本⽂介绍的混合（多级）FPGA-Redis 系统是其中 Redis 缓存被合并为 FPGA 之外的另⼀个缓存层，如图所示：1. Redis 与 FPGA 协同⼯作，以改善 FPGA 有限内存的缺点，并在 FPGA 发⽣缓存未命中时提⾼性能。FPGA 处理⽹络处理，从⽽降低软件 Redis 缓存的功耗和资源消耗。另⼀⽅⾯，Redis 通过响应 FPGA 上发⽣缓存未命中的请求来补充 FPGA 的低内存容量。当 FPGA 上发⽣缓存未命中时，对丢失请求的响应现在由 Redis 响应，⽽不是主内存中的主区块链。由于 Redis ⽐主存更快，因此整体系统性能得 到了提⾼。我们只在 FPGA 和 Redis 缓存（包括缓存）上缓存频繁的请求（例如块头）。不频繁和⼤数据请求只缓存在 Redis 上（⾮包容性缓存），以优化 FPGA 的内存容量。提升⾼达 4.09× 与 FPGA 仅缓存在 在 FPGA上的命中率通常低于 100%。 表格1 是相关⼯作的总结。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/625963980.png data-action=zoom alt class=lazyload></a></figure></p><h1 id=四区块链的性能瓶颈>四、区块链的性能瓶颈<a class=anchorjs-link href=#%e5%9b%9b%e5%8c%ba%e5%9d%97%e9%93%be%e7%9a%84%e6%80%a7%e8%83%bd%e7%93%b6%e9%a2%88></a></h1><p>区块链中最⼤的性能问题是可扩展性（延迟和吞吐量）问题。就区块链写⼊性能⽽⾔，延迟或区块时间是将新区块添加到区块链中所花费的时间。吞吐量是处理的事务数每秒。关于区块链服务器的读取性能，延迟是指从区块链请求（查询）发送 到收到响应所花费的时间。此上下⽂中的吞吐量是每秒处理的查询（请求）数。延迟越短（吞吐量越⾼），系统性能就越好。在许多⽤例中使⽤ NoSQL缓存改善了 Web 服务器的⾼延迟。</p><p>区块链可扩展性问题阻碍了区块链技术在许多领域和公司中的全⾯采⽤。它们来⾃两个⽅⾯：</p><ol><li><p><strong>块间隔和块大小</strong>：</p><p>由于挖掘过程、交易验证和⽹络延迟，将新块添加到主区块链需要时间。这段时间较⻓导致交易速度较低。例如，在⽐特币中，平均每 10 分钟添加⼀个新块（限制为 1 MB）。⽐特币和以太坊通常每秒分别处理 4 和 20 笔交易。与 Visa 在⾼峰时间每秒处理多达 56000 笔交易的速度相⽐，这个速度要 低得多。为了改善这个问题，可以降低挖掘难度，以便更快地添加块。但是，这可能会影响系统的安全性。或者，可以增加块⼤⼩以增加吞吐量。但是，这反过来也会增加块传播延迟，并且还可能对系统的安全性产⽣影响。</p><p>已经提出了⼀些建议来修改共识协议以提⾼区块链的可扩展性。Bitcoin-NG 提议将⽐特币活动划分（分⽚）为两个阶段，即领导者选择和交易序列化。在这个协议中，有关键块（⽤于领导选举）和微块（包含实际交易）。平均每 10 分钟选举⼀次新的领导者，他在其任期（纪元）内签署并创建微区块，这些微区块作为区块进⼊主区块链，⽆需任何⼯作证明。使⽤这种⽅法，可以处理更多的事务，⽽不会对安全性造成太⼤影响。</p><p>⾟波林斯基和佐哈尔提出了GHOST 规则，以⽀持⽐特币在⾼吞吐量运⾏时防⽌双花攻击。他们观察到，如果⽐特币要以⾼吞吐量运⾏，即使交易被接受，较弱的攻击者也可以逆转交易。GHOST 规则适⽤于分叉，并建议选择具有⼦树的链，该链与⽐特币中选择的最⻓链不同，其⼯作量更⼤。这也确保了矿⼯之间的公平。Luu等⼈提出了开放区块链 (ELASTICO) 的 安全分⽚协议，该协议将采矿⽹络划分为均匀分布的组（分⽚），每个组（分⽚）处理特定的交易集，以加快交易处理速度。其他区块链可扩展性提 案包括 Li ，Gencer、lightning network，Trustchain和Sidechain 。然⽽，这些提议尚未在⽐特币中完全实施，因为它们可能需要进⼀步的评估和试
验。</p></li><li><p><strong>区块链规模</strong>：</p><p>随着新区块的定期添加，区块链规模会随着时间的推移⽽变得巨⼤。截⾄2019 年 11 ⽉，⽐特币区块链⼤⼩超过249GB，这种巨⼤的区块链规模带来了低数据读取性能和存储问题，构成了另⼀个可扩展性威胁。布鲁斯提出了在他的名为 Cryptonite 的新加密货币中使⽤的迷你区块链⽅案。在此⽅案中，旧交易从区块链中删除，仅保留交易标头。引⼊了另⼀个数据库来保存⽤⼾的未使⽤输出和帐⼾余额。除了该⽅案可能带来的安全挑战外，该⽅案可能不适合⾮加密货币区块 链应⽤程序，例如始终保存健康记录的医疗保健管理。</p><p>巨⼤的区块链规模是导致区块链数据请求的⾼延迟影响区块链服务器和应 ⽤程序性能的因素之⼀。区块链数据存储在主内存中，与将数据存储在RAM内存中的 NoSQL 缓存相⽐，主内存具有更⾼的访问延迟。Twitter 和Facebook 等许多 Web 服务都使⽤软件 NoSQL 缓存（例如 Memcached 和Redis）来在访问其⼤数据时提供低延迟。这种做法扩展了他们的系统并节省了成本。当在 FPGA 上实现 NoSQL 缓存时获得了更好的性能和更低的功耗，但是这种硬件缓存遭受了 FPGA 有限内存的挫折。因此，提出了FPGA-Redis 混合 NoSQL 缓存系统，以提供更低的访问延迟并提⾼服务器的 吞吐量性能。</p></li></ol><h1 id=五方法与架构>五、方法与架构<a class=anchorjs-link href=#%e4%ba%94%e6%96%b9%e6%b3%95%e4%b8%8e%e6%9e%b6%e6%9e%84></a></h1><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/1063593238.png data-action=zoom alt class=lazyload></a></figure></p><h2 id=51-方法>5.1 方法<a class=anchorjs-link href=#51-%e6%96%b9%e6%b3%95></a></h2><p>我们选择原型制作来开发这个系统。 图 4显⽰系统概览。它由轻量级节点应⽤程序（客⼾端）、全节点区块链服务器、FPGA in-NIC 缓存和 Redis缓存服务器组成。FPGA ⽹卡通过千兆 PCIe 插槽连接到 Redis 服务器，并通过千兆以太⽹连接到区块链服务器。进出 Redis 服务器的流量通过 FPGAb NIC。我们在 FPGA NIC 上实现了总线主控直接内存寻址 (BMD) PCIe 端点和键值存储。在 Redis 服务器中，⼀个 Redis 应⽤程序通过 Hiredis 与 Redis实例通信（Redis 的 C 客⼾端也构建了）。服务器应⽤程序在全节点区块链服务器中开发，⽤于管理来⾃客⼾端的请求。服务器应⽤程序与客⼾端、FPGA-Redis 系统和主区块链进⾏通信。Curl 使⽤ JSON RPC 向 Bitcoind 发送请求，⽽ Jansson 在缓存和转发到客⼾端应⽤程序之前将 JSON 响应解析为字符串。</p><p>混合 NoSQL 缓存系统的描述如下：客⼾端⾸先向区块链服务器发送区块链数据请求。该请求由服务器应⽤程序处理。然后，服务器应⽤程序通过FPGA NIC 从混合缓存系统请求数据。FPGA NIC ⾸先检查请求的数据是否在FPGA 缓存（键值存储）上缓存（发⽣缓存命中）。如果 FPGA 上发⽣缓存命中，则 FPGA 将数据响应到服务器应⽤程序，服务器应⽤程序反过来代表区 块链服务器响应客⼾端。如果在 FPGA 上未找到请求的数据（FPGA 上发⽣缓存未命中），则 FPGA ⽹卡通过在 FPGA 上实现的 PCIe 端点将请求转发到Redis 应⽤程序。现在 Redis 应⽤程序从 Redis 获取请求的数据（如果在Redis上发⽣缓存命中）并通过 NIC 转发到服务器应⽤程序。最后，如果FPGA 和 Redis 都发⽣缓存未命中，则服务器应⽤程序通过向区块链核⼼(Bitcoind) 发送远程过程调⽤ (RPC) 来请求来⾃主区块链（存储在主内存中）的数据。请求的数据最终被发送到客⼾端和 NoSQL 缓存，以针对未来的 请求进⾏缓存。</p><p>我们采⽤了包容性缓存策略（数据缓存在 FPGA 和 Redis 缓存上），只针对频繁请求并实现⾼命中率。不频繁和⼤数据请求仅缓存在Redis（⾮包含缓存策略）。如果⼀个请求以 Redis 为⽬的地（例如块请求），则 NIC 直接将请求转发给 Redis，⽽不检查 FPGA。FPGA NIC 充当Redis 和区块链服务器应⽤程序之间的接⼝。</p><p>另⼀⽅⾯，轻量级客⼾端应⽤程序是⽤ Visual Basic.Net 开发的，⽽服务器应⽤程序是⽤ C 语⾔开发的。NoSQL 键值存储（硬件缓存）由于其⾼性能、低延迟⽽在 FPGA 上⽤ Verilog 实现和简单。我们使⽤ SHA-256 哈希改进的 4 路组关联缓存组织，为 FPGA 键值存储提供⾼效和更好的哈希表。FPGA 上还使⽤了先进先出 (FIFO) 缓存替换策略，因为它的简单性以及在区块链中更频繁地请求最近数据（如确认）的事实。因此，可以⽤缓存中的新数据替换旧数据。另⼀⽅⾯，Redis 使⽤最不常⽤ (LFU) 替换策略。</p><p>在 FPGA 之上添加的 Redis 缓存（使混合 FPGA-Redis NoSQL 缓存）允许系统⽔平扩展以提⾼性能。随着未来服务器负载的增加，可以轻松添加混合缓存的副本，以通过⽔平扩展进⼀步提⾼性能。即使添加 Redis 服务器可能需要购买具有低功耗的低成本商品服务器作为开销。但是，这种开销很⼩，因为与使⽤更强⼤的资源升级区块链服务器（例如系统垂直扩展的情况）相⽐，商品服务器成本低且更具成本效益[18‒24]。商品服务器，例如Dell EMC PowerEdge T40（1 个处理器，4 个内核，71 ⽡）仅售 456 美元⽽使⽤的 Redis 软件是开源和免费的。相⽐之下，垂直扩展需要⼀台价格 可能超过 10,000 美元的功能强⼤的服务器。这种垂直扩展服务器的⽰例是具有 2-4 个处理器、1100 ⽡电源的 Dell PowerEdge R940XA，价格为 10,319⾄ 14649 美元，⼀个强⼤的服务器的垂直扩展 CPU 是⾮常昂贵的。</p><p>总⽽⾔之，提出的混合 FPGA-Redis NoSQL 缓存的优势克服了其较⼩的开销（需要低成本和功率⼤的商品服务器），添加低成本的Redis商品服务器更具成本效益。</p><h2 id=52-系统架构>5.2 系统架构<a class=anchorjs-link href=#52-%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84></a></h2><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/151275570.png data-action=zoom alt class=lazyload></a></figure></p><p>该系统由 FPGA in-NIC 键值存储、Redis 数据库和管理与 FPGA、Redis和主区块链核⼼（在本例中为⽐特币）的连接的服务器应⽤程序组成。我们为 FPGA 使⽤流⽔线、数据流架构。系统架构如图5所示。</p><h3 id=521-服务器应用>5.2.1 服务器应用<a class=anchorjs-link href=#521-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%ba%94%e7%94%a8></a></h3><p>服务器应⽤程序充当系统的⼊⼝点。它接收来⾃客⼾端的请求，然后与FPGA-Redis 缓存系统和主区块链核⼼进⾏通信。根据客⼾端的请求，服务器应⽤程序⾸先检查数据是否被缓存，否则它会从主区块链请求数据。服务器应⽤程序将 FPGA-Redis 缓存系统与客⼾端隔离以确保安全。这种⽅法允许 在区块链服务器中实施安全措施，⽽不会影响缓存系统。⽤ C 语⾔开发的服 务器应⽤程序由 Curl API、Jansson API 和实现其功能的⽅法组成。该应⽤程序通过千兆以太⽹将数据传输到 FPGA NIC，并使⽤ Curl 和 Jansson API与主区块链核⼼对话。Curl API 是⼀个 C 客⼾端，⽤于向 Bitcoind发送 RPC调⽤。</p><h3 id=522-数据包管理器>5.2.2 数据包管理器<a class=anchorjs-link href=#522-%e6%95%b0%e6%8d%ae%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8></a></h3><p>FPGA 通过其数据包管理器内核接收和发送数据包。这个包管理器模块接 收传⼊和传出的数据包并将它们转发到 FPGA、PCIe 或以太⽹。它与 PCIe BMD 核⼼⼀起控制和托管以太⽹核⼼。以太⽹核⼼是通过千兆以太⽹基础设施处理FPGA和服务器应⽤程序之间的双⼯通信的 NIC。因此，它实现了UDP 硬件模块和具有千兆媒体独⽴接⼝ (GMII) 的千兆以太⽹媒体访问控制器(MAC)。MAC 的⼀端连接到 FPGA 板上的 Marvel PHY 芯⽚。从另⼀端，MAC连接到使⽤ AXI-Stream FIFO 与数据包管理器交换数据的 UDP 逻辑。FPGA中的 PCIe 内核是⼀个 PCIe 端点，通过 PCIe gen2 架构以⼤约 7 Gbps 的速度处理与 Redis 应⽤程序的数据交换。PCIe 端点包含时钟元件、接收和写⼊引擎，具有总线主控直接存储器寻址的核⼼功能。</p><h3 id=523-内存控制器>5.2.3 内存控制器<a class=anchorjs-link href=#523-%e5%86%85%e5%ad%98%e6%8e%a7%e5%88%b6%e5%99%a8></a></h3><p>内存控制器内核便于 RAM RW 模块对 DDR3 内存进⾏读写。它由 Xilinx的 Virtex 6 存储器接⼝解决⽅案、iodelay和基础设施模块组成。内存控制器核⼼组件所需的时钟信号由基础架构逻辑⽣成，iodelay 提供延迟。内存接⼝解决⽅案结合了连接到物理 DDR3 内存的控制器和物理层 (PHY)。PHY 处理 存储器的排序和时序。从解决⽅案的另⼀端来看，⽤⼾界⾯逻辑与 RAM RW模块连接以进⾏读取和写⼊操作。在实际写⼊内存之前，内存控制器内核⾸ 先在其写⼊数据 FIFO (wdf) 缓冲区中对数据进⾏排队。</p><h3 id=524-自定义sha-256哈希核心>5.2.4 自定义SHA-256哈希核心<a class=anchorjs-link href=#524-%e8%87%aa%e5%ae%9a%e4%b9%89sha-256%e5%93%88%e5%b8%8c%e6%a0%b8%e5%bf%83></a></h3><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/4251236789.png data-action=zoom alt class=lazyload></a></figure></p><p>⾃定义 SHA-256 散列核⼼（⽤ Verilog HDL 编写）对请求或响应（作为其输⼊）执⾏选择性散列，以计算存储在散列表中并⽤作缓存或检索数据的地址的索引（键）在 FPGA 中。⼀个请求由⼀个 1 字节的标签和⼀个参数(<em>tag</em>+<em>parameter</em>) ⽽响应由标签、参数和请求的数据组成(<em>tag</em>+<em>parameter</em>+<em>value</em>)。标签定义请求类型（例如块头请求的⼗六进制值A0），⽽参数是请求的</p><p>特定数据的标识符。该参数可以是散列值或⾮散列值，例如分别为块散列或块⾼度。值是响应中提供的请求数据。以下是请求和响应的⽰例，以便更好地理解此模块。</p><ol><li><p>区块头请求⽰例：
请求格式：Tag &ldquo;block hash&rdquo;</p><p>要请求创世块的块头，我们发送：</p><p>A0 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26</p><p>其中：标签：A0、参数：00&mldr;1b60a8ce26f（一个hash值）</p></li><li><p>区块响应示例：</p><p>响应格式：tag ‘‘block hash’’ ‘‘value’’</p><p>块响应为：</p><p>b1 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f &ldquo;data&rdquo;</p><p>其中：标签：b1、参数：00&mldr;1b60a8ce26f、值：&ldquo;data&rdquo;</p></li></ol><p>⼀些区块链数据（例如块和交易）由其SHA-256 哈希值标识，⽽另⼀些则由未哈希值（例如块⾼度或交易 ID）标识。这就是为什么有些请求将散列值作为参数（已经散列）⽽有些请求具有未散列参数的主要原因，因为数据标识符⽤作请求/响应参数。例如，请求某个区块的区块头，该区块的哈希值（这是⼀个哈希值，已知）作为参数给出，并且不会被该哈希核再次哈希）。相反，要请求某个区块的区块哈希，区块链中区块的⾼度（未哈希值）作为参数，因此由该哈希核⼼进⾏哈希）。⼀些请求有空值作为参数（例如getblockcount），在这种情况下，只有标签⽤于 SHA-256 散列。</p><p>图6显⽰原始和⾃定义哈希核⼼。在原始哈希核⼼中，输⼊数据始终使⽤SHA-256 核⼼进⾏哈希处理。相⽐之下，⾃定义散列添加了⼀个⽤于选择性散列的控制单元。⾃定义散列核⼼并不总是对输⼊数据进⾏散列，⽽是仅在其参数不是散列值时才散列数据。如果参数已经是散列值，则控制单元将其 直接传递到核⼼的输出⽽不进⾏散列，因为它已经是散列值。这样，我们节省了对已经是哈希值的数据进⾏哈希处理的时间。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/1687001700.png data-action=zoom alt class=lazyload></a></figure></p><p>添加的控制单元接收请求或响应数据作为其输⼊。它提取标签并检查标签的最⾼有效位 (MSB) 是否为“1”，表明该参数已经是⼀个哈希值。如果MSB为1，则参数的第⼀个字节被标记(tag||parameter)直接作为消息摘要传递给⾃定义哈希的输出。如果 MSB 为“0”，则输⼊数据将传递到原始sha-256核⼼，该核⼼对数据进⾏散列并将结果作为消息摘要输出。算法 1 描述了⾃定义散列操作的这个过程。</p><p>哈希核输出的前 24 位被提取为键，键是指向值（请求的数据）的指针存储在我们的哈希表中的索引。值和哈希表都存储在 FPGA 的 DDR3 内存中。我们⾃定义散列核⼼的好处是 (1) 使⽤ SHA-256 减少了冲突并增强了散列表以获得更好的性能，因为 SHA-256 是⽆冲突的并且是⼀个标准。(2) 当参数已经是哈希值时保存哈希执⾏以提⾼性能。</p><h3 id=525-ram读写模块>5.2.5 RAM读写模块<a class=anchorjs-link href=#525-ram%e8%af%bb%e5%86%99%e6%a8%a1%e5%9d%97></a></h3><p>RAM RW 模块通过内存控制器内核促进和协调内存读写。它从哈希核⼼接 收内存地址，并将读取或写⼊命令连同数据和内存地址⼀起提供给内存控制器。对于内存读取，该模块将读取的数据连同其标签和参数⼀起发送到数据包管理器，该数据包管理器决定将数据路由到何处。数据包管理器将请求的 标签参数对与读取的标签参数对进⾏⽐较，如果发现相同，则将数据转发给以太⽹处理程序；否则，请求将转发到 PCIe 处理程序以发送到 Redis 应⽤程序。RAM RW 模块将通过 FIFO 的第⼀个字⽤作其数据队列以获得更好的性能。</p><h1 id=六实施>六、实施<a class=anchorjs-link href=#%e5%85%ad%e5%ae%9e%e6%96%bd></a></h1><p>系统原型在 windows 7 PC 和 ML605 Virtex 6 FPGA 板上实现。FPGA 板 具有 XC6VLX240T-1FFG1156 Virtex-6 FPGA、Micron 512 MB MT4JSF6464HY-1G1 DDR3 SODIMM、Gen2 PCIe（4 通道）和板载 Marvell Alaska 88E1111 千兆以太⽹ PHY 收发器。FPGA 上的所有硬件模块均在Verilog 中实现。通过在 FPGA 上实施适当的时钟缓冲器和延迟来⽣成所需的时钟频率。所有数据队列都是使⽤第⼀个字通过 FIFO 实现的。FIFO 使⽤不同的时钟频率连接以太⽹、PCIe 和内存模块。</p><p>我们使⽤ Xilinx MIG 3.9 IP 内核⽣成器⽣成了内存控制器。对⽣成的 IP内核进⾏了修改，以满⾜ ML605 板在约束和其他功能⽅⾯的要求。RAM RW模块也⽤于通过内存控制器读取和写⼊DDR3 内存。在与系统的其他组件集成之前，内存读写已成功测试和模拟。</p><p>PCIe 和以太⽹核⼼也得到了实施。我们定制了赛灵思 PCIe 总线主控性能演⽰参考设计，以实现性能测量为 7 Gbps 左右的 PCIe BMD 内核。Jungo PCIe 驱动程序API⽤于我们开发的 Redis 应⽤程序中的 PCIe 驱动程序并对其进⾏定制。服务器应⽤程序是在区块链服务器中⽤ C 语⾔开发的。我们在Visual Studio 中构建了Curl API，⽤于通过 JSON RPC 调⽤与⽐特币核⼼守护程序进⾏通信。我们还在 Visual Studio for Windows 操作系统中构建了Jansson 和 Hiredis 客⼾端。Jansson 解析以 JSON 格式接收的区块链数据，同时 Hiredis 客⼾端与同样构建的 Redis 服务器进⾏通信。</p><p>另⼀⽅⾯，轻量级客⼾端应⽤程序也是⽤ Visual Basic 语⾔构建的，使⽤UDP 客⼾端套接字发送和接收数据包。为了同时发送和接收数据包，读取和 写⼊事件是在不同的线程中创建的。服务器应⽤程序和轻量级客⼾端均在具有 12 GB RAM、3.06 GHz Xeon 处理器和 1 TB 内存的 Windows 7 DellPrecision T7500 ⼯作站上实施。整个系统被实施和测试，还评估了系统吞吐 量性能。</p><h1 id=七结果与评价>七、结果与评价<a class=anchorjs-link href=#%e4%b8%83%e7%bb%93%e6%9e%9c%e4%b8%8e%e8%af%84%e4%bb%b7></a></h1><h2 id=71-效果评估>7.1 效果评估<a class=anchorjs-link href=#71-%e6%95%88%e6%9e%9c%e8%af%84%e4%bc%b0></a></h2><p>为了评估系统的性能，系统设置如图 4. 请求是从开发的轻量级客⼾端应⽤程序发送的。我们发送了五种不同类型的 5000 个区块链数据请求。请求的区块链数据是区块头、确认、区块⾼度、时间跨度和默克尔根。我们从区块链 API ⽹站来构建我们的⼯作负载。⼯作负载数据存储在客⼾端应⽤程序中，并被应⽤程序⽤于创建和发送请求。⼯作负载都是读取请求，其⼀般格式(characters)的形式为*‘‘tag parameter’’*。标签字符定义请求类型（例如块头或确认），⽽参数指向请求其数据的特定项⽬（块或交易）。前面给出的请求示例是getblockheader &lsquo;blockhash&rsquo;&rsquo; 标签所在的位置getblockheadere，参数是blockhash块，并且可以更改为请求另一个块的块头。</p><p>5000 个请求在 FPGA 和 Redis 上发送的命中率各不相同。初始请求⾸先发送到预缓存的 FPGA 和 Redis，以便可以为评估设置各种命中/未命中率。我们在 FPGA 和 Redis 上测量了各种未命中率的性能。Redis 上的命中率是FPGA 上发⽣缓存未命中的请求的百分⽐。我们⽐较了有和没有 Redis 缓存 的系统吞吐量。如果在缓存中找到请求的数据，则表⽰在 FPGA 或 Redis 上 发⽣缓存命中，否则发⽣缓存未命中。</p><p>我们使⽤ Visual Studio.Net 框架的秒表类来评估系统的延迟和吞吐量。秒表类使⽤⾼分辨率性能计数器（分辨率为 335 纳秒）来精确测量请求的响 应时间。我们在发送请求时启动秒表，并在收到响应时停⽌它。因此，获得了发送请求和接收其响应之间经过的时钟数。</p><p>为了计算我们使⽤的延迟和吞吐量：</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/2439004115.png data-action=zoom alt class=lazyload></a></figure></p><p>其中：freq 是秒表频率。</p><h2 id=72-结果>7.2 结果<a class=anchorjs-link href=#72-%e7%bb%93%e6%9e%9c></a></h2><p>与我们的系统集成的完整⽐特币区块链节点的吞吐量性能和延迟按照7.1内部进行了评估。初始请求⾸先发送到预缓存的 FPGA 和Redis，以便可以为评估设置各种命中/未命中率。我们在 FPGA 和 Redis上测量了各种未命中率的性能，Redis 上的命中率是 FPGA 上发⽣缓存未命中 的请求的百分⽐。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/3469922437.png data-action=zoom alt class=lazyload></a></figure></p><p>为了展⽰这种多级 FPGA-Redis 系统的优势，我们⾸先评估了仅具有FPGA 缓存（没有 Redis 缓存）的系统，该系统后来使⽤多级FPGA-Redis 缓存进⾏了评估。图 7 仅显⽰了具有 FPGA 缓存的系统的吞吐量性能。在这种情况下，当 FPGA 发⽣缓存未命中时，请求的数据直接来⾃存储在主存储器（硬盘）中的主区块链。在 FPGA上分别以 100% 和 0% 的未命中率获得每秒 91 个请求 (req/s) 和 9381 个请求/s 的吞吐量。因此，提⾼了 103倍当所有请求在 FPGA 上发⽣缓存命中时获得（FPGA 上的未命中率为 0%）。</p><p>尽管有如此⾼的改进，但可以从图 7 由于某些请求在 FPGA 上发⽣缓存未命中，未命中概率增加，吞吐量⼤⼤降低。这种退化是由于从主内存中的主区块链获取数据的⾼延迟。FPGA有限的内存容量也使得存储更多数据以降低丢失率变得困难。</p><p>另⼀⽅⾯，混合 FPGA-Redis 多级系统通过添加 Redis 附加缓存层来改善仅 FPGA 缓存的性能下降，该缓存层在 FPGA 上发⽣缓存未命中时响应请求，⽽不是从主区块链获取请求的数据（存储在主存储器中）。由于 Redis⽐主存更快，因此系统的性能得到了提⾼。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/2461609449.png data-action=zoom alt class=lazyload></a></figure></p><p>多级 FPGA-Redis 缓存系统的评估⽅式与仅 FPGA 缓存系统相同，⽅法是改变 FPGA 上的未命中率。Redis 上的命中率设置为 FPGA 上未找到（发⽣缓存未命中）的请求的百分⽐。当 Redis 也发⽣缓存未命中时，其余请求来⾃主内存，图 8 显⽰吞吐量性能结果。</p><p>可以从图8看出，在 FPGA 上的命中率相同的情况下，与仅 FPGA 缓存相⽐，使⽤多级 FPGA-Redis 缓存可以获得更⾼的吞吐量。例如，FPGA 缓存仅在 10% 的未命中率下获得了 294.73 req/s 的吞吐量。相⽐之下，在 FPGA 上以相同的未命中率 (10%) 的情况下，使⽤多级 FPGA-Redis 100% 缓存获得了 1206 req/s (4.09 倍) req/s 的更⾼吞吐量。这个结果清楚地表明，与仅 FPGA 的系统相⽐，FPGA-Redis 系统提供了 更⾼的吞吐量性能，因为 FPGA 上的⼀些丢失的请求被缓存在⽐主存更快的Redis 上。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/376872896.png data-action=zoom alt class=lazyload></a></figure></p><p>图9测量的是延迟⽽不是吞吐量，还可以看出，与 FPGA 上相同命中率的 FPGA 缓存相⽐，混合 FPGARedis 缓存获得了更低的延迟。这也表明多级 FPGA-Redis 系统通过响应来⾃Redis 缓存的 FPGA 上未找到的请求来提⾼系统性能，从⽽减少延迟。</p><p>从所讨论的所有结果中可以看出，这种 FPGA-Redis混合NoSQL缓存系统⽐仅 FPGA 缓存系统提升了区块链系统的性能。当所有请求在 FPGA 上发⽣缓存命中时，系统性能提升 103倍与根本不使⽤缓存时相⽐。随着命中率从 100% 降低，性能会下降。由于FPGA的内存有限，很难在FPGA上达到100%的命中率。因此，当 FPGA 发⽣缓存未命中（即 FPGA 上 的命中率低于 100%）时，作为另⼀个缓存层添加的 Redis 缓存提⾼了系统的性能。性能提升⾼达 4.09倍Redis 与仅使⽤ FPGA 缓存时相⽐。改进主要 是因为当 FPGA 发⽣缓存未命中时，请求的数据是从 Redis 响应的，而不是从区块链磁盘存储获取。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/445089104.png data-action=zoom alt class=lazyload></a></figure></p><p>当发送带有 SHA-256 哈希参数的请求后，FPGA 上发⽣缓存命中时，我们还评估了由于我们的⾃定义 SHA-256 哈希保存哈希执⾏⽽导致的性能改进。在第⼀种情况下，我们使⽤提供的带有标签的 SHA-256 哈希参数作为哈希表的哈希结果，从⽽节省了实际的哈希执⾏。在第⼆种情况下，实际散列是对第⼀种情况中使⽤的相同数据执⾏的。表 2 显⽰了 1.3 倍的改进，并在执⾏时保存了哈希。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/3489705952.png data-action=zoom alt class=lazyload></a></figure></p><p>此外，使⽤ SHA-256 哈希函数有助于改善前⾯讨论的整体结果。FPGA ⾯积利⽤率在表3结果显⽰⼩⾯积利⽤率。同样使⽤ Xilinx 功耗估算器报告，FPGA 的估算功耗为 7.7 W，这也很⼩。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2022/01/3590325056.png data-action=zoom alt class=lazyload></a></figure></p><p>如表4所示，这个 FPGA-Redis 系统表现出更好的性能。我们的⾃定义 SHA-256 哈希核⼼是我们的⼯作与以前的⼯作之间的⼀个独特的新颖区别。⾃定义 SHA-256 散列核⼼使我们的系统专⻔⽤于⾼效的区块链缓存，并为具有散列参数的请求节省了散列执⾏。使⽤ SHA-256 散列 还可以减少散列表中的冲突，从⽽提⾼整体吞吐量性能。总之，使⽤我们的FPGA-Redis 区块链缓存系统提⾼了区块链服务器的响应性能。因此，该系统能够提⾼区块链应⽤程序的可扩展性和吞吐量。</p><h1 id=八结论>八、结论<a class=anchorjs-link href=#%e5%85%ab%e7%bb%93%e8%ae%ba></a></h1><p>区块链技术因其在⾃治（⽆需中央机构和中介机构）、数据安全、速度、可追溯性、降低成本、效率等⽅⾯的巨⼤优势⽽获得了如此多的关注。它已被多家公司和国家⼴泛采⽤并成功试⽤，然⽽可扩展性问题阻碍了它在⼏个地⽅的全⾯采⽤。Visa 和 Google 等⾮区块链应⽤在可 扩展性和吞吐量⽅⾯的表现优于区块链应⽤。</p><p>由于区块链规模巨⼤，越来越多的区块链轻量级节 点（尤其是物联⽹设备）给全节点区块链服务器带来了如此多的⼯作量，从⽽影响了区块链应⽤ 程序的可扩展性和吞吐量。我们评估了区块链中的性能瓶颈，并提出了⼀种⾼效的⾼性能 FPGA Redis 混合缓存系统，⽤于提⾼区块链应⽤程序的可扩展性和吞吐量。我们还设计并使⽤了定制的 SHA-256 哈希核⼼来减少哈希冲突并提⾼整体性能。</p><p>我们的系统减少了区块链服务器上的⼯作量，这些服务器为许多轻量级节点提供服务，这些节点由于其庞⼤的规模⽽⽆法存储区块链。我们评估了连接到我们系统的真正完整的⽐特币区块链服务器的吞吐量性能。我们的结果显⽰了⾼达 4.09 倍整体性能提升⽐仅使⽤ FPGA 缓存，103倍性能提升当在FPGA 上达到 100% 的命中率时。与之前讨论的⼯作相⽐，这是⼀个显着的改进。该系统还具有较⼩的FPGA利⽤率和功耗。因此，可以推断我们的系统有效地提⾼了区块链应⽤程序的可扩展性和吞吐量。</p><hr style=visibility:hidden><ul class=pager><li class=previous><a href=/icorer_blog/posts/cloudnative_k8s_tcp_upstream_balance/ data-toggle=tooltip data-placement=top title=TCP长连接在K8S环境下的负载均衡分析>Previous<br><span>TCP长连接在K8S环境下的负载均衡分析</span></a></li><li class=next><a href=/icorer_blog/posts/alibaba_cloud_faasnet_serverless_container_solution/ data-toggle=tooltip data-placement=top title=阿里云FAASNET无服务器容器方案>Next<br><span>阿里云FAASNET无服务器容器方案</span></a></li></ul><hr style=visibility:hidden></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5>FEATURED TAGS</h5><div class=tags><a href=/icorer_blog/tags/blockchain/>blockchain</a>
<a href=/icorer_blog/tags/clang/>CLang</a>
<a href=/icorer_blog/tags/cloudnative/>cloudnative</a>
<a href=/icorer_blog/tags/cmake/>Cmake</a>
<a href=/icorer_blog/tags/drand/>drand</a>
<a href=/icorer_blog/tags/epoll/>epoll</a>
<a href=/icorer_blog/tags/fpga/>FPGA</a>
<a href=/icorer_blog/tags/gc/>GC</a>
<a href=/icorer_blog/tags/golang/>GoLang</a>
<a href=/icorer_blog/tags/hackathon/>Hackathon</a>
<a href=/icorer_blog/tags/http2/>HTTP2</a>
<a href=/icorer_blog/tags/http3/>HTTP3</a>
<a href=/icorer_blog/tags/icefiredb/>IceFireDB</a>
<a href=/icorer_blog/tags/k8s/>k8s</a>
<a href=/icorer_blog/tags/kafka/>kafka</a>
<a href=/icorer_blog/tags/linux/>linux</a>
<a href=/icorer_blog/tags/nginx/>Nginx</a>
<a href=/icorer_blog/tags/nosql/>NoSQL</a>
<a href=/icorer_blog/tags/php/>PHP</a>
<a href=/icorer_blog/tags/php-kernel/>php kernel</a>
<a href=/icorer_blog/tags/php%E5%86%85%E6%A0%B8/>PHP内核</a>
<a href=/icorer_blog/tags/quic/>QUIC</a>
<a href=/icorer_blog/tags/redis/>redis</a>
<a href=/icorer_blog/tags/serverless/>serverless</a>
<a href=/icorer_blog/tags/unikernel/>unikernel</a>
<a href=/icorer_blog/tags/wanxiang/>Wanxiang</a>
<a href=/icorer_blog/tags/web3/>web3</a>
<a href=/icorer_blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件</a>
<a href=/icorer_blog/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a>
<a href=/icorer_blog/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/>信息安全</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/>内存数据库</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/>内存泄漏</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/>内核源码</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6/>内核研究</a>
<a href=/icorer_blog/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/>区块链</a>
<a href=/icorer_blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>垃圾回收</a>
<a href=/icorer_blog/tags/%E5%AD%98%E5%82%A8/>存储</a>
<a href=/icorer_blog/tags/%E5%AE%B9%E5%99%A8/>容器</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/>底层开发</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/>底层研究</a>
<a href=/icorer_blog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/>开源项目</a>
<a href=/icorer_blog/tags/%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97/>异构计算</a>
<a href=/icorer_blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a>
<a href=/icorer_blog/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/>性能测试</a>
<a href=/icorer_blog/tags/%E6%8A%80%E6%9C%AF%E7%A7%91%E6%99%AE/>技术科普</a>
<a href=/icorer_blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/>数据库技术</a>
<a href=/icorer_blog/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/>文章翻译</a>
<a href=/icorer_blog/tags/%E6%96%B0%E6%9E%B6%E6%9E%84/>新架构</a>
<a href=/icorer_blog/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/>时序数据库</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/>服务治理</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/>服务网格</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E9%81%A5%E6%B5%8B/>服务遥测</a>
<a href=/icorer_blog/tags/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/>测试报告</a>
<a href=/icorer_blog/tags/%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/>研究报告</a>
<a href=/icorer_blog/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/>缓存技术</a>
<a href=/icorer_blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a>
<a href=/icorer_blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/>虚拟机</a>
<a href=/icorer_blog/tags/%E8%A1%8C%E4%B8%9A%E6%8A%A5%E5%91%8A/>行业报告</a>
<a href=/icorer_blog/tags/%E8%AE%BA%E6%96%87/>论文</a>
<a href=/icorer_blog/tags/%E9%9B%B6%E4%BF%A1%E4%BB%BB/>零信任</a>
<a href=/icorer_blog/tags/%E9%AB%98%E6%80%A7%E8%83%BD/>高性能</a></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=/icorer_blog/index.xml><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/corerman1><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/gitsrc><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 笔迹-工匠之芯 2022</p></div></div></div></footer><script src=/icorer_blog/js/jquery.min.js></script>
<script src=/icorer_blog/js/bootstrap.min.js crossorigin=anonymous></script>
<script src=/icorer_blog/js/hux-blog.min.c4ea77041cd3edbfc8b2622cd887a9a5d8760a4162d14489e36d2a3fa4c90172.js></script>
<script src=/icorer_blog/js/simple-jekyll-search.min.js></script>
<script src=/icorer_blog/js/search.min.7d1445cf07369bca2715d9f63738c16c73a7a2273a95d6729bee561f7e84c6c8.js></script>
<script src=/icorer_blog/zoomjs/zoom.min.js></script></body></html>