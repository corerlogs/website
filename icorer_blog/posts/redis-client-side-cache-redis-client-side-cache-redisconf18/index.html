<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=icon type=image/ico sizes=16x16 href=/icorer_blog/img/favicon.ico><meta property="og:image" content="https://res.cloudinary.com/malloc/image/upload/v1669271757/icorer.com/34047788_pepere.jpg"><title>Redis Client Side Cache - Redis客户端缓存 - RedisConf18 | 笔迹-工匠之芯</title><meta name=author content="LB"><meta name=description content="一. 背景描述客户端缓存是一个有意思的话题，它不是空穴来风的技术，在最新的Redis RC版本已经正式开始着手CSC方案的设计，虽然目前版本的CSC还不能真正的商用，但是市面上也有一些其他公司开始着手试探CSC相关方案的设计与实现。
目标比较有名的模型是两种：
Ben Malec paylocity公司方案 Redis6 RC方案 这两种方案并不是独立的，他们各有各的优势，paylocity公司的方案被redis团队所赞赏，并吸收了一些思路进入Redis RC版本中，Redis RC版本主要是提供了一些server端的协助，但是本质上还是没有完整的CSC方案。
二. RedisConf2018大会 Ben Malec分享这里，我们将阐述RedisConf 2018年的经典分享，这个分享围绕CSC机制的相关设计与实现，并且方案已经被广泛使用在paylocity公司，有很高的的借鉴意义。 Ben Malec的分享主要围绕如何实现一个和Redis缓存同步的本地内存缓存。
首先，我们看一下简单的网站模型，模型图如下：
接着，Ben提出很重要的缓存象限，缓存象限图如下所示：
缓存最好的应用场景就是针对更改少、请求频繁的数据读写场景。
客户端缓存，首先需要面对的问题就是 “缓存数据滞后”
这部分演讲，Ben发散思维了所有Web服务器尝使用的“文件系统观察”功能。
随后，客户端缓存会出现“跨服务器缓存数据不一致”问题。
这种问题并不是只会在不同的机器间出现，还会在同一台机器不同进程中出现。
比如在两台机器针对缓存都设置了相同的TTL生命期，但是由于机器间时间可能不同步，从而造成缓存不一致情况。更坏的情况就是，数据已经更新了，但是客户端缓存没办法及时更新，造成用户请求到旧的数据，如果再多台机器负载的情况下，极有可能出现一会新值、一会旧值得问题，这种飘忽不定的缓存返回会造成用户较差的使用体验。
接下来，Ben提出一个很重要的时间观点，服务器间想在大约相同的时间内更新相关的key，这个大约相同的时间证明这个缓存方案并不一定能够满足分布式强一致，只是在合理的时间范围内数据一致。
接下来，Ben提出第三个缓存问题，“缓存踩踏”问题
这里所说的就是如果自己完全制作一个进程内缓存，有很多需要考虑，比如启动数据加载，数据池的备份，服务器扩容过程，等等问题。
Redis可以提供简单的缓存解决方案。
Redis缓存可以很好地解决缓存一致性问题，也可以解决缓存数据滞后问题，也不会有数据践踏。
但是redis也有一些其他问题，比如每次缓存获取都需要tcp往返通信，虽然redis已经很快了，但是本地内存的访问速度仍然比网络io速度高太多。
这里，Ben提出如果在redis基础上，再增加进程内缓存，效果就会更好了。
针对这种本地缓存方案，首先提出了三个需要做的事情：
解决数据一致性问题 解决数据滞后问题，主要围绕进程内缓存和远程redis之间的滞后问题 不要让网络爆炸，要控制合理的网络通信 借助redis，我们是不是可以更好的实现这个功能呢？
上面这部分讲述了一个问题，如果我们想让机器间的数据保证一致性，如果仅仅通过广播变更的key-value，这将是致命的，因为大量的key-value将引爆网络，还有一个原因就是你广播了key-value数据，并不是所有的节点以后都会使用，这就会造成效率问题，这些问题几乎都是围绕网络，但是还没考虑网络的质量问题，比如网络质量很差的情况下，节点可能收到多组不同的改动，这些改动可能会数据践踏，但是你不知道践踏的顺序，从而造成数据的不一致问题。
因此，我们并不是广播key-value，而是只广播key，但是你也知道redis支持key数据，最大可以达到512MB，就算不是512MB，就算是1kb的数据，我们的网络就能抗住吗，所以简单的广播key是不理智的。
redis集群中采用hash槽位来进行数据分片，那么我们是否可以借鉴这种思路呢？我们不再广播key，而是广播key所计算的hash值，这样如果key的数据多么大，我们都能控制在网络上传输的数据大小。
我们放弃了广播key，而选择同步16bit的key hash槽数据，这样操作的优势明显，首先广播数据的大小被控制了，并且解决了数据一致性问题，我们只是广播hash，并没有广播数据，当某个hash出现了脏数据，它将会在下次访问时被感知并被更新。这个也有一点缺陷需要注意，因为我们借助了hash槽位，所以一个hash slot上会包含很多key，这些key中的一个被更新，则这组hash slot都将失效。
计算遍历所有的 key 吗？命中脏 slots 的话，就删除这个key？但是这样的话相当于对每一个缓存更新操作，客户端都要遍历计算一遍自己所有 key 的 slot，显然是不可接受的。
这里也是采用惰性计算的思想：客户端收到了 slot 更新的广播，只把 slot 存起来，当真正用到在此 slot 中的 key 的时候才去 Redis 更新。那么就会有这样一种情况，slot 中部分 key 更新了，部分 key 没有更新，如何区分开哪些 key 已经在 slot 更新之后更新过了呢？这里只要记一下 slot 更新的 timestamp 就可以，每一个 key-value 也带有一个 timestamp 属性。如果 key 的 timestamp 早于 slot 的 timestamp，那 key 就是需要更新的；更新之后 key 的 timestamp 就晚于 slot 的 timestamp 了。下次可以直接用。"><meta name=keywords content="blog,博客,工匠之芯,笔迹-工匠之芯"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis Client Side Cache - Redis客户端缓存 - RedisConf18"><meta name=twitter:description content="一. 背景描述客户端缓存是一个有意思的话题，它不是空穴来风的技术，在最新的Redis RC版本已经正式开始着手CSC方案的设计，虽然目前版本的CSC还不能真正的商用，但是市面上也有一些其他公司开始着手试探CSC相关方案的设计与实现。
目标比较有名的模型是两种：
Ben Malec paylocity公司方案 Redis6 RC方案 这两种方案并不是独立的，他们各有各的优势，paylocity公司的方案被redis团队所赞赏，并吸收了一些思路进入Redis RC版本中，Redis RC版本主要是提供了一些server端的协助，但是本质上还是没有完整的CSC方案。
二. RedisConf2018大会 Ben Malec分享这里，我们将阐述RedisConf 2018年的经典分享，这个分享围绕CSC机制的相关设计与实现，并且方案已经被广泛使用在paylocity公司，有很高的的借鉴意义。 Ben Malec的分享主要围绕如何实现一个和Redis缓存同步的本地内存缓存。
首先，我们看一下简单的网站模型，模型图如下：
接着，Ben提出很重要的缓存象限，缓存象限图如下所示：
缓存最好的应用场景就是针对更改少、请求频繁的数据读写场景。
客户端缓存，首先需要面对的问题就是 “缓存数据滞后”
这部分演讲，Ben发散思维了所有Web服务器尝使用的“文件系统观察”功能。
随后，客户端缓存会出现“跨服务器缓存数据不一致”问题。
这种问题并不是只会在不同的机器间出现，还会在同一台机器不同进程中出现。
比如在两台机器针对缓存都设置了相同的TTL生命期，但是由于机器间时间可能不同步，从而造成缓存不一致情况。更坏的情况就是，数据已经更新了，但是客户端缓存没办法及时更新，造成用户请求到旧的数据，如果再多台机器负载的情况下，极有可能出现一会新值、一会旧值得问题，这种飘忽不定的缓存返回会造成用户较差的使用体验。
接下来，Ben提出一个很重要的时间观点，服务器间想在大约相同的时间内更新相关的key，这个大约相同的时间证明这个缓存方案并不一定能够满足分布式强一致，只是在合理的时间范围内数据一致。
接下来，Ben提出第三个缓存问题，“缓存踩踏”问题
这里所说的就是如果自己完全制作一个进程内缓存，有很多需要考虑，比如启动数据加载，数据池的备份，服务器扩容过程，等等问题。
Redis可以提供简单的缓存解决方案。
Redis缓存可以很好地解决缓存一致性问题，也可以解决缓存数据滞后问题，也不会有数据践踏。
但是redis也有一些其他问题，比如每次缓存获取都需要tcp往返通信，虽然redis已经很快了，但是本地内存的访问速度仍然比网络io速度高太多。
这里，Ben提出如果在redis基础上，再增加进程内缓存，效果就会更好了。
针对这种本地缓存方案，首先提出了三个需要做的事情：
解决数据一致性问题 解决数据滞后问题，主要围绕进程内缓存和远程redis之间的滞后问题 不要让网络爆炸，要控制合理的网络通信 借助redis，我们是不是可以更好的实现这个功能呢？
上面这部分讲述了一个问题，如果我们想让机器间的数据保证一致性，如果仅仅通过广播变更的key-value，这将是致命的，因为大量的key-value将引爆网络，还有一个原因就是你广播了key-value数据，并不是所有的节点以后都会使用，这就会造成效率问题，这些问题几乎都是围绕网络，但是还没考虑网络的质量问题，比如网络质量很差的情况下，节点可能收到多组不同的改动，这些改动可能会数据践踏，但是你不知道践踏的顺序，从而造成数据的不一致问题。
因此，我们并不是广播key-value，而是只广播key，但是你也知道redis支持key数据，最大可以达到512MB，就算不是512MB，就算是1kb的数据，我们的网络就能抗住吗，所以简单的广播key是不理智的。
redis集群中采用hash槽位来进行数据分片，那么我们是否可以借鉴这种思路呢？我们不再广播key，而是广播key所计算的hash值，这样如果key的数据多么大，我们都能控制在网络上传输的数据大小。
我们放弃了广播key，而选择同步16bit的key hash槽数据，这样操作的优势明显，首先广播数据的大小被控制了，并且解决了数据一致性问题，我们只是广播hash，并没有广播数据，当某个hash出现了脏数据，它将会在下次访问时被感知并被更新。这个也有一点缺陷需要注意，因为我们借助了hash槽位，所以一个hash slot上会包含很多key，这些key中的一个被更新，则这组hash slot都将失效。
计算遍历所有的 key 吗？命中脏 slots 的话，就删除这个key？但是这样的话相当于对每一个缓存更新操作，客户端都要遍历计算一遍自己所有 key 的 slot，显然是不可接受的。
这里也是采用惰性计算的思想：客户端收到了 slot 更新的广播，只把 slot 存起来，当真正用到在此 slot 中的 key 的时候才去 Redis 更新。那么就会有这样一种情况，slot 中部分 key 更新了，部分 key 没有更新，如何区分开哪些 key 已经在 slot 更新之后更新过了呢？这里只要记一下 slot 更新的 timestamp 就可以，每一个 key-value 也带有一个 timestamp 属性。如果 key 的 timestamp 早于 slot 的 timestamp，那 key 就是需要更新的；更新之后 key 的 timestamp 就晚于 slot 的 timestamp 了。下次可以直接用。"><meta property="og:title" content="Redis Client Side Cache - Redis客户端缓存 - RedisConf18"><meta property="og:description" content="一. 背景描述客户端缓存是一个有意思的话题，它不是空穴来风的技术，在最新的Redis RC版本已经正式开始着手CSC方案的设计，虽然目前版本的CSC还不能真正的商用，但是市面上也有一些其他公司开始着手试探CSC相关方案的设计与实现。
目标比较有名的模型是两种：
Ben Malec paylocity公司方案 Redis6 RC方案 这两种方案并不是独立的，他们各有各的优势，paylocity公司的方案被redis团队所赞赏，并吸收了一些思路进入Redis RC版本中，Redis RC版本主要是提供了一些server端的协助，但是本质上还是没有完整的CSC方案。
二. RedisConf2018大会 Ben Malec分享这里，我们将阐述RedisConf 2018年的经典分享，这个分享围绕CSC机制的相关设计与实现，并且方案已经被广泛使用在paylocity公司，有很高的的借鉴意义。 Ben Malec的分享主要围绕如何实现一个和Redis缓存同步的本地内存缓存。
首先，我们看一下简单的网站模型，模型图如下：
接着，Ben提出很重要的缓存象限，缓存象限图如下所示：
缓存最好的应用场景就是针对更改少、请求频繁的数据读写场景。
客户端缓存，首先需要面对的问题就是 “缓存数据滞后”
这部分演讲，Ben发散思维了所有Web服务器尝使用的“文件系统观察”功能。
随后，客户端缓存会出现“跨服务器缓存数据不一致”问题。
这种问题并不是只会在不同的机器间出现，还会在同一台机器不同进程中出现。
比如在两台机器针对缓存都设置了相同的TTL生命期，但是由于机器间时间可能不同步，从而造成缓存不一致情况。更坏的情况就是，数据已经更新了，但是客户端缓存没办法及时更新，造成用户请求到旧的数据，如果再多台机器负载的情况下，极有可能出现一会新值、一会旧值得问题，这种飘忽不定的缓存返回会造成用户较差的使用体验。
接下来，Ben提出一个很重要的时间观点，服务器间想在大约相同的时间内更新相关的key，这个大约相同的时间证明这个缓存方案并不一定能够满足分布式强一致，只是在合理的时间范围内数据一致。
接下来，Ben提出第三个缓存问题，“缓存踩踏”问题
这里所说的就是如果自己完全制作一个进程内缓存，有很多需要考虑，比如启动数据加载，数据池的备份，服务器扩容过程，等等问题。
Redis可以提供简单的缓存解决方案。
Redis缓存可以很好地解决缓存一致性问题，也可以解决缓存数据滞后问题，也不会有数据践踏。
但是redis也有一些其他问题，比如每次缓存获取都需要tcp往返通信，虽然redis已经很快了，但是本地内存的访问速度仍然比网络io速度高太多。
这里，Ben提出如果在redis基础上，再增加进程内缓存，效果就会更好了。
针对这种本地缓存方案，首先提出了三个需要做的事情：
解决数据一致性问题 解决数据滞后问题，主要围绕进程内缓存和远程redis之间的滞后问题 不要让网络爆炸，要控制合理的网络通信 借助redis，我们是不是可以更好的实现这个功能呢？
上面这部分讲述了一个问题，如果我们想让机器间的数据保证一致性，如果仅仅通过广播变更的key-value，这将是致命的，因为大量的key-value将引爆网络，还有一个原因就是你广播了key-value数据，并不是所有的节点以后都会使用，这就会造成效率问题，这些问题几乎都是围绕网络，但是还没考虑网络的质量问题，比如网络质量很差的情况下，节点可能收到多组不同的改动，这些改动可能会数据践踏，但是你不知道践踏的顺序，从而造成数据的不一致问题。
因此，我们并不是广播key-value，而是只广播key，但是你也知道redis支持key数据，最大可以达到512MB，就算不是512MB，就算是1kb的数据，我们的网络就能抗住吗，所以简单的广播key是不理智的。
redis集群中采用hash槽位来进行数据分片，那么我们是否可以借鉴这种思路呢？我们不再广播key，而是广播key所计算的hash值，这样如果key的数据多么大，我们都能控制在网络上传输的数据大小。
我们放弃了广播key，而选择同步16bit的key hash槽数据，这样操作的优势明显，首先广播数据的大小被控制了，并且解决了数据一致性问题，我们只是广播hash，并没有广播数据，当某个hash出现了脏数据，它将会在下次访问时被感知并被更新。这个也有一点缺陷需要注意，因为我们借助了hash槽位，所以一个hash slot上会包含很多key，这些key中的一个被更新，则这组hash slot都将失效。
计算遍历所有的 key 吗？命中脏 slots 的话，就删除这个key？但是这样的话相当于对每一个缓存更新操作，客户端都要遍历计算一遍自己所有 key 的 slot，显然是不可接受的。
这里也是采用惰性计算的思想：客户端收到了 slot 更新的广播，只把 slot 存起来，当真正用到在此 slot 中的 key 的时候才去 Redis 更新。那么就会有这样一种情况，slot 中部分 key 更新了，部分 key 没有更新，如何区分开哪些 key 已经在 slot 更新之后更新过了呢？这里只要记一下 slot 更新的 timestamp 就可以，每一个 key-value 也带有一个 timestamp 属性。如果 key 的 timestamp 早于 slot 的 timestamp，那 key 就是需要更新的；更新之后 key 的 timestamp 就晚于 slot 的 timestamp 了。下次可以直接用。"><meta property="og:type" content="article"><meta property="og:url" content="https://icorer.com/icorer_blog/posts/redis-client-side-cache-redis-client-side-cache-redisconf18/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-15T16:22:18+08:00"><meta property="article:modified_time" content="2020-03-15T16:22:18+08:00"><link rel=stylesheet href=/icorer_blog/css/bootstrap.min.css crossorigin=anonymous><link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/icorer_blog/sass/main.css><link rel=stylesheet href=/icorer_blog/zoomjs/zoom.min.css><script src=/icorer_blog/js/lazysizes.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/icorer_blog/apple-touch-icon.png><link rel=manifest href=/icorer_blog/site.webmanifest></head><body><nav class="navbar navbar-default navbar-custom navbar-fixed-top invert"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://icorer.com/icorer_blog/>笔迹-工匠之芯</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=https://icorer.com title=工匠之芯>工匠之芯</a></li><li><a href=https://icorer.com/icorer_about title=关于我>关于我</a></li><li><a href=https://github.com/gitsrc title=开源仓库>开源仓库</a></li><li class=search-icon><a href=javascript:void(0)><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse"),__HuxNav__={close:function(){$navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)},open:function(){$collapse.style.height="auto",$navbar.className+=" in"}};$toggle.addEventListener("click",function(){$navbar.className.indexOf("in")>0?__HuxNav__.close():__HuxNav__.open()}),document.addEventListener("click",function(e){if(e.target==$toggle)return;if(e.target.className=="icon-bar")return;__HuxNav__.close()})</script><div class=search-page><div class=search-icon-close-container><span class=search-icon-close><i class="fa fa-chevron-down"></i></span></div><div class="search-main container"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><form></form><input type=text id=search-input placeholder=内容搜索...></form><div id=search-results class=mini-post-list></div></div></div></div></div><style type=text/css>header.intro-header{position:relative;background-image:url('')}</style><header class="intro-header style-text"><div class=header-mask></div><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/icorer_blog/tags/redis/ title=redis>redis</a>
<a class=tag href=/icorer_blog/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/ title=缓存技术>缓存技术</a>
<a class=tag href=/icorer_blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/ title=数据库技术>数据库技术</a></div><h1>Redis Client Side Cache - Redis客户端缓存 - RedisConf18</h1><h2 class=subheading></h2><span class=meta>Posted by LB
on Sun, Mar 15, 2020</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h3 id=一-背景描述>一. 背景描述<a class=anchorjs-link href=#%e4%b8%80-%e8%83%8c%e6%99%af%e6%8f%8f%e8%bf%b0></a></h3><p>客户端缓存是一个有意思的话题，它不是空穴来风的技术，在最新的Redis RC版本已经正式开始着手CSC方案的设计，虽然目前版本的CSC还不能真正的商用，但是市面上也有一些其他公司开始着手试探CSC相关方案的设计与实现。</p><p>目标比较有名的模型是两种：</p><ol><li>Ben Malec paylocity公司方案</li><li><a href=/icorer_blog/img/index.php/archives/458/ title="Redis6 RC方案" target=_blank>Redis6 RC方案</a></li></ol><p>这两种方案并不是独立的，他们各有各的优势，paylocity公司的方案被redis团队所赞赏，并吸收了一些思路进入Redis RC版本中，Redis RC版本主要是提供了一些server端的协助，但是本质上还是没有完整的CSC方案。</p><h3 id=二-redisconf2018大会-ben-malec分享>二. RedisConf2018大会 Ben Malec分享<a class=anchorjs-link href=#%e4%ba%8c-redisconf2018%e5%a4%a7%e4%bc%9a-ben-malec%e5%88%86%e4%ba%ab></a></h3><p>这里，我们将阐述RedisConf 2018年的经典分享，这个分享围绕CSC机制的相关设计与实现，并且方案已经被广泛使用在paylocity公司，有很高的的借鉴意义。<figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/224375385.png data-action=zoom alt class=lazyload></a></figure><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/1440735567.png data-action=zoom alt class=lazyload></a></figure></p><p>Ben Malec的分享主要围绕如何实现一个和Redis缓存同步的本地内存缓存。</p><p>首先，我们看一下简单的网站模型，模型图如下：</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/1648651003.png data-action=zoom alt class=lazyload></a></figure><strong>接着，Ben提出很重要的缓存象限，缓存象限图如下所示：</strong></p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/4215809206.png data-action=zoom alt class=lazyload></a></figure><strong>缓存最好的应用场景就是针对更改少、请求频繁的数据读写场景。</strong></p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/1191837373.png data-action=zoom alt class=lazyload></a></figure></p><p>客户端缓存，首先需要面对的问题就是 “<strong>缓存数据滞后</strong>”</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/400601853.png data-action=zoom alt class=lazyload></a></figure>这部分演讲，Ben发散思维了所有Web服务器尝使用的“文件系统观察”功能。</p><p>随后，客户端缓存会出现“<strong>跨服务器缓存数据不一致</strong>”问题。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/3111180058.png data-action=zoom alt class=lazyload></a></figure>这种问题并不是只会在不同的机器间出现，还会在同一台机器不同进程中出现。</p><p>比如在两台机器针对缓存都设置了相同的TTL生命期，但是由于机器间时间可能不同步，从而造成缓存不一致情况。更坏的情况就是，数据已经更新了，但是客户端缓存没办法及时更新，造成用户请求到旧的数据，如果再多台机器负载的情况下，极有可能出现一会新值、一会旧值得问题，这种飘忽不定的缓存返回会造成用户较差的使用体验。</p><p>接下来，Ben提出一个很重要的时间观点，服务器间想在<strong>大约相同的时间</strong>内更新相关的key，这个大约相同的时间证明这个缓存方案并不一定能够满足分布式强一致，只是在合理的时间范围内数据一致。</p><p>接下来，Ben提出第三个缓存问题，“<strong>缓存踩踏</strong>”问题</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/682601984.png data-action=zoom alt class=lazyload></a></figure></p><p>这里所说的就是如果自己完全制作一个进程内缓存，有很多需要考虑，比如启动数据加载，数据池的备份，服务器扩容过程，等等问题。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/2084904826.png data-action=zoom alt class=lazyload></a></figure></p><p>Redis可以提供简单的缓存解决方案。</p><p>Redis缓存可以很好地解决缓存一致性问题，也可以解决缓存数据滞后问题，也不会有数据践踏。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/3025310649.png data-action=zoom alt class=lazyload></a></figure></p><p>但是redis也有一些其他问题，比如每次缓存获取都需要tcp往返通信，虽然redis已经很快了，但是本地内存的访问速度仍然比网络io速度高太多。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/126326365.png data-action=zoom alt class=lazyload></a></figure></p><p>这里，Ben提出如果在redis基础上，再增加进程内缓存，效果就会更好了。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/180649881.png data-action=zoom alt class=lazyload></a></figure></p><p>针对这种本地缓存方案，首先提出了三个需要做的事情：</p><ol><li>解决数据一致性问题</li><li>解决数据滞后问题，主要围绕进程内缓存和远程redis之间的滞后问题</li><li>不要让网络爆炸，要控制合理的网络通信</li></ol><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/1963327491.png data-action=zoom alt class=lazyload></a></figure></p><p>借助redis，我们是不是可以更好的实现这个功能呢？</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/63103800.png data-action=zoom alt class=lazyload></a></figure></p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/1391917950.png data-action=zoom alt class=lazyload></a></figure></p><p>上面这部分讲述了一个问题，如果我们想让机器间的数据保证一致性，如果仅仅通过广播变更的key-value，这将是致命的，因为大量的key-value将引爆网络，还有一个原因就是你广播了key-value数据，并不是所有的节点以后都会使用，这就会造成效率问题，这些问题几乎都是围绕网络，但是还没考虑网络的质量问题，比如网络质量很差的情况下，节点可能收到多组不同的改动，这些改动可能会数据践踏，但是你不知道践踏的顺序，从而造成数据的不一致问题。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/2193686483.png data-action=zoom alt class=lazyload></a></figure></p><p>因此，我们并不是广播key-value，而是只广播key，但是你也知道redis支持key数据，最大可以达到512MB，就算不是512MB，就算是1kb的数据，我们的网络就能抗住吗，所以简单的广播key是不理智的。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/3884979063.png data-action=zoom alt class=lazyload></a></figure></p><p>redis集群中采用hash槽位来进行数据分片，那么我们是否可以借鉴这种思路呢？我们不再广播key，而是广播key所计算的hash值，这样如果key的数据多么大，我们都能控制在网络上传输的数据大小。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/888530507.png data-action=zoom alt class=lazyload></a></figure></p><p>我们放弃了广播key，而选择同步16bit的key hash槽数据，这样操作的优势明显，首先广播数据的大小被控制了，并且解决了数据一致性问题，我们只是广播hash，并没有广播数据，当某个hash出现了脏数据，它将会在下次访问时被感知并被更新。这个也有一点缺陷需要注意，因为我们借助了hash槽位，所以一个hash slot上会包含很多key，这些key中的一个被更新，则这组hash slot都将失效。</p><p>计算遍历所有的 key 吗？命中脏 slots 的话，就删除这个key？但是这样的话相当于对每一个缓存更新操作，客户端都要遍历计算一遍自己所有 key 的 slot，显然是不可接受的。</p><p>这里也是采用<strong>惰性计算</strong>的思想：客户端收到了 slot 更新的广播，只把 slot 存起来，当真正用到在此 slot 中的 key 的时候才去 Redis 更新。那么就会有这样一种情况，slot 中部分 key 更新了，部分 key 没有更新，如何区分开哪些 key 已经在 slot 更新之后更新过了呢？这里只要记一下 slot 更新的 timestamp 就可以，每一个 key-value 也带有一个 timestamp 属性。如果 key 的 timestamp 早于 slot 的 timestamp，那 key 就是需要更新的；更新之后 key 的 timestamp 就晚于 slot 的 timestamp 了。下次可以直接用。</p><p>上面所述的hash slot范围影响问题，并不是不可以缓解的，redis6中提议采用更长的hash算法，支持千万个slot，从而降低数据碰撞率，从而环节hash slot更新影响问题。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/780285920.png data-action=zoom alt class=lazyload></a></figure></p><p>针对hash slot部分，我们需要在客户端内维护一个lastUpdated数组，这个数组用来记录hash slot的更新时间，这里，<strong>需要特别强调一点，这个hash slot时间戳，一定是客户端本机时间戳</strong>。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/2161417761.png data-action=zoom alt class=lazyload></a></figure></p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/4254179159.png data-action=zoom alt class=lazyload></a></figure></p><p>上图是一个关键的数据结构图，这个lastUpdated 存放着所有hash槽位最后更新的本地时间，通过提前预分配空间，可以降低查询索引时间复杂度到o(1)。右面的是客户端内的缓存结构，每一个key都对应着一个数据结构，数据体结构中包括<strong>hash槽位</strong>、<strong>最后写入客户端缓存的时间，<strong>还有</strong>数据体</strong>。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/857777103.png data-action=zoom alt class=lazyload></a></figure></p><p>上图展示的是客户端缓存的读取操作流程，从流程中可以看出：</p><ul><li>如果已经检测到客户端进程内有所对应的缓存，则读取最后一次更新的时间戳，如果时间戳已经过期，则进行远程Redis的读取和本地更新操作，如果时间戳没有过期，则返回缓存给客户请求。</li><li>如果客户端进程内没有所对应的缓存数据，则读取远程redis的缓存数据，计算key所对应的hash槽数据，把缓存写入到进程内，并返回缓存响应给客户端。</li></ul><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/3401773578.png data-action=zoom alt class=lazyload></a></figure></p><p>增加一个数据进入缓存的主要流程包括：</p><ol><li>获取当前时间戳</li><li>计算key所对应的哈希槽位数据</li><li>写入数据到redis服务器</li><li>写入缓存数据、时间戳信息到客户端缓存内部</li><li>发布update信号到所有的client，发布的信息不是每个key，而是hash</li></ol><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/1589208017.png data-action=zoom alt class=lazyload></a></figure></p><p>虽然从上面的读写操作看来，似乎流程是没问题的，但是还有一些挑战性的计时问题，这个问题将是最大的问题，任何一个系统都不想访问已经更新过数据的旧数据。我们使用同步消息更新lastUpdated数组，但是这种更新可能随时都会存在。</p><p>特别是在高频请求，或者hash slot数量不多、但是存储的缓存量很大，会出现频繁的数据更新信号、数据读写过程冲突问题，这个问题是很头疼的问题，我们该如何解决这种冲突？</p><p>解决上面的这个问题，我们当然可以使用分布式方案进行优化、比如redis分布式锁。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/2839540389.png data-action=zoom alt class=lazyload></a></figure></p><p>我们总是关注并发和一致性之间的问题解决。采用分布式锁解决一致性问题看似非常合适，但是基本丧失了并发性。因为每个并发单元均需要等待锁的释放。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/2981628834.png data-action=zoom alt class=lazyload></a></figure></p><p>我们目前没有采用分布式锁、master时钟的方案，而是进行了操作的顺序化设计，非常仔细的设计了操作顺序。</p><p><strong>这部分非常关键，有很多细节需要注意，主要包括以下几点</strong>：</p><ol><li><strong>所有的 timestamp 都是 server本地时间戳</strong>：获得了 slot 更新的消息，将 slot 的更新时间设定为当前 local timestamp；进程更新 key 了，进程将 key 的更新时间设定为 local timestamp。实际上，timestamp 已经当成一个相对于本地 server 的<strong>偏移量</strong>来用了，无论是不同进程之间的时间如何偏移不准，都没有影响。</li><li>必须<strong>先更新 Redis，Redis 更新完成之后再广播更新消息</strong>（再次强调，<strong>Redis 作为 Source of the Truth</strong>）。</li><li><strong>在更新 Redis、in-process cache 之前就获取 timestamp</strong>，这一步很关键。这里解释一下为什么要先获取 current timestamp 再进行更新：其根本目的是 slot key 的 timestamp 就尽量提前。如果在 Get current timestamp 之前收到了 slot update message，那么我们的更新操作一定发生在其他进程的更新操作之后，没有毛病；如果在 Get current timestamp 之后收到了 slot update message，那么不管如何，我们的 key timestamp 会落后收到的 slot timestamp，会去 redis 获取，也没有毛病。假设这里先更新完再获取 timestamp，会有这么一种情况：我们更新好了 in-process cache，这时候来了一条 slot update message，我们更新了这个 slot 的 timestamp，然后我们自己的更新操作到了获取 timestamp 这一步，我们记录了自己的 key timestamp 和 slot timestamp。就造成了我们的 key 更新时间实际上晚于真正的 key 更新时间，我们保存了一个过时的 key 却不知道。</li></ol><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/2109470553.png data-action=zoom alt class=lazyload></a></figure></p><p><strong>上图很重要，展示了一个更新顺序：</strong></p><ol><li><code>#1</code>第一步更新远程redis缓存</li><li><code>#1</code>第二部发布推送、通知其他机器数据更新</li><li><code>#2</code>到远程redis去取数据，并把最新的redis缓存数据存储在自己的进程内。</li></ol><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/1140848589.png data-action=zoom alt class=lazyload></a></figure></p><p>这还有一个边界情况，这是一个计算机时间戳的边界条件。我们正在使用时间戳，它的分辨率是300纳秒，这也就意味着冲突可能发生在300纳秒间，在这个时间段内，一方面我们接收到了更新信号，一方面我们需要读写数据，在这个最小计算机时间周期内，他们可以被认为是统一时间发生的。</p><p><strong>这个情况就是在一个 timestamp 分辨率下，客户端更新缓存，但同时收到了 slot 更新的消息。即客户端 key 的 timestamp 是 a，但是在 a 这个 timestamp 的同时其他进程更新了缓存，这个时候 timestamp a 依然是正确的，但其实缓存住的是一个过时的 key。</strong></p><p>其实这个发生的概率太小了，timestamp 的精度是 300ns 的话，必须在 300ns 内更新完 redis 缓存和 in-process 缓存，收到 sync 消息，才有可能发生——但是依然有概率发生的。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/2076144566.png data-action=zoom alt class=lazyload></a></figure></p><p>这里Ben提到了一个很简单的解决方案，但是我被这种简单的方案背后的智慧所震撼，如果时间戳更新的频率是300纳秒，那么我们只需要针对开始操作的时间戳进行 减1操作。</p><p><strong>获取时间戳 之后之后总是 -1</strong>（其实不必-1，减一个 timestamp 精度就可以）。这样就保证收到同步消息时，客户端总是倾向于缓存脏了、去 redis 获取。如果发生一个 时间戳精度内出现缓存更新和收到同步更新消息，那么客户端实际缓存更新的时间肯定晚于其他进程更新缓存的时间，因为本地客户端把时间调快了，所以客户端保存的 key 是新的。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/3245613928.png data-action=zoom alt class=lazyload></a></figure></p><p>Ben针对自己的客户端缓存方案，还提了几点优化方案：</p><ol><li><p>早期测试显示Redis的命中率比预期高</p><ul><li>根本原因是客户端正在处理更新发布/订阅他们发布的消息，因为他们正在处理自己刚刚发布到redis的缓存数据。</li><li>解决方案是让发布/订阅处理程序忽略以下消息：源自相同的缓存提供程序实例</li></ul></li><li><p>更新Redis包括执行两个Redis命令，一个更新值，第二个通知其他客户端数据变化。</p><ul><li>但是我们不想发生两次TCP往返。</li><li>Lua脚本可以解决！</li></ul></li></ol><p>针对第一个问题，这是个因为订阅广播而造成的重复处理问题，这个问题可以通过在广播阶段增加一个client id，这个client id可以是一个ip、mac地址，或者一个配置好的唯一ID，从而避免重复处理。</p><p>针对第二个问题，更新远程redis需要一次tcp交互、广播通知客户端也需要一次tcp交互，因此可以借助lua进行统一操作，由lua进行远程redis的更新和广播通知。</p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/1389257723.png data-action=zoom alt class=lazyload></a></figure></p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/634176684.png data-action=zoom alt class=lazyload></a></figure></p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/286204077.png data-action=zoom alt class=lazyload></a></figure></p><p><figure><a class=paragraph-image><img data-src=https://icorer.com/icorer_blog/img/usr/uploads/2020/03/2882306941.png data-action=zoom alt class=lazyload></a></figure></p><h3 id=三-问题阶段>三. 问题阶段<a class=anchorjs-link href=#%e4%b8%89-%e9%97%ae%e9%a2%98%e9%98%b6%e6%ae%b5></a></h3><h4 id=31-客户端缓存能够快多少>3.1 客户端缓存能够快多少？<a class=anchorjs-link href=#31-%e5%ae%a2%e6%88%b7%e7%ab%af%e7%bc%93%e5%ad%98%e8%83%bd%e5%a4%9f%e5%bf%ab%e5%a4%9a%e5%b0%91></a></h4><p>根据具体的硬件可能会不同，但是大概会在40 - 45 倍的性能。</p><h4 id=32-当众多客户端中某一个客户端没有收到订阅消息如何处理>3.2 当众多客户端中某一个客户端没有收到订阅消息，如何处理？<a class=anchorjs-link href=#32-%e5%bd%93%e4%bc%97%e5%a4%9a%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%ad%e6%9f%90%e4%b8%80%e4%b8%aa%e5%ae%a2%e6%88%b7%e7%ab%af%e6%b2%a1%e6%9c%89%e6%94%b6%e5%88%b0%e8%ae%a2%e9%98%85%e6%b6%88%e6%81%af%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86></a></h4><p>首先，这种情况很少见，针对这种情况，我们可以针对数据set进行一个ttl设置。</p><p>针对这点，我有一点想法，客户端缓存的场景主要是解决远程redis的效率或者网路io问题，这个并不是万能钥匙，因此hash slot不能太大，合适非范围可以让客户端缓存的订阅依赖性下降，让客户端缓存既分担远程redis的压力，也能提高缓存性能。</p><p>相关材料：</p><ol><li><a href="https://www.youtube.com/watch?v=kliQLwSikO4" target=_blank>https://www.youtube.com/watch?v=kliQLwSikO4</a></li><li><a href=https://www.slideshare.net/RedisLabs/redisconf18-techniques-for-synchronizing-inmemory-caches-with-redis target=_blank>https://www.slideshare.net/RedisLabs/redisconf18-techniques-for-synchronizing-inmemory-caches-with-redis</a></li><li><a href=https://www.kawabangga.com/posts/3590 target=_blank>https://www.kawabangga.com/posts/3590</a></li></ol><hr style=visibility:hidden><ul class=pager><li class=previous><a href=/icorer_blog/posts/getting-to-go-the-journey-of-gos-garbage-collector/ data-toggle=tooltip data-placement=top title="Go的垃圾收集者之旅 [Getting to Go: The Journey of Go's Garbage Collector]">Previous<br><span>Go的垃圾收集者之旅 [Getting to Go: The Journey of Go's Garbage Collector]</span></a></li><li class=next><a href=/icorer_blog/posts/related-design-of-redis6-client-cache/ data-toggle=tooltip data-placement=top title=Redis6客户端缓存的相关设计>Next<br><span>Redis6客户端缓存的相关设计</span></a></li></ul><hr style=visibility:hidden></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5>FEATURED TAGS</h5><div class=tags><a href=/icorer_blog/tags/blockchain/>blockchain</a>
<a href=/icorer_blog/tags/clang/>CLang</a>
<a href=/icorer_blog/tags/cloudnative/>cloudnative</a>
<a href=/icorer_blog/tags/cmake/>Cmake</a>
<a href=/icorer_blog/tags/deca/>DeCA</a>
<a href=/icorer_blog/tags/dpki/>DPKI</a>
<a href=/icorer_blog/tags/drand/>drand</a>
<a href=/icorer_blog/tags/eip/>EIP</a>
<a href=/icorer_blog/tags/epoll/>epoll</a>
<a href=/icorer_blog/tags/ethereum/>Ethereum</a>
<a href=/icorer_blog/tags/fpga/>FPGA</a>
<a href=/icorer_blog/tags/gc/>GC</a>
<a href=/icorer_blog/tags/golang/>GoLang</a>
<a href=/icorer_blog/tags/hackathon/>Hackathon</a>
<a href=/icorer_blog/tags/http2/>HTTP2</a>
<a href=/icorer_blog/tags/http3/>HTTP3</a>
<a href=/icorer_blog/tags/icefiredb/>IceFireDB</a>
<a href=/icorer_blog/tags/k8s/>k8s</a>
<a href=/icorer_blog/tags/kafka/>kafka</a>
<a href=/icorer_blog/tags/layer2/>Layer2</a>
<a href=/icorer_blog/tags/linux/>linux</a>
<a href=/icorer_blog/tags/nginx/>Nginx</a>
<a href=/icorer_blog/tags/nosql/>NoSQL</a>
<a href=/icorer_blog/tags/php/>PHP</a>
<a href=/icorer_blog/tags/php-kernel/>php kernel</a>
<a href=/icorer_blog/tags/php%E5%86%85%E6%A0%B8/>PHP内核</a>
<a href=/icorer_blog/tags/quic/>QUIC</a>
<a href=/icorer_blog/tags/redis/>redis</a>
<a href=/icorer_blog/tags/sbt/>SBT</a>
<a href=/icorer_blog/tags/serverless/>serverless</a>
<a href=/icorer_blog/tags/ssi/>SSI</a>
<a href=/icorer_blog/tags/unikernel/>unikernel</a>
<a href=/icorer_blog/tags/wanxiang/>Wanxiang</a>
<a href=/icorer_blog/tags/web3/>web3</a>
<a href=/icorer_blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件</a>
<a href=/icorer_blog/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a>
<a href=/icorer_blog/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/>以太坊</a>
<a href=/icorer_blog/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/>信息安全</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/>内存数据库</a>
<a href=/icorer_blog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/>内存泄漏</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/>内核源码</a>
<a href=/icorer_blog/tags/%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6/>内核研究</a>
<a href=/icorer_blog/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/>区块链</a>
<a href=/icorer_blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>垃圾回收</a>
<a href=/icorer_blog/tags/%E5%AD%98%E5%82%A8/>存储</a>
<a href=/icorer_blog/tags/%E5%AE%B9%E5%99%A8/>容器</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/>底层开发</a>
<a href=/icorer_blog/tags/%E5%BA%95%E5%B1%82%E7%A0%94%E7%A9%B6/>底层研究</a>
<a href=/icorer_blog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/>开源项目</a>
<a href=/icorer_blog/tags/%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97/>异构计算</a>
<a href=/icorer_blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a>
<a href=/icorer_blog/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/>性能测试</a>
<a href=/icorer_blog/tags/%E6%8A%80%E6%9C%AF%E7%A7%91%E6%99%AE/>技术科普</a>
<a href=/icorer_blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/>数据库技术</a>
<a href=/icorer_blog/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/>文章翻译</a>
<a href=/icorer_blog/tags/%E6%96%B0%E6%9E%B6%E6%9E%84/>新架构</a>
<a href=/icorer_blog/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/>时序数据库</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/>服务治理</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/>服务网格</a>
<a href=/icorer_blog/tags/%E6%9C%8D%E5%8A%A1%E9%81%A5%E6%B5%8B/>服务遥测</a>
<a href=/icorer_blog/tags/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/>测试报告</a>
<a href=/icorer_blog/tags/%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/>研究报告</a>
<a href=/icorer_blog/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/>缓存技术</a>
<a href=/icorer_blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a>
<a href=/icorer_blog/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/>虚拟机</a>
<a href=/icorer_blog/tags/%E8%A1%8C%E4%B8%9A%E6%8A%A5%E5%91%8A/>行业报告</a>
<a href=/icorer_blog/tags/%E8%AE%BA%E6%96%87/>论文</a>
<a href=/icorer_blog/tags/%E9%9B%B6%E4%BF%A1%E4%BB%BB/>零信任</a>
<a href=/icorer_blog/tags/%E9%AB%98%E6%80%A7%E8%83%BD/>高性能</a></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=/icorer_blog/index.xml><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-rss fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/lb_icefirelabs><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/gitsrc><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i>
<i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 笔迹-工匠之芯 2023</p></div></div></div></footer><script src=/icorer_blog/js/jquery.min.js></script>
<script src=/icorer_blog/js/bootstrap.min.js crossorigin=anonymous></script>
<script src=/icorer_blog/js/hux-blog.min.c4ea77041cd3edbfc8b2622cd887a9a5d8760a4162d14489e36d2a3fa4c90172.js></script>
<script src=/icorer_blog/js/simple-jekyll-search.min.js></script>
<script src=/icorer_blog/js/search.min.7d1445cf07369bca2715d9f63738c16c73a7a2273a95d6729bee561f7e84c6c8.js></script>
<script src=/icorer_blog/zoomjs/zoom.min.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VB37D8LWFT"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VB37D8LWFT")</script></body></html>